---
id: min-cut
title: 'Minimum Cut'
author: Benjamin Qi
prerequisites:
  - max-flow
description: '?'
frequency: 1
---

## Resources

The resources below include many clever applications of min cut, including the
[Closure Problem](https://en.wikipedia.org/wiki/Closure_problem).

<Resources>
	<Resource
		source="CPC"
		title="10 - Network Flow"
		url="10_graphs_3_network_flow"
		starred
	>
		Slides from "Algorithm Design." Min-Cut Max-Flow Theorem, applications of
		flow / min cut.
	</Resource>
</Resources>

## Minimum Node Covers

<FocusProblem problem="minEx" />

<Resources>
	<Resource source="CPH" title="20.3 - Maximum Matchings" starred>
		brief mentions of Hall's Theorem, Konig's Theorem
	</Resource>
</Resources>

### Solution - Coin Grid

This problem asks us to find a **minimum node cover** of a bipartite graph.
Construct a flow graph with vertices labeled $0\ldots 2N+1$, source $0$, sink
$2N+1$, and the following edges:

- Edges from $0\to i$ with capacity $1$ for each $1\le i\le N$. Cutting the
  $i$-th such edge corresponds to choosing the $i$-th row.
- Edges from $N+i\to 2N+1$ with capacity $1$ for each $1\le i\le N$. Cutting the
  $i$-th such edge corresponds to choosing the $i$-th column.
- If there exists a coin in $(r,c)$ add an edge from $r\to N+c$ with capacity
  $\infty$.

First we find a max flow, which tells us the number of edges with capacity 1 we
need to cut. To find the min cut itself, BFS from the source once more time.
Edges $(a,b)$ connecting vertices that are reachable from the source
(`lev[a] != -1`) to vertices that aren't (`lev[b] == -1`) are part of the
minimum cut. In this case, each of these edges must be of the form $(0,i)$ or
$(i+N,2N+1)$ for $1\le i\le N$. Each cut edge corresponds to a row or column we
remove coins from.

Note that edges of the form $r\to N+c$ can't be cut because they have capacity
$\infty$.

```cpp
struct Dinic {     // flow template
	using F = ll;  // flow type
	struct Edge {
		int to;
		F flo, cap;
	};
	int N;
	V<Edge> eds;
	V<vi> adj;
	void init(int _N) {
		N = _N;
		adj.rsz(N), cur.rsz(N);
	}
	/// void reset() { trav(e,eds) e.flo = 0; }
	void ae(int u, int v, F cap, F rcap = 0) {
		assert(min(cap, rcap) >= 0);
		adj[u].pb(sz(eds));
		eds.pb({v, 0, cap});
		adj[v].pb(sz(eds));
		eds.pb({u, 0, rcap});
	}
	vi lev;
	V<vi::iterator> cur;
	bool bfs(int s, int t) {  // level = shortest distance from source
		lev = vi(N, -1);
		F0R(i, N) cur[i] = begin(adj[i]);
		queue<int> q({s});
		lev[s] = 0;
		while (sz(q)) {
			int u = q.ft;
			q.pop();
			trav(e, adj[u]) {
				const Edge &E = eds[e];
				int v = E.to;
				if (lev[v] < 0 && E.flo < E.cap) q.push(v), lev[v] = lev[u] + 1;
			}
		}
		return lev[t] >= 0;
	}
	F dfs(int v, int t, F flo) {
		if (v == t) return flo;
		for (; cur[v] != end(adj[v]); cur[v]++) {
			Edge &E = eds[*cur[v]];
			if (lev[E.to] != lev[v] + 1 || E.flo == E.cap) continue;
			F df = dfs(E.to, t, min(flo, E.cap - E.flo));
			if (df) {
				E.flo += df;
				eds[*cur[v] ^ 1].flo -= df;
				return df;
			}  // saturated >=1 one edge
		}
		return 0;
	}
	F maxFlow(int s, int t) {
		F tot = 0;
		while (bfs(s, t))
			while (F df = dfs(s, t, numeric_limits<F>::max())) tot += df;
		return tot;
	}
};

int main() {
	int n;
	re(n);
	Dinic D;
	D.init(2 * n + 2);
	F0R(i, n) {
		D.ae(0, i + 1, 1);
		D.ae(i + 1 + n, 2 * n + 1, 1);
		F0R(j, n) {
			char c;
			re(c);
			if (c == 'o')
				D.ae(i + 1, j + 1 + n, MOD);  // some big capacity -> not cut
		}
	}
	ps(D.maxFlow(0, 2 * n + 1));
	D.bfs(0, 2 * n + 1);
	FOR(i, 1, n + 1) if (D.lev[i] < 0) ps(1, i);  // edge from 0 to i is cut
	FOR(i, 1, n + 1)
	if (D.lev[i + n] >= 0) ps(2, i);  // edge from i+n to 2*n+1 is cut
}
```

## Minimum Path Covers

<FocusProblem problem="pathEx" />

<Resources>
	<Resource source="CPH" title="20.4 - Path Covers" starred>
		brief mentions of node-disjoint and general path covers, Dilworth's theorem
	</Resource>
	<Resource
		source="Wikipedia"
		title="Dilworth's Theorem"
		url="https://en.wikipedia.org/wiki/Dilworth%27s_theorem#Proof_via_K%C5%91nig's_theorem"
	>
		proof via Konig's theorem
	</Resource>
</Resources>

### Solution - The Wrath of Kahn

Ignore all vertices of $G$ that can never be part of $S$. Then our goal is to
find the size of a maximum antichain in the remaining graph, which as mentioned
in CPH is just an instance of maximum path cover.

```cpp
TopoSort<500> T;
int n, m;
bool link[500][500];
vi out[500];
Dinic<1005> D;

int main() {
	setIO();
	re(n, m);
	F0R(i, m) {
		int x, y;
		re(x, y);
		T.ae(x, y);
		link[x][y] = 1;
	}
	F0R(k, n) F0R(a, n) F0R(b, n) link[a][b] |= link[a][k] & link[k][b];
	T.sort(n);
	vi bad;
	F0R(i, n) if (T.in[i]) bad.pb(i);  // cannot be part of S
	trav(a, bad) F0R(i, n) link[a][i] = link[i][a] = 0;
	F0R(i, n) {
		D.ae(2 * n, i, 1);
		D.ae(i + n, 2 * n + 1, 1);
	}
	F0R(i, n) F0R(j, n) if (link[i][j]) D.ae(i, n + j, 1);
	int chain = n - sz(bad) - D.maxFlow(2 * n + 2, 2 * n, 2 * n + 1);
	ps(chain);
}
```

## Problems

<Problems problems="cut" />
