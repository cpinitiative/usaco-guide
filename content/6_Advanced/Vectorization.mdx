---
id: vectorization
title: Vectorization in C++
author: Benjamin Qi, Aryansh Shrivastava
description: '?'
frequency: 0
---

[Pragmas](https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html) provide additional
information to the compiler. Sometimes you'll see the following lines at the
beginning of a program.

```cpp
#pragma GCC optimize("Ofast")
#pragma GCC target("avx2")
```

## About

<Resources>
	<Resource
		source="CF"
		title="GCC Optimization Pragmas"
		url="https://codeforces.com/blog/entry/96344"
	/>
	<Resource
		source="GCC"
		title="3.11 - Optimization Options"
		url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"
	/>
	<Resource
		source="KACTL"
		title="10.5.2 - Pragmas"
		url="https://github.com/kth-competitive-programming/kactl/blob/master/kactl.pdf"
	/>
	<Resource
		source="CF"
		title="What do SSE/AVX do?"
		url="https://codeforces.com/blog/entry/54682?#comment-387553"
	/>
	<Resource
		source="CF"
		title="Speeding Up for Naive Algorithm"
		url="https://codeforces.com/blog/entry/66279"
	/>
	<Resource
		source="CodinGame"
		title="SSE & AVX Vectorization"
		url="https://www.codingame.com/playgrounds/283/sse-avx-vectorization/autovectorization"
	>
		some bugs :(, seems ok for most part?
	</Resource>
</Resources>

According to KACTL:

- `#pragma GCC optimize ("Ofast")` will make GCC auto-vectorize for loops and
  optimizes floating points better (assumes associativity and turns off
  [denormals](https://en.wikipedia.org/wiki/Denormal_number)).
- `#pragma GCC target ("avx,avx2")` can double performance of vectorized code,
  but causes crashes on old machines.

 <!-- - Also consider the older `#pragma GCC target ("sse4")`. -->

According to CodinGame,

> Modern CPUs can execute up to four instructions at the same time if they are
> independent.

Can also check Wikipedia articles about
[SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions) and
[AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) (AVX is the more
advanced version).

<!-- <IncompleteSection>

better source to learn about these?

</IncompleteSection> -->

## Examples from CF

The occasional Div 1 E is trivialized by this!

<!-- - [`unroll-loops`](https://codeforces.com/contest/855/submission/89815160): TLE 49 -->
<!-- - [`Ofast`, `unroll-loops`](https://codeforces.com/contest/855/submission/89815262): 3509ms -->

- [Nagini](https://codeforces.com/contest/855/submission/47823825)
  - [no pragmas](https://codeforces.com/contest/855/submission/89815214): TLE 30
  - [`O3`](https://codeforces.com/contest/855/submission/89815479): 3509ms
  - [`Ofast`](https://codeforces.com/contest/855/submission/89815327): 3525ms
  - [`Ofast`, `avx`](https://codeforces.com/contest/855/submission/72962496):
    2339ms
  - [`Ofast`, `avx2`](https://codeforces.com/contest/855/submission/72962508):
    1544ms
  - [`Ofast`, `sse4`](https://codeforces.com/contest/855/submission/72962469):
    2479ms
- [Welcome home, Chtholly](https://codeforces.com/contest/896/submission/47824007)
  - only `Ofast`: TLE
  - `avx`: 2354ms
  - `avx2`: 1684ms
  - `sse4`: 2183ms
- [Awesome Substrings](https://codeforces.com/contest/1270/submission/68018017)
  - `sse4` / `avx`: TLE
  - `avx2`: 6894ms

## Where Can I Use These?

Whether these pragmas are supported depends on the computer architecture (see
[here](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#x86-Options)).

- `Ofast` with `avx2` works on CF and DMOJ.
- `sse4` and `avx` cause runtime errors on InfoArena and
  [SzkopuÅ‚](https://szkopul.edu.pl/). However,
  `#pragma GCC optimize("unroll-loops")` seems to work on InfoArena (compare
  [TLE](https://www.infoarena.ro/job_detail/2641920) and
  [AC](https://www.infoarena.ro/job_detail/2641921)).
- These have occasionally worked on past USACO problems, such as the unintended quadratic time solution at the end of [this problem](http://www.usaco.org/current/data/sol_prob3_silver_open22.html).

## Why Should I _Not_ Use These?

From [this comment](https://codeforces.com/blog/entry/66279?#comment-502965):

> To everyone who doesn't know what's going on here: seems that topicstarter
> doesn't know it either, and it looks like some magic for him.

It's **not** a good idea to include these pragmas at the start of every program.
As mentioned above, these pragmas cause RE on some sites. Other times, they are
just ignored by the compiler, or even worse, they might make your code slower
instead of faster (ex. see
[here](https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2)).

<!-- Anyways, keep in mind that these rarely make a difference in competitive programming. -->

<!-- <IncompleteSection /> -->

## Example - Ligatures

<FocusProblem problem="tutorial" />

The problem involves counting the occurrences of specific pairs of characters (ligatures) in a given text corpus based on multiple sets of suggested ligatures. The primary challenge is efficiently handling large input sizes and ensuring that the counting process respects the rule that ligatures can't overlap.

### Solution

This solution to the problem uses SIMD (Single Instruction, Multiple Data) parallelism to efficiently count the occurrences of suggested ligatures within a large corpus:

**Overview**
1. **Preprocessing the Corpus**:
- The corpus is preprocessed to identify all pairs of consecutive characters, which are stored in a pairs vector.

2. **Setting Up Bitmasks**:
- A bitmask array active is set up where each bit represents whether a specific ligature is part of a query.
The bitmask for each query is configured such that each suggested ligature toggles a specific bit.

3. **Counting Occurrences Using SIMD**:
- The core of the solution utilizes SIMD instructions to parallelize the counting process.
The program processes the corpus in chunks, accumulating counts for each query simultaneously using AVX2 intrinsics.

**Time Complexity:** $\mathcal{O}(\mathcal{N} + \mathcal{Q} * \mathcal{K})$

<LanguageSection>
<CPPSection>

```cpp
#pragma GCC target ("avx2")
#include <iostream>
#include <vector>
#include <string>
#include <immintrin.h>
using namespace std;

#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define trav(a, x) for (auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;

const int SIMD_BITS = 256;
const int MAXQ = 100'000;

typedef __m256i mi;

void set_bit(mi& m, size_t ind) {
	union {
		mi m;
		uint32_t ar[SIMD_BITS / 32];
	} u;
	u.m = m;
	u.ar[ind / 32] = (uint32_t) (u.ar[ind / 32] | (1 << (ind % 32)));
	m = u.m;
}

void printm(mi m) {
	union {
		mi m;
		uint32_t ar[SIMD_BITS / 32];
	} u;
	u.m = m;
	rep(i,0,SIMD_BITS) {
		cout << ((u.ar[i / 32] >> (i % 32)) & 1);
	}
	cout << endl;
}


mi active[MAXQ / SIMD_BITS + 1][26*26+1]{}; // ~26*26 * MAXQ / 8 bytes

int main() {
	cin.sync_with_stdio(false);
	cin.exceptions(cin.failbit);
	int N, Q, K;
	cin >> N >> Q >> K;
	string str, s;
	cin >> str;
	N--;
	int padN = (N + 31) & -32;
	int qchunks = Q / SIMD_BITS + 1;
	vector<short> pairs(padN);
	rep(i,0,N) {
		int a = str[i] - 'a';
		int b = str[i+1] - 'a';
		pairs[i] = (short)((26*a + b) * sizeof(mi));
	}
	rep(i,N,padN) {
		pairs[i] = 26*26 * sizeof(mi);
	}

	rep(i,0,Q) {
		cin >> s;
		rep(j,0,K) {
			int a = s[2*j] - 'a';
			int b = s[2*j+1] - 'a';
			set_bit(active[i / SIMD_BITS][26*a + b], i % SIMD_BITS);
		}
	}

	vi res(qchunks * SIMD_BITS);
	rep(k,0,qchunks) {
		char* act = (char*)active[k];
		int i = 0;
		mi zero = _mm256_setzero_si256();
		mi acc0 = zero, acc1 = zero, acc2 = zero, acc3 = zero, acc4 = zero;
		mi accs[30]{}, ts[30]{};
		mi picked = zero;
		mi carry;
#define SET0 carry = picked = _mm256_andnot_si256(picked, *(mi*)(act + pairs[i++]))
#define ADD2(t, acc) { mi x = t ^ carry, y = (x & acc) | (t & carry); acc = x ^ acc, carry = y; } // (carry, acc) = (t + acc + carry)
#define ADD(ind) ADD2(t ## ind, acc ## ind)
		while (i < padN) {
			mi t0, t1, t2, t3, t4;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); t2 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); ADD(2); t3 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); t2 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); ADD(2); ADD(3); t4 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); t2 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); ADD(2); t3 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); t2 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); t1 = carry;
			SET0; t0 = carry;
			SET0; ADD(0); ADD(1); ADD(2); ADD(3); ADD(4);

			int ind = 5;
			while (!(i & (1 << ind))) {
				ADD2(ts[ind], accs[ind]);
				ind++;
			}
			ts[ind] = carry;
		}
		accs[0] = acc0;
		accs[1] = acc1;
		accs[2] = acc2;
		accs[3] = acc3;
		accs[4] = acc4;

		carry = zero;
		rep(ind,0,30) {
			mi val = (padN & (1 << ind) ? ts[ind] : zero);
			ADD2(val, accs[ind]);
		}

		mi low32 = _mm256_set1_epi32(1);
		rep(j,0,32) {
			mi mval = zero, p2 = low32;
			rep(ind,0,30) {
				mval = _mm256_add_epi32(mval, _mm256_and_si256(_mm256_sub_epi32(zero, accs[ind] & low32), p2));
				accs[ind] = _mm256_srli_epi32(accs[ind], 1);
				p2 = _mm256_slli_epi32(p2, 1);
			}
			union {
				mi m;
				uint32_t ar[SIMD_BITS / 32];
			} u;
			u.m = mval;
			rep(l,0,SIMD_BITS / 32) {
				res[k * SIMD_BITS + l * 32 + j] = u.ar[l];
			}
		}
	}

	rep(i,0,Q)
		cout << res[i] << '\n';
	cout << flush;

	exit(0);
}
```

</CPPSection>
</LanguageSection>
