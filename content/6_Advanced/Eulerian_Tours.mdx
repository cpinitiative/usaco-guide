---
id: eulerian-tours
title: 'Eulerian Tours'
author: Benjamin Qi, Mihnea Brebenel
prerequisites:
  - graph-traversal
description: Visiting all edges of a graph exactly once.
frequency: 0
---

Mentioned in USACO Training ...

<Problems problems="sam" />

## Resources

<Resources>
	<Resource source="CPH" title="19.1 - Eulerian Tours" />
	<Resource source="CP2" title="4.7.3 - Eulerian Graph" />
</Resources>

## Implementation

### Mail Delivery

First, let's define what an **Eulerian path** is.

> An Eulerian path is a path that goes through every edge once.

Similarly, an **Eulerian cycle** is an Eulerian path that starts and ends
with the same node.

An important condition is that a graph can have an Eulerian cycle (not path!) if and only if every node has an even degree.

Now, to find the Eulerian cycle we run a modified DFS.
The DFS goes through only unvisited edges and the same edge can be processed multiple times throughout the DFS, so we remove it from the graph at the first visit.

The algorithm described is [Hierholzer's Algorithm](https://en.wikipedia.org/wiki/Eulerian_path).

**Time Complexity:** $\mathcal{O}(E)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<pair<int, int>>> g;
vector<int> path;
vector<bool> seen;

void dfs(int node) {
	while (!g[node].empty()) {
		auto [son, idx] = g[node].back();
		g[node].pop_back();
		if (seen[idx]) { continue; }
		seen[idx] = true;
		dfs(son);
	}
	path.push_back(node);
}

int main() {
	cin >> n >> m;

	vector<int> degree(n, 0);
	g.resize(n);
	degree.resize(n);
	seen.resize(m);

	for (int i = 0; i < m; i++) {
		int x, y;
		cin >> x >> y;
		x--, y--;
		g[x].emplace_back({y, i});
		g[y].emplace_back({x, i});
		degree[x]++;
		degree[y]++;
	}

	for (int node = 0; node < n; node++) {
		if (degree[node] % 2) {
			cout << "IMPOSSIBLE";
			return 0;
		}
	}

	dfs(0);

	if (path.size() != m + 1) {
		cout << "IMPOSSIBLE";
	} else {
		for (auto node : path) { cout << node + 1 << ' '; }
	}
}
```

</CPPSection>
</LanguageSection>

### Teleporters

The condition of existence for an eulerian path in a directed graph is: At most one node has $out_i - in_i=1$ and at most one node has $in_i - out_i=1$.
This property is because an Eulerian path or cycle leaves a node the same number of times it enters the node. In a directed
graph the exception are the start node and the end node.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<vector<int>> g;
vector<int> in, out, path;

void dfs(int node) {
	while (!g[node].empty()) {
		int son = g[node].back();
		g[node].pop_back();
		dfs(son);
	}
	path.push_back(node);
}

int main() {
	cin >> n >> m;

	g.resize(n + 1);
	in.resize(n + 1);
	out.resize(n + 1);

	for (int i = 0; i < m; i++) {
		int x, y;
		cin >> x >> y;
		g[x].push_back(y);
		out[x]++;
		in[y]++;
	}

	bool flag = true;
	for (int node = 2; node < n && flag; node++) {
		if (in[node] != out[node]) { flag = false; }
	}
	if (out[1] != in[1] + 1 || out[n] != in[n] - 1 || !flag) {
		cout << "IMPOSSIBLE";
		return 0;
	}

	dfs(1);

	reverse(path.begin(), path.end());
	if (path.size() != m + 1 || path.back() != n) {
		cout << "IMPOSSIBLE";
	} else {
		for (auto node : path) { cout << node << ' '; }
	}
}
```

</CPPSection>
</LanguageSection>

## De Bruijn Sequences

<FocusProblem problem="de-bruijn-sequence" />

A [De Bruijn sequece](https://en.wikipedia.org/wiki/De_Bruijn_sequence) is a string of minimum length that contains every string of length $n$ exactly once as a substring, for a fixed alphabet with $k$ letters.
In our case $k=2$ because we only have $0$ and $1$.

Let's take a look at some particular cases:
1. $n=2$ $\rightarrow$ `00110`
2. $n=3$ $\rightarrow$ `0001011100`

We can visualize the transitions - adding $0$ or $1$ - using an oriented graph whose nodes contain a string of length $n-1$.

<center>
![de-bruijn](/de-bruijn.png)
<i> How the graph looks for $n=3$ </i>
</center>

An Eulerian path in the above graph represents a valid solution. The starting node has $n-1$ characters and there are $k^n$ edges that each add one more character, so the length of a De-Bruijn string is $k^n+n-1$.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	if (n == 1) {
		cout << "10" << endl;
		return 0;
	}

	vector<vector<int>> adj(1 << (n - 1));
	for (int node = 0; node < (1 << (n - 1)); node++) {
		int son = (node << 1) % (1 << (n - 1));
		adj[node].push_back(son);
		adj[node].push_back(son | 1);
	}

	stack<int> todo;
	todo.push(0);
	vector<int> path;
	while (!todo.empty()) {
		int node = todo.top();
		if (!adj[node].empty()) {
			todo.push(adj[node].back());
			adj[node].pop_back();
		} else {
			path.push_back(node & 1);
			todo.pop();
		}
	}
	for (int i = 0; i < n - 2; i++) { path.push_back(0); }

	for (int digit : path) { cout << digit; }
	cout << endl;
}
```

</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />
