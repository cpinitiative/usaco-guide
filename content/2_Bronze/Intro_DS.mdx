---
id: intro-ds
title: Introduction to Data Structures
author: Darren Yao, Benjamin Qi, Nathan Wang, Abutalib Namazov, Allen Li
description: 'Introduces the concept of a data structure, (dynamic) arrays, pairs, tuples.'
---

export const problems = {};

<!--
  new Problem("Silver", "Teleportation", "812", "Very Hard", false, [], ""),
 -->

## Data Structures

A **data structure** determines how data is organized so that information can be used efficiently. Each data structure supports some operations efficiently, while other operations are either inefficient or not supported at all. Since different operations are supported by each data structure, you should carefully evaluate which data structure will work best for your particular problem.

<LanguageSection>

<CPPSection>

The C++ [standard library data structures](http://www.cplusplus.com/reference/stl/) are designed to store any type of data. We put the desired data type within the `<>` brackets when declaring the data structure, as follows:

```cpp
vector<string> v;
```

This creates a `vector` structure that only stores objects of type `string`.

For our examples below, we will primarily use the `int` data type, but note that you can use any data type including `string` and user-defined structures.

Essentially, every standard library data structure supports the `size()` method, which returns the number of elements in the data structure, and the `empty()` method, which returns `true` if the data structure is empty, and `false` otherwise.

## Arrays

<Warning>

Technically, you can solve all Bronze problems without using anything from this module aside from arrays. So the rest of this module isn't strictly necessary for Bronze (although highly recommended).

</Warning>

<Resources>
	<Resource
		source="LCPP"
		url="https://www.learncpp.com/cpp-tutorial/6-15-an-introduction-to-stdarray/"
		title="6.15 - Intro to std::array"
	>
		{' '}
	</Resource>
</Resources>

You already know one of the simplest data structures: the **array**! In C++11, in addition to _normal arrays_, there exists an [`array` class](http://www.cplusplus.com/reference/array/array/) in the STL. For example, an `array` of `int`s can be initialized using the following line of code:

```cpp
array<int, 25> ar;
```

The array class supports the normal STL operations (such as `.empty()` or `.size()`) as well as the normal square-bracket access operator:

```cpp
ar[5] //access the element at the 5th index.
```


<LanguageSection>
<CPPSection>

In C++, arrays initialized locally using either the default syntax (i.e. `int arr[10];` ) or the array class are initialized to random numbers, because C++ doesn't have built-in memory management. In order to initialize an array to zero, you have several options:

 - Use a for loop (or nested for loops).
 - Declare the array globally.
 - Add braces at the end of the declaration (i.e. `int arr[10]{};` ). See [LearnCpp](https://www.learncpp.com/cpp-tutorial/62-arrays-part-ii/) for more information regarding this syntax.
 - Use a built-in function such as [`memset(arr, 0, sizeof arr)`](http://www.cplusplus.com/reference/cstring/memset/) or [`std::fill(arr, arr+10, 0)`](http://www.cplusplus.com/reference/algorithm/fill/).

<Warning>

Make sure you know what `memset` actually does before using it! `memset` treats the value that is passed to it as an `unsigned char`. So for an array of 32-bit integers, `memset(arr, -1, sizeof arr)` will set each element to $-1$, as you might expect. However, `memset(arr, 1, sizeof arr)` will set each element to $1+2^8+2^{16}+2^{24}=16843009$, not $1$.

</Warning>

</CPPSection>
<JavaSection />
<PySection />
</LanguageSection>


</CPPSection>

<JavaSection>

Java default [`Collections`](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html) data structures are designed to store any type of object. However, we usually don't want our data structures to only store one type of data, like integers or strings. We do this by putting the desired data type within the `<>` brackets when declaring the data structure, as follows:

```java
ArrayList<String> list = new ArrayList<String>();
```

This creates an `ArrayList` structure that only stores objects of type `String`.

For our examples below, we will primarily use the `Integer` data type, but note that you can have Collections of any object type, including `Strings` , other Collections, or user-defined objects.

`Collections` data types always contain an `add` method for adding an element to the collection, and a `remove` method which removes and returns a certain element from the collection. They also support the `size()` method, which returns the number of elements in the data structure, and the `isEmpty()` method, which returns `true` if the data structure is empty, and `false` otherwise.

</JavaSection>

<PySection />

</LanguageSection>

<LanguageSection>

<PySection>

## Lists

The default way to store data in Python is using a **list**, which can automatically resize itself to accommodate more elements. We can add and delete elements at the end in $\mathcal{O}(1)$ time. A list can be initialized as follows:

```py
arr = []
```

Python lists are **generic**. This means that they can store any kind of data type, including objects. For example, the following code creates a dynamic array and adds the numbers $1$ through $10$ to it:

```py
for i in range(1, 11): # Note that range(i, j) includes i, but does not include j
    arr.append(i)
```

In Python, we can give a dynamic array an initial size. The code below creates a dynamic array with $30$ zeroes.

```py
arr = [0] * 30
```

### Iterating

We can use a regular for loop to iterate through all elements of a list.

```py
arr = [1, 7, 4, 5, 2]

for i in range(len(arr)):
    print(arr[i], end = " ")
print()

for element in arr:
    print(element, end = " ")
print()
```

We can also use **iterators**. An iterator allows you to traverse a container by pointing to an object within the container. `iter(arr)` returns an iterator pointing to the first element of the list `arr`.

```py
arr = [4, 2, 0, 0, 5]
it = iter(arr)

print(next(it)) # 4
print(next(it)) # 2
print(next(it)) # 0
```

### Inserting and Erasing

```py
arr = []
arr.append(2) # [2]
arr.append(3) # [2, 3]
arr.append(7) # [2, 3, 7]
arr.append(5) # [2, 3, 7, 5]
arr[1] = 4; # sets element at index 1 to 4 -> [2, 4, 7, 5]
arr.pop(1) # removes element at index 1 -> [2, 7, 5]
# this remove method is O(n); to be avoided
arr.append(8) # [2, 7, 5, 8]
arr.pop() # [2, 7, 5]
# here, we remove the element from the end of the list; this is O(1).
arr.append(4) # [2, 7, 5, 4]
arr.append(4) # [2, 7, 5, 4, 4]
arr.append(9) # [2, 7, 5, 4, 4, 9]
print(arr[2]) # 5
arr = arr[3:] # [4, 4, 9]
# this erases the first three elements; O(n)
```

### List Comprehensions

List comprehensions are extremely useful for simplifying a python for loop that modifies/creates a list into one expression. The general syntax is: `[ expression for item in list if conditional ]` 

An example is provided in the code block below.

```py
# If a number is odd, add the number times 2 into the array
old_list = [2, 5, 3, 1, 6]
new_list = []
for i in old_list:
    if i % 2 == 1:
        new_list.append(i * 2);
print(new_list) # [10, 6, 2]
# Simplified one liner with list comprehension
# Recall the form [ expression for item in list if conditional ]
# expression: i * 2
# list: old_list
# conditional: i % 2 == 1 (only include item i if it satisfies the conditional)
new_list = [i * 2 for i in old_list if i % 2 == 1]
print(new_list) # [10, 6, 2]
```

A very applicable use of list comprehensions for competitive programming in particular is creating an integer list from space separated input:

```py
# Example input: 5 3 2 6 8 1
# Note that the conditional in the list comprehension is optional, and defaults to True if not provided
arr = [int(x) for x in input().split()]
print(arr) # [5, 3, 2, 6, 8, 1]
```

For more information on list comprehensions, including nesting them to create multidimensional lists, refer to the below resources.

<Resources>
	<Resource
		source="PythonForBeginners"
		title="List Comprehensions in Python"
		url="https://www.pythonforbeginners.com/basics/list-comprehensions-in-python"
	>
	{'Basic list comprehension tutorial'}
	</Resource>
	<Resource
		source="GFG"
		title="Nested List Comprehensions in Python"
		url="https://www.geeksforgeeks.org/nested-list-comprehensions-in-python/"
	>
	{'Nesting list comprehensions'}
    </Resource>
</Resources>

</PySection>

<CPPSection>

## Dynamic Arrays

<Resources>
	<Resource source="IUSACO" title="4.1, 4.2 - Dynamic Arrays">
		module is based off this
	</Resource>
	<Resource source="CPH" title="4.1 - Dynamic Arrays">
		vectors, strings
	</Resource>
	<Resource source="PAPS" title="3.1 - Vectors"></Resource>
	<Resource
		source="LCPP"
		title="6.16 - Intro to std::vector"
		url="https://www.learncpp.com/cpp-tutorial/6-16-an-introduction-to-stdvector/"
	>
		{' '}
	</Resource>
</Resources>

Dynamic arrays ([`vector`](http://www.cplusplus.com/reference/vector/vector/) in C++) support all the functions that a normal array does, and can resize itself to accommodate more elements. In a dynamic array, we can also add and delete elements at the end in $\mathcal{O}(1)$ time.

For example, the following code creates a dynamic array and adds the numbers $1$ through $10$ to it:

```cpp
vector<int> v;
for(int i = 1; i <= 10; i++){
    v.push_back(i);
}
```

In C++, we can give a dynamic array an initial size. The code below creates a dynamic array with $30$ zeroes.

```cpp
vector<int> v(30); // one way
vector<int> v; v.resize(30); // another way
```

In array-based contest problems, we'll use one-, two-, and three-dimensional static arrays most of the time. However, we can also have static arrays of dynamic arrays, dynamic arrays of static arrays, and so on. Usually, the choice between a static array and a dynamic array is just personal preference.

## Unspecified Behavior

```cpp
vi res{-1};
int addElement() {
	res.pb(-1);
	return sz(res)-1;
}

void rec(int x) {
	F0R(i,10) {
		res[i] = addElement();
		ps(i,res[i]);
	}
}

int main() {
	rec(0);
}
```

Running the above code with C++17

```
g++ -std=c++17 bad.cpp -o bad && ./bad
```

gives the intended output:

```
0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
```

But running with C++14

```
g++ -std=c++14 bad.cpp -o bad && ./bad
```

gives:

```
0 -1
1 -1
2 3
3 -1
4 5
5 6
6 7
7 -1
8 9
9 10
```

However, the code works correctly if you save the result of `addElement()` to an intermediate variable.

```cpp
void rec(int x) {
	F0R(i,10) {
		int tmp = addElement();
		res[i] = tmp;
		ps(i,res[i]);
	}
}
```

<!-- See [this](https://codeforces.com/blog/entry/83241) CF blog post and  -->

The problem is that `res[i] = addElement();` only works if `addElement()` is evaluated before `res[i]` is. If `res[i]` is evaluated first, and *then* `addElement()` results in the memory for `res` being reallocated, then `res[i]` is invalidated. The order in which `res[i]` and `addElement()` are evaluated is unspecified (at least before C++17).

See [this](https://stackoverflow.com/questions/38501587/what-are-the-evaluation-order-guarantees-introduced-by-c17#:~:text=In%20C%2B%2B17%2C%20it,of%20the%20object%20is%20evaluated) StackOverflow post for some discussion about why this is the case (also a similar issue [here](https://stackoverflow.com/questions/18040037/why-does-setting-an-element-of-a-map-to-its-size-increments-the-size-before-as)).

### Iterating

<Resources>
	<Resource source="CPH" title="4.4 - Working With Ranges">
		{' '}
	</Resource>
	<Resource
		source="CPP"
		title="Reference - <iterator>"
		url="https://www.cplusplus.com/reference/iterator/"
	>
		{' '}
	</Resource>
	<Resource
		source="LCPP"
		title="6.17 - Intro to Iterators"
		url="https://www.learncpp.com/cpp-tutorial/introduction-to-iterators/"
	>
		{' '}
	</Resource>
</Resources>

One way to iterate through all elements of a static or dynamic array is to use a regular for loop.

```cpp
vector<int> v{1,7,4,5,2};
for (int i = 0; i < int(size(v)); i++){
	cout << v[i] << " ";
}
cout << endl;
```

We can also use **iterators**. An iterator allows you to traverse a container by pointing to an object within the container. However, they are **not** the same thing as pointers.

For example, `v.begin()` or `begin(v)` returns an iterator pointing to the first element of the vector `v`. Apart from the standard way of traversing a vector (by treating it as an array), you can also use iterators:

```cpp
for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    cout << *it << " "; //prints the values in the vector using the iterator
}
```

Here is another way to write this. `auto` (since C++11) automatically infers the type of an object:

```cpp
vector<int> v{1,7,4,5,2};
for (auto it = begin(v); it != end(v); it = next(it)) {
	cout << *it << " "; //prints the values in the vector using the iterator
}
```

We can also use a for-each loop.

```cpp
for (int element : v) {
    cout << element << " "; //prints the values in the vector
}
```

### Inserting and Erasing

Keep in mind that insertion and erasure in the middle of a `vector` are $\mathcal{O}(n)$.

```cpp
vector<int> v;
v.push_back(2); // [2]
v.push_back(3); // [2, 3]
v.push_back(7); // [2, 3, 7]
v.push_back(5); // [2, 3, 7, 5]
v[1] = 4; // sets element at index 1 to 4 -> [2, 4, 7, 5]
v.erase(v.begin() + 1); // removes element at index 1 -> [2, 7, 5]
// this remove method is O(n); to be avoided
v.push_back(8); // [2, 7, 5, 8]
v.erase(v.end()-1); // [2, 7, 5]
// here, we remove the element from the end of the list; this is O(1).
v.push_back(4); // [2, 7, 5, 4]
v.push_back(4); // [2, 7, 5, 4, 4]
v.push_back(9); // [2, 7, 5, 4, 4, 9]
cout << v[2]; // 5
v.erase(v.begin(), v.begin()+3); // [4, 4, 9]
// this erases the first three elements; O(n)
```

### Strings

<IncompleteSection>

All the vector operations above also work on strings.

</IncompleteSection>

</CPPSection>

<JavaSection>

## Dynamic Arrays

Dynamic arrays ([`ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) in Java) that support all the functions that a normal array does, and can repeatedly reallocate storage to accommodate more elements as they are added.

In a dynamic array, we can also add and delete elements at the end in $\mathcal{O}(1)$ time. For example, the following code creates a dynamic array and adds the numbers $1$ through $10$ to it:

```java
ArrayList<Integer> list = new ArrayList<Integer>();
for(int i = 1; i <= 10; i++){
    list.add(i);
}
```

In array-based contest problems, we'll use one-, two-, and three-dimensional static arrays most of the time. However, we can also have static arrays of dynamic arrays, dynamic arrays of static arrays, and so on. Usually, the choice between a static array and a dynamic array is just personal preference.

### Iterating

To iterate through a static or dynamic array, we can use either the regular for loop or the for-each loop.

```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(1); list.add(7); list.add(4); list.add(5); list.add(2);
int[] arr = {1, 7, 4, 5, 2};
for(int i = 0; i < list.size(); i++){ // regular
    System.out.println(list.get(i));
}
for(int element : arr){ // for-each
    System.out.println(element);
}
```

### Adding and Removing

We can add and remove at any index of a dynamic array in $\mathcal{O}(n)$ time.

```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(2); // [2]
list.add(3); // [2, 3]
list.add(7); // [2, 3, 7]
list.add(5); // [2, 3, 7, 5]
list.set(1, 4); // sets element at index 1 to 4 -> [2, 4, 7, 5]
list.remove(1); // removes element at index 1 -> [2, 7, 5]
// this remove method is O(n); to be avoided
list.add(8); // [2, 7, 5, 8]
list.remove(list.size()-1); // [2, 7, 5]
// here, we remove the element from the end of the list; this is O(1)
System.out.println(list.get(2)); // 5
```

</JavaSection>

</LanguageSection>


## Memory Allocation

One thing to keep in mind when using arrays is the memory limit. Usually the USACO memory limit is 256 MB. To estimate how many values can be stored within this limit:

1. Calculate the total memory size in bytes: for 256 MB, that's $256\cdot 10^6$.
2. Divide by the size, in bytes, of an `int` (4), or a `long long` (8), etc. For example, the number of `int`s that you are able to store is bounded above by $\frac{256\cdot 10^6}{4}=64\cdot 10^6$.
3. Be aware that [program overhead](https://stackoverflow.com/questions/2860234/what-is-overhead) (which can be very significant, especially with recursive functions) will reduce the amount of memory available.

## Pairs & Tuples

If we want to store a collection of points on the 2D plane, then we can use a dynamic array of **pairs**.

<LanguageSection>

<CPPSection>

Of course, both `vector<vector<int>>` and `vector<array<int,2>>` would suffice for this case, but a pair can also store two elements of different types.

### [C++ Pairs](http://www.cplusplus.com/reference/utility/pair/pair/)

- `pair<type1, type2> p`: Creates a pair `p` with two elements with the first one being of `type1` and the second one being of `type2`.
- `make_pair(a, b)`: Returns a pair with values `a`, `b`.
- `{a, b}`: With C++11 and above, this can be used as to create a pair, which is easier to write than `make_pair(a, b)`.
- `pair.first`: The first value of the pair.
- `pair.second`: The second value of the pair.

Example:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	pair<string, int> myPair1 = make_pair("Testing", 123);
	cout << myPair1.first << " " << myPair1.second << endl;
	myPair1.first = "It is possible to edit pairs after declaring them";
	cout << myPair1.first << " " << myPair1.second << endl;
	pair<string, string> myPair2 = {"Testing", "curly braces"};
	cout << myPair2.first << " " << myPair2.second << endl;
}

/* Output:
Testing 123
It is possible to edit pairs after declaring them 123
Testing curly braces
*/
```

### [C++ Tuples](http://www.cplusplus.com/reference/tuple/)

Of course, we can hold more than two values with something like `pair<int,pair<int,int>>`, but it gets messy when you need a lot of elements. In this case, using **tuples** might be more convenient.

- `tuple<type1, type2, ..., typeN> t`: Creates a tuple with `N` elements, i'th one being of `typei`.
- `make_tuple(a, b, c, ..., d)`: Returns a tuple with values written in the brackets.
- `get<i>(t)`: Returns the `i`'th element of the tuple `t`. Can also be used to change the element of a tuple.

This operation only works for constant `i`. Namely, it is **not** allowed to do something like the following since `i` is not constant:

```cpp
tuple<int,int,int> t{3,4,5};
int i = 1; cout << get<i>(t);
```

- `tie(a, b, c, ..., d) = t`: Equals `a, b, c, ..., d` to the elements of the tuple $t$ accordingly.

<!-- This is not frequently used by competitive programmers, but it is good to know and can help simplify things sometimes.  -->

Example:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int a = 3, b = 4, c = 5;
	tuple<int, int, int> t = tie(a, b, c);
	cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
	get<0>(t) = 7;
	cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;

	tuple<string, string, int> tp2 = make_tuple("Hello", "world", 100);
	string s1, s2; int x;
	tie(s1, s2, x) = tp2;
	cout << s1 << " " << s2 << " " << x << endl;
}

/* Output:
3 4 5
7 4 5
Hello world 100
*/
```

</CPPSection>

<JavaSection>

### Java

<Warning title="Language Note">

Pairs and tuples are not available in Java's standard libraries, though we can work around that.

</Warning>

We can create our own generic Pair class in Java:

```java
static class Pair<K, V> {
	K first;
	V second;

	public Pair(K first_value, V second_value) {
		first = first_value;
		second = second_value;
	}
}
```

Then, we can use the `Pair` class as follows:

```java
Pair<Integer, String> p = new Pair(5, "hello");
System.out.println(p.first + " " + p.second);
```

</JavaSection>

<PySection>

<Warning title="Language Note">

**Pairs are not available in Python.** Just use tuples; no need for pairs!

</Warning>

### Python Tuples

Use the link below (if you know of a better one, please let us know!) to learn about tuples.

<!-- Python automatically sorts a list of tuples by the first element, then the second, and so on. This can save you time and keystrokes for certain problems like the one above.
 -->

<Resources>

<Resource
	source="Tutorialspoint"
	title="Python Tuples"
	url="https://www.tutorialspoint.com/python/python_tuples.htm"
	starred
/>

</Resources>

</PySection>
</LanguageSection>

## Problems

Nothing to see here! To reiterate, arrays of fixed size should suffice for essentially every Bronze problem, but dynamic arrays, pairs, and tuples can greatly simplify implementation at times.

<!-- Unless someone has any. I really can't find anything... -->
