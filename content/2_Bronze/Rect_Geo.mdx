---
id: rect-geo
title: 'Rectangle Geometry'
author: Darren Yao, Michael Cao, Benjamin Qi
contributors: Allen Li, Andrew Wang, Dong Liu
description:
  'Problems involving rectangles whose sides are parallel to the coordinate
  axes.'
frequency: 2
prerequisites:
  - time-comp
---

<Resources>
	<Resource source="IUSACO" title="7.1 - Rectangle Geometry">
		module is based off this
	</Resource>
</Resources>

<br />

Most problems in this category include only two or three squares or rectangles,
in which case you can simply draw out cases on paper. This should logically lead
to a solution.

## Example - Fence Painting

<FocusProblem problem="fence" />

### Slow Solution

**Time Complexity:** $\mathcal{O}(\text{max coordinate})$

<Spoiler title="Solution">

Since all the intervals lie between the range, $[0, 100]$, we can mark each
interval of length $1$ contained within each interval as painted using a loop.
Then the answer will be the number of marked intervals. The code is provided
[here](https://usaco.guide/general/input-output#method-1).

However, this solution would not work for higher constraints (ex. if the
coordinates were up to $10^9$).

</Spoiler>

### Fast Solution

**Time Complexity:** $\mathcal{O}(1)$

<Spoiler title="Solution">

Calculate the answer by adding the original lengths and subtracting the
intersection length.

$$
(b-a)+(d-c)-\text{intersection}([a,b],[c,d])
$$

The
[official analysis](http://www.usaco.org/current/data/sol_paint_bronze_dec15.html)
splits computing the intersection length into several cases. However, we do it
more simply here. An interval $[x,x+1]$ is contained within both $[a,b]$ and
$[c,d]$ if $a\le x$, $c\le x$, $x<b$, and $x<d$. In other words,
$\max(a,c)\le x$ and $x<\min(b,d)$. So the length of the intersection is
$\min(b,d)-\max(a,c)$ if this quantity is positive and zero otherwise!

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	freopen("paint.in", "r", stdin);
	freopen("paint.out", "w", stdout);

	int a, b, c, d;
	cin >> a >> b >> c >> d;

	int total = (b - a) + (d - c);  // the sum of the two intervals
	int intersection = max(min(b, d) - max(a, c), 0);  // subtract the intersection
	int ans = total - intersection;

	cout << ans << "\n";
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Paint {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("paint");
		int a = io.nextInt();
		int b = io.nextInt();
		int c = io.nextInt();
		int d = io.nextInt();

		// the sum of the two intervals
		int total = (b - a) + (d - c);
		// subtract the intersection
		int intersection = Math.max(Math.min(b, d) - Math.max(a, c), 0);
		int union = total - intersection;

		io.println(union);
		io.close();
	}

	CodeSnip{Kattio}
}
```

</JavaSection>

<PySection>

```py
import sys

sys.stdin = open("paint.in", "r")
sys.stdout = open("paint.out", "w")

a, b = map(int, input().split())
c, d = map(int, input().split())
total = (b - a) + (d - c)  # the sum of the two intervals
intersection = max(min(b, d) - max(a, c), 0)  # subtract the intersection
union = total - intersection

print(union)
```

</PySection>

</LanguageSection>

</Spoiler>

## Example - Blocked Billboard

Think of this as the 2D analog of the previous example.

<FocusProblem problem="sam" />

### Slow Solution

**Time Complexity:** $\mathcal{O}((\text{max coordinate})^2)$

<Spoiler title="Solution">

Since all coordinates are in the range $[-1000,1000]$, we can simply go through
each of the $2000^2$ possible visible squares and check which ones are visible
using nested for loops.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_POS = 2000;
bool visible[MAX_POS][MAX_POS];

int main() {
	freopen("billboard.in", "r", stdin);
	freopen("billboard.out", "w", stdout);
	for (int i = 0; i < 3; ++i) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		// make all the coordinates positive
		x1 += MAX_POS / 2;
		y1 += MAX_POS / 2;
		x2 += MAX_POS / 2;
		y2 += MAX_POS / 2;
		for (int x = x1; x < x2; x++) {
			for (int y = y1; y < y2; y++) {
				visible[x][y] =  i < 2;
			}
		}
	}

	int ans = 0;
	for (int x = 0; x < MAX_POS; x++) {
		for (int y = 0; y < MAX_POS; y++) {
			ans += visible[x][y];
		}
	}
	cout << ans << "\n";
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Billboard {
	private static final int MAX_POS = 2000;
	
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("billboard");
		int visible[][] = new int[MAX_POS][MAX_POS];

		for (int i = 0; i < 3; ++i) {
			int x1 = io.nextInt();
			int y1 = io.nextInt();
			int x2 = io.nextInt();
			int y2 = io.nextInt();
			x1 += MAX_POS / 2;
			y1 += MAX_POS / 2;
			x2 += MAX_POS / 2;
			y2 += MAX_POS / 2;
			for (int x = x1; x < x2; x++) {
				for (int y = y1; y < y2; y++) {
					visible[x][y] = i < 2 ? 1 : 0;
				}
			}
		}

		int ans = 0;
		for (int x = 0; x < 2000; ++x) {
			for (int y = 0; y < 2000; ++y) {
				ans += visible[x][y];
			}
		}

		io.println(ans);
		io.close();
	}

	CodeSnip{Kattio}
}
```

</JavaSection>

<PySection>

Code runs marginally faster in Python [when placed in a function](https://stackoverflow.com/questions/11241523/why-does-python-code-run-faster-in-a-function),
so we can use this to get all 10 test cases. When taken out of
the function, the code passes only 9 test cases.

```py
import sys

MAX_POS = 2000


def main():
	sys.stdin = open("billboard.in", "r")
	sys.stdout = open("billboard.out", "w")

	visible = [[False for _ in range(MAX_POS)] for _ in range(MAX_POS)]

	for i in range(3):
		x1, y1, x2, y2 = map(int, input().split())
		x1 += MAX_POS // 2
		y1 += MAX_POS // 2
		x2 += MAX_POS // 2
		y2 += MAX_POS // 2
		for x in range(x1, x2):
			for y in range(y1, y2):
				visible[x][y] = i < 2

	ans = 0
	for x in range(MAX_POS):
		for y in range(MAX_POS):
			ans += visible[x][y]
	print(ans)


main()
```

</PySection>

</LanguageSection>

Of course, this wouldn't suffice if the coordinates were changed to be up to
$10^9$.

</Spoiler>

### Fast Solution

**Time Complexity:** $\mathcal{O}(1)$

<Spoiler title="Solution">

[Official Analysis](http://www.usaco.org/current/data/sol_billboard_bronze_dec17.html)

<LanguageSection>

<JavaSection>

Creating a class `Rect` to represent a rectangle makes the code easier
to understand.

```java
import java.io.*;
import java.util.*;

class Rect {
	int x1, y1, x2, y2;
	int area() { return (y2 - y1) * (x2 - x1); }
}

public class Billboard {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("billboard");
		
		Rect a = new Rect(), b = new Rect(), t = new Rect();
		a.x1 = io.nextInt(); a.y1 = io.nextInt();
		a.x2 = io.nextInt(); a.y2 = io.nextInt();
		b.x1 = io.nextInt(); b.y1 = io.nextInt();
		b.x2 = io.nextInt(); b.y2 = io.nextInt();
		t.x1 = io.nextInt(); t.y1 = io.nextInt();
		t.x2 = io.nextInt(); t.y2 = io.nextInt();

		io.println(a.area() + b.area() - intersect(a, t) - intersect(b, t));
		io.close();
	}

	static int intersect(Rect p, Rect q) {
		int xOverlap = Math.max(0, Math.min(p.x2, q.x2) - Math.max(p.x1, q.x1));
		int yOverlap = Math.max(0, Math.min(p.y2, q.y2) - Math.max(p.y1, q.y1));
		return xOverlap * yOverlap;
	}

	CodeSnip{Kattio}
}
```

#### Alternative Implementation

We can also use the built-in
[`Rectangle`](https://docs.oracle.com/javase/8/docs/api/java/awt/Rectangle.html)
class. To create a new rectangle, use the following constructor:

```java
// creates a rectangle with upper-left corner at (x,y) with a specified width
// and height
Rectangle newRect = new Rectangle(x, y, width, height);
```

The `Rectangle` class supports numerous useful methods, including the following:

- `firstRect.intersects(secondRect)` checks if two rectangles intersect.
- `firstRect.union(secondRect)` returns a rectangle representing the union of
  two rectangles.
- `firstRect.contains(x, y)` checks whether the integer point $(x,y)$ exists in
  firstRect.
- `firstRect.intersection(secondRect)` returns a rectangle representing the
  intersection of two rectangles.
- `rect.isEmpty()` checks whether `rect` is empty.

This class can often lessen the implementation needed in some bronze problems
and CodeForces problems.

<Info title="Important Note About Java Coordinates">

$y$-[coordinates](https://docs.oracle.com/javase/tutorial/2d/overview/coordinate.html)
in Java increase from top to bottom, not bottom to top! This is why we consider
the top-left $y$-coordinate of each rectangle in the solution below to be `-y2`
instead of `y2`.

Alternatively, you can think of `newRect` as creating a rectangle with
_lower-left_ corner at $(x,y)$ and work with Cartesian coordinates instead. So
the solution below will work if all occurences of `-y2` are replaced with `y1`.

</Info>

With Built-in `Rectangle` class:

```java
import java.awt.Rectangle; // needed to use Rectangle class
import java.io.*;
import java.util.*;

public class Billboard {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("billboard");

		int x1, y1, x2, y2;
		x1 = io.nextInt(); y1 = io.nextInt();
		x2 = io.nextInt(); y2 = io.nextInt();
		Rectangle firstRect = new Rectangle(x1, -y2, x2 - x1, y2 - y1);
		
		x1 = io.nextInt(); y1 = io.nextInt();
		x2 = io.nextInt(); y2 = io.nextInt();
		Rectangle secondRect = new Rectangle(x1, -y2, x2 - x1, y2 - y1);

		x1 = io.nextInt(); y1 = io.nextInt();
		x2 = io.nextInt(); y2 = io.nextInt();
		Rectangle truck = new Rectangle(x1, -y2, x2 - x1, y2 - y1);

		long firstIntersect = getArea(firstRect.intersection(truck));
		long secondIntersect = getArea(secondRect.intersection(truck));

		io.println(getArea(firstRect) + getArea(secondRect)
						- firstIntersect - secondIntersect);
		io.close();
	}

	public static long getArea(Rectangle r) {
		return r.isEmpty() ? 0 : (long) r.getHeight() * (long) r.getWidth();
	}

	CodeSnip{Kattio}
}
```

<Optional>

[java.awt.geom.Area](https://docs.oracle.com/javase/7/docs/api/java/awt/geom/Area.html)
will allow you to calculate the union, intersection, difference, or exclusive or
of arbitrary polygons (and more). See
[here](<https://github.com/bqi343/USACO/blob/master/Implementations/content/geometry%20(13)/Polygons/PolyUnion.java>)
for an example of usage.

</Optional>

</JavaSection>

<CPPSection>

Note how creating a struct `Rect` to represent a rectangle makes the code easier
to understand.

<!-- Unfortunately, C++ doesn't have a built in rectangle `struct` or `class`, so you need to write the functions yourself. Here is the code from the official analysis (modified slightly): -->

<Info title="What's a struct?">

A C++ [`struct`](http://www.cplusplus.com/doc/tutorial/structures/) is the same
as a C++ `class` but all members are `public` rather than `private` by default.
Check [LCPP](https://www.learncpp.com/cpp-tutorial/47-structs/) for more
information.

</Info>

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Rect {
	int x1, y1, x2, y2;
	int area() { return (y2 - y1) * (x2 - x1); }
};

int intersect(Rect p, Rect q) {
	int xOverlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1));
	int yOverlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1));
	return xOverlap * yOverlap;
}

int main() {
	freopen("billboard.in", "r", stdin);
	freopen("billboard.out", "w", stdout);

	Rect a, b, t;  // billboards a, b, and the truck
	cin >> a.x1 >> a.y1 >> a.x2 >> a.y2;
	cin >> b.x1 >> b.y1 >> b.x2 >> b.y2;
	cin >> t.x1 >> t.y1 >> t.x2 >> t.y2;
	cout << a.area() + b.area() - intersect(a, t) - intersect(b, t) << endl;
}
```

</CPPSection>

<PySection>

<!-- Unfortunately, Python doesn't have a built in rectangle class, so you need to write the class yourself. -->

Note how creating a class `Rect` to represent a rectangle makes the code easier
to understand.

```py
import sys

class Rect:
	def __init__(self):
		self.x1, self.y1, self.x2, self.y2 = map(int, input().split())

	def area(self):
		return (self.y2 - self.y1) * (self.x2 - self.x1)

def intersect(p, q):
	x_overlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1))
	y_overlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1))
	return x_overlap * y_overlap

sys.stdin = open("billboard.in", "r")
sys.stdout = open("billboard.out", "w")

rects = []
for _ in range(3):
	rects.append(Rect())

print(rects[0].area() + rects[1].area() - intersect(rects[0], rects[2]) - intersect(rects[1], rects[2]))
```

</PySection>

</LanguageSection>

</Spoiler>

## Problems

<Problems problems="general" />
