---
id: intro-greedy
title: Introduction to Greedy Algorithms
author: Darren Yao
description: 'Selecting the choice that seems to be the best at the moment at every step of your algorithm.'
frequency: 2
prerequisites:
  - ad-hoc
  - intro-ds
---

import { Problem } from '../models';

export const problems = {
	tutorial: [
		new Problem(
			'Bronze',
			'Mad Scientist',
			'1012',
			'Easy',
			false,
			[],
			'See below.'
		),
	],
	general: [
		new Problem(
			'Bronze',
			'Cow Tipping',
			'689',
			'Normal',
			false,
			[],
			'Cells in the last row and column can be toggled uniquely. Toggle the appropriate ones and then recurse to the rectangle in the previous row/column, and solve the same way.'
		),
		new Problem(
			'Bronze',
			'Out of Place',
			'785',
			'Hard',
			true,
			[],
			'If there are $K$ elements out of order, such that $a_i \neq s_i$ where $s$ is the sorted array, the answer is $K - 1$. This can be achieved by greedily sorting the elements similar to bubble sort.'
		),
		new Problem(
			'Bronze',
			'Race',
			'989',
			'Very Hard',
			true,
			[],
			'Greedily increment/decrement Bessies speed to fit the conditions until her total distance exceeds K.'
		),
		new Problem('Silver', 'Rest Stops', '810', 'Very Hard', true, [], ''),
	],
};

## Greedy Algorithms

Some USACO Bronze problems that appear to be Ad Hoc can actually be solved using **greedy** algorithms. This idea will be covered in a future [module](/silver/greedy), but we'll introduce the general mindset in this section.

<Resources>
	<Resource source="CPH" title="6.1 - Coin Problem" starred>
		other examples are outside scope of bronze
	</Resource>
</Resources>

<Warning>

True **"greedy"** problems start to show up in silver, though the greedy mindset can be very helpful for bronze problems.

</Warning>

From the above:

> A **greedy** algorithm constructs a solution to the problem by always making a choice that looks the best at the moment. A greedy algorithm never takes back its choices, but directly constructs the final solution. For this reason, greedy algorithms are usually very efficient.

**Greedy** does not refer to a single algorithm, but rather a way of thinking that is applied to problems; there's no one way to do greedy algorithms. Hence, we use a selection of well-known examples to help you understand the greedy paradigm.

### Example: Mad Scientist

Try to come up with a greedy algorithm for the USACO Bronze problem "Mad Scientist."

<Problems problems={problems.tutorial} />

<Spoiler title="Correct Greedy Algorithm">

In this problem, the correct greedy solution is to continually flip the longest possible ranges of mismatching cows.

Mad Scientist has an excellent [editorial](http://www.usaco.org/current/data/sol_breedflip_bronze_feb20.html) with a video solution and intuitive proof.

It is highly recommended you read it to gain a better understanding of the greedy algorithm.

</Spoiler>

However, not all greedy problems in the bronze division necessarily require mathematical proofs of correctness. It is often sufficent to intuitively convince yourself your algorithm is correct.

<Info title="Pro Tip">

Sometimes, if the algorithm is easy enough to implement, you don't even need to convince yourself it's correct; just code it and see if it passes. Competitive programmers refer to this as "Proof by AC," or "Proof by Accepted."

<!-- Don't overuse it though? -->

</Info>

## Problems

<Problems problems={problems.general} />

<IncompleteSection>

</IncompleteSection>

<!-- Anything else major that needs to be added? Bronze Ad Hoc is not very complicated. -->
