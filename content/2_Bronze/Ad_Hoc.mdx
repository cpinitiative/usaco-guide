---
id: ad-hoc
title: Ad Hoc Problems
author: Michael Cao, Darren Yao, Benjamin Qi, Allen Li, Andrew Wang, Dong Liu
description: "Problems that don't fall under any well-defined category, including Rectangle Geometry problems."
frequency: 1
---

export const problems = {
	general: [
		new Problem('Bronze', 'Sleepy Cow Herding', '915', 'Easy', false, [], ''),
		new Problem('Bronze', 'Sleepy Cow Sorting', '892', 'Hard', false, [], ''),
		new Problem('Bronze', 'Taming the Herd', '809', 'Hard', false, [], ''),
		new Problem('Bronze', 'Modern Art', '737', 'Very Hard', false, [], ''),
		new Problem('Bronze', 'Hoofball', '808', 'Very Hard', false, [], ''),
		new Problem(
			'Silver',
			'Spaced Out',
			'1088',
			'Very Hard',
			false,
			['Greedy'],
			''
		),
	],
	fence: [
		new Problem(
			'Bronze',
			'Fence Painting',
			'567',
			'Very Easy',
			false,
			['Rectangle'],
			''
		),
	],
	rectGeoSample: [
		new Problem(
			'Bronze',
			'Blocked Billboard',
			'759',
			'Easy',
			false,
			['Rectangle'],
			''
		),
	],
	rectGeoProblems: [
		new Problem(
			'Bronze',
			'Square Pasture',
			'663',
			'Very Easy',
			false,
			['Rectangle'],
			'usaco-663'
		),
		new Problem(
			'Bronze',
			'Blocked Billboard II',
			'783',
			'Easy',
			true,
			['Rectangle'],
			'usaco-759'
		),
		new Problem(
			'CF',
			'D3C - White Sheet',
			'contest/1216/problem/C',
			'Normal',
			false,
			['Rectangle'],
			''
		),
	],
};

Most bronze problems fall into specific categories, such as simulation and complete search. Those which don't often require more thought, although they are not necessarily more difficult to implement.

Any problem that doesn't fall under any well-defined category can be labelled as **ad hoc**. Since there is no fixed algorithm or idea to solving these problems, they can be hard to generalize. In this module, we'll go over some general tips that may be useful in approaching problems that appear to be ad hoc.

- Draw lots of small cases to gain a better understanding of the problem. If you're having trouble debugging, draw more cases. If you don't know how to start with a problem, draw more cases. Whenever you don't know how to further approach a problem, you're probably missing an important observation, so draw more cases and make observations about properties of the problem.
- Whenever you find an observation that seems useful, write it down! Writing down ideas lets you easily come back to them later, and makes sure you don't forget about ideas that could potentially be the solution.
- Don't get stuck on any specific idea, unless you see an entire solution. Trying to complete search an ad hoc problem could end up wasting a lot of your time in contest.
- Try to approach the problem from a lot of different perspectives. Try to mess around with formulas or draw a visual depiction of the problem (maybe a [graph](/bronze/intro-graphs)?). One of the most helpful things you can do when solving ad hoc problems is to keep trying ideas until you make progress. This is something you get better at as you do more problems.

These tips are helpful in solving ad hoc problems. However, in the end, the best way to get better at ad hoc problems (or any type of problem) is to do a lot of them.

<!-- Try to solve as many practice problems below as you can, and click the solution sketch tab if you can't figure the solution out. -->

<!-- If anyone disagrees with any of the tips / ideas presented in the blogs below, just let me know. I think they're quite interesting, though I haven't tried it out myself. -->

<!--
<Resources>
	<Resource
		source="ZLE@kauntaofficial.github.io"
		title="The Art of Thinking"
		url="https://kauntaofficial.github.io/the-art-of-thinking"
	>
		blog with more tips
	</Resource>
	<Resource
		source="ZLE@kauntaofficial.github.io"
		title="Developing Intuition"
		url="https://kauntaofficial.github.io/developing-intuition"
	>
		developing intuition while practicing
	</Resource>
</Resources>
-->

## General Ad-Hoc Problems

<!-- Don't you love Dhruv Rohatgi problems? -->

<Problems problems={problems.general} />

# Rectangle Geometry

Some of the ad-hoc problems that appear in Bronze involve rectangles.

<Resources>
	<Resource source="IUSACO" title="7.1 - Rectangle Geometry">
		section is based off this
	</Resource>
</Resources>

<br />

Most problems in this category include only two or three squares or rectangles, in which case you can simply draw out cases on paper. This should logically lead to a solution.

## Rect Geo Example - Fence Painting

<FocusProblem problem={problems.fence[0]} />

### Slow Solution

**Time Complexity:** $\mathcal{O}(\text{max coordinate})$

<Spoiler title="Solution">

Since all the intervals lie between the range, $[0, 100]$, we can mark each interval of length $1$ contained within each interval as painted using a loop. Then the answer will be the number of marked intervals. The code is provided [here](https://usaco.guide/general/io#method-1).

However, this solution would not work for higher constraints (ex. if the coordinates were up to $10^9$).

</Spoiler>

### Fast Solution

**Time Complexity:** $\mathcal{O}(1)$

<Spoiler title="Solution">

Calculate the answer by adding the original lengths and subtracting the intersection length.

$$
(b-a)+(d-c)-\text{intersection}([a,b],[c,d])
$$

The [official analysis](http://www.usaco.org/current/data/sol_paint_bronze_dec15.html) splits computing the intersection length into several cases. However, we do it more simply here. An interval $[x,x+1]$ is contained within both $[a,b]$ and $[c,d]$ if $a\le x$, $c\le x$, $x<b$, and $x<d$. In other words, $\max(a,c)\le x$ and $x<\min(b,d)$. So the length of the intersection is $\min(b,d)-\max(a,c)$ if this quantity is positive and zero otherwise!

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	freopen("paint.in", "r", stdin);
	freopen("paint.out", "w", stdout);

	int a, b, c, d;
	cin >> a >> b >> c >> d;

	int ans = 0;
	ans += b-a; // add length of first interval
	ans += d-c; // add length of second interval
	// if intervals intersect, subtract the length of the intersection
	ans -= max(min(b, d)-max(a, c), 0);

	cout << ans << "\n";
}
```

</CPPSection>

<PySection>

```py
import sys

sys.stdin = open("paint.in", "r")
sys.stdout = open("paint.out", "w")

a, b = map(int, input().split())
c, d = map(int, input().split())
total = (b-a) + (d-c)
intersection = max(min(b, d)-max(a, c), 0)
ans = total - intersection

print(ans)
```

</PySection>

</LanguageSection>

</Spoiler>


## Rect Geo Example - Blocked Billboard

Think of this as the 2D analog of the previous example.

<FocusProblem problem={problems.rectGeoSample[0]} />

### Slow Solution

**Time Complexity:** $\mathcal{O}((\text{max coordinate})^2)$

<Spoiler title="Solution">

Since all coordinates are in the range $[-1000,1000]$, we can simply go through each of the $2000^2$ possible visible squares and check which ones are visible using nested for loops.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

bool ok[2000][2000];

int main() {
	freopen("billboard.in","r",stdin);
	freopen("billboard.out","w",stdout);
	for (int i = 0; i < 3; ++i) {
		int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
		x1 += 1000, y1 += 1000, x2 += 1000, y2 += 1000;
		for (int x = x1; x < x2; ++x)
			for (int y = y1; y < y2; ++y) {
				if (i < 2) ok[x][y] = 1;
				else ok[x][y] = 0;
			}
	}
	int ans = 0;
	for (int x = 0; x < 2000; ++x)
		for (int y = 0; y < 2000; ++y)
			ans += ok[x][y];
	cout << ans << "\n";
}
```

</CPPSection>

<JavaSection>

```java

import java.io.*;
import java.util.*;

public class billboard
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new FileReader("billboard.in"));
		PrintWriter out = new PrintWriter(new FileWriter("billboard.out"));
		int ok[][] = new int[2000][2000];
		for (int i = 0; i < 3; ++i) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int x1 = Integer.parseInt(st.nextToken());
			int y1 = Integer.parseInt(st.nextToken());
			int x2 = Integer.parseInt(st.nextToken());
			int y2 = Integer.parseInt(st.nextToken());
			x1 += 1000; y1 += 1000; x2 += 1000; y2 += 1000;
			for (int x = x1; x < x2; ++x){
				for (int y = y1; y < y2; ++y) {
					if (i < 2) ok[x][y] = 1;
					else ok[x][y] = 0;
				}
			}
		}
		int ans = 0;
		for (int x = 0; x < 2000; ++x){
			for (int y = 0; y < 2000; ++y){
				ans += ok[x][y];
			}
		}
		out.println(ans);
		out.close();
	}
}

```

</JavaSection>

<PySection>

Unfortunately, the naive Python solution only passes 9/10 test cases.

```py
import sys

sys.stdin = open("billboard.in", "r")
sys.stdout = open("billboard.out", "w")

ok = [[False for i in range(2000)] for j in range(2000)]

for i in range(3):
	x1, y1, x2, y2 = map(int, input().split())
	x1 += 1000; y1 += 1000; x2 += 1000; y2 += 1000
	for x in range(x1, x2):
		for y in range(y1, y2):
			if i < 2:
				ok[x][y] = 1
			else:
				ok[x][y] = 0
ans = 0
for x in range(2000):
	for y in range(2000):
		ans += ok[x][y]
print(ans)
```

</PySection>

</LanguageSection>

Of course, this wouldn't suffice if the coordinates were changed to be up to $10^9$.

</Spoiler>

### Fast Solution

**Time Complexity:** $\mathcal{O}(1)$

<Spoiler title="Solution">

[Official Analysis](http://www.usaco.org/current/data/sol_billboard_bronze_dec17.html)

<LanguageSection>

<JavaSection>

Note how creating a class `Rect` to represent a rectangle makes the code easier to understand.

```java
import java.io.*;
import java.util.*;

class Rect {
	int x1, y1, x2, y2;
	Rect() {}
	int area() { return (y2-y1)*(x2-x1); }
}

public class blockedBillboard {
	public static void main (String[] args) throws IOException{
		Scanner sc = new Scanner(new File("billboard.in"));
		PrintWriter pw = new PrintWriter(new FileWriter("billboard.out"));
		Rect a = new Rect(), b = new Rect(), t = new Rect();
		int x1, y1, x2, y2;
		a.x1 = sc.nextInt(); a.y1 = sc.nextInt(); a.x2 = sc.nextInt(); a.y2 = sc.nextInt();
		b.x1 = sc.nextInt(); b.y1 = sc.nextInt(); b.x2 = sc.nextInt(); b.y2 = sc.nextInt();
		t.x1 = sc.nextInt(); t.y1 = sc.nextInt(); t.x2 = sc.nextInt(); t.y2 = sc.nextInt();
		pw.println(a.area()+b.area()-intersect(a, t)-intersect(b, t));
		pw.close();
	}
	static int intersect(Rect p, Rect q) {
		int xOverlap = Math.max(0, Math.min(p.x2, q.x2) - Math.max(p.x1, q.x1));
		int yOverlap = Math.max(0, Math.min(p.y2, q.y2) - Math.max(p.y1, q.y1));
		return xOverlap * yOverlap;
	}
}
```

#### Alternative Implementation

We can also use the built-in [`Rectangle`](https://docs.oracle.com/javase/8/docs/api/java/awt/Rectangle.html) class. To create a new rectangle, use the following constructor:

```java
// creates a rectangle with upper-left corner at (x,y) with a specified width and height
Rectangle newRect = new Rectangle(x, y, width, height);
```

The `Rectangle` class supports numerous useful methods, including the following:

- `firstRect.intersects(secondRect)` checks if two rectangles intersect.
- `firstRect.union(secondRect)` returns a rectangle representing the union of two rectangles.
- `firstRect.contains(x, y)` checks whether the integer point $(x,y)$ exists in firstRect.
- `firstRect.intersection(secondRect)` returns a rectangle representing the intersection of two rectangles.
- `rect.isEmpty()` checks whether `rect` is empty.

This class can often lessen the implementation needed in some bronze problems and CodeForces problems.

<Info title="Important Note About Java Coordinates">

$y$-[coordinates](https://docs.oracle.com/javase/tutorial/2d/overview/coordinate.html) in Java increase from top to bottom, not bottom to top! This is why we consider the top-left $y$-coordinate of each rectangle in the solution below to be `-y2` instead of `y2`.

Alternatively, you can think of `newRect` as creating a rectangle with _lower-left_ corner at $(x,y)$ and work with Cartesian coordinates instead. So the solution below will work if all occurences of `-y2` are replaced with `y1`.

</Info>

With Built-in `Rectangle` class:

```java
import java.awt.Rectangle; //needed to use Rectangle class
import java.io.*;
import java.util.*;

public class blockedBillboard {
	public static void main(String[] args) throws IOException{
		Scanner sc = new Scanner(new File("billboard.in"));
		PrintWriter pw = new PrintWriter(new FileWriter("billboard.out"));
		int x1, y1, x2, y2;

		x1 = sc.nextInt(); y1 = sc.nextInt(); x2 = sc.nextInt(); y2 = sc.nextInt();
		Rectangle firstRect = new Rectangle(x1, -y2, x2-x1, y2-y1);
		x1 = sc.nextInt(); y1 = sc.nextInt(); x2 = sc.nextInt(); y2 = sc.nextInt();
		Rectangle secondRect = new Rectangle(x1, -y2, x2-x1, y2-y1);
		x1 = sc.nextInt(); y1 = sc.nextInt(); x2 = sc.nextInt(); y2 = sc.nextInt();
		Rectangle truck = new Rectangle(x1, -y2, x2-x1, y2-y1);

		long firstIntersect = getArea(firstRect.intersection(truck));
		long secondIntersect = getArea(secondRect.intersection(truck));
		pw.println(getArea(firstRect)+getArea(secondRect)
						- firstIntersect - secondIntersect);
		pw.close();
	}
	public static long getArea(Rectangle r){
		if (r.isEmpty()) return 0;
		return (long)r.getHeight()*(long)r.getWidth();
	}
}
```

<Optional>

[java.awt.geom.Area](https://docs.oracle.com/javase/7/docs/api/java/awt/geom/Area.html) will allow you to calculate the union, intersection, difference, or exclusive or of arbitrary polygons (and more). See [here](<https://github.com/bqi343/USACO/blob/master/Implementations/content/geometry%20(13)/Polygons/PolyUnion.java>) for an example of usage.

</Optional>

</JavaSection>

<CPPSection>

Note how creating a struct `Rect` to represent a rectangle makes the code easier to understand.

<!-- Unfortunately, C++ doesn't have a built in rectangle `struct` or `class`, so you need to write the functions yourself. Here is the code from the official analysis (modified slightly): -->

<Info title="What's a struct?">

A C++ [`struct`](http://www.cplusplus.com/doc/tutorial/structures/) is the same as a C++ `class` but all members are `public` rather than `private` by default. Check [LCPP](https://www.learncpp.com/cpp-tutorial/47-structs/) for more information.

</Info>

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Rect {
	int x1,y1,x2,y2;
	int area() { return (y2-y1)*(x2-x1); }
};

int intersect(Rect p, Rect q){
	int xOverlap = max(0,min(p.x2,q.x2)-max(p.x1,q.x1));
	int yOverlap = max(0,min(p.y2,q.y2)-max(p.y1,q.y1));
	return xOverlap*yOverlap;
}

int main(){
	ifstream cin ("billboard.in");
	ofstream cout ("billboard.out");
	Rect a, b, t;  // billboards a, b, and the truck
	cin >> a.x1 >> a.y1 >> a.x2 >> a.y2;
	cin >> b.x1 >> b.y1 >> b.x2 >> b.y2;
	cin >> t.x1 >> t.y1 >> t.x2 >> t.y2;
	cout << a.area()+b.area()-intersect(a,t)-intersect(b,t) << endl;
}
```

</CPPSection>

<PySection>

<!-- Unfortunately, Python doesn't have a built in rectangle class, so you need to write the class yourself. -->

Note how creating a class `Rect` to represent a rectangle makes the code easier to understand.

```py
import sys

class Rect:
	def __init__(self):
		self.x1, self.y1, self.x2, self.y2 = map(int, input().split())

	def area(self):
		return (self.y2 - self.y1) * (self.x2 - self.x1)

def intersect(p, q):
	xOverlap = max(0, min(p.x2, q.x2) - max(p.x1, q.x1))
	yOverlap = max(0, min(p.y2, q.y2) - max(p.y1, q.y1))
	return xOverlap * yOverlap

sys.stdin = open("billboard.in", "r")
sys.stdout = open("billboard.out", "w")

rects = []

for i in range(3):
	rects.append(Rect())

print(rects[0].area() + rects[1].area() - intersect(rects[0], rects[2]) - intersect(rects[1], rects[2]))
```

</PySection>

</LanguageSection>

</Spoiler>

## Rect Geo Problems

<Problems problems={problems.rectGeoProblems} />
