---
id: ad-hoc
title: Ad Hoc Problems
author: Michael Cao
contributors: Ryan Chou, Rameez Parwez
description:
  'Problems that do not fall into standard categories with well-studied
  solutions.'
frequency: 4
---

## Introduction

According to USACO Training section 1.2:

> **Ad hoc** problems are those whose algorithms do not fall into standard
> categories with well-studied solutions. Each ad hoc problem is different; no
> specific or general techniques exist to solve them.

Here are some general tips that may be useful in approaching problems that
appear to be ad hoc.

- Draw lots of small cases to gain a better understanding of the problem. If
  you're having trouble debugging, draw more cases. If you don't know how to
  start with a problem, draw more cases. Whenever you don't know how to further
  approach a problem, you're probably missing an important observation, so draw
  more cases and make observations about properties of the problem.
- Whenever you find an observation that seems useful, write it down! Writing
  down ideas lets you easily come back to them later, and makes sure you don't
  forget about ideas that could potentially be the solution.
- Don't get stuck on any specific idea, unless you see an entire solution.
- Try to approach the problem from a lot of different perspectives. Try to mess
  around with formulas or draw a visual depiction of the problem. One of the
  most helpful things you can do when solving ad hoc problems is to keep trying
  ideas until you make progress. This is something you get better at as you do
  more problems.

In the end, the best way to get better at ad hoc problems (or any type of
problem) is to do a lot of them.

## Example - Photoshoot 2

<FocusProblem problem = "photoshoot2"/>

<Spoiler title = "Solution">

## Explanation

If the element is at the target position, we simply move forward to the next one.
Otherwise, if it's not currently available at the target position, we handle it by
marking the element as moved and incrementing our answer.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <cstring>
#include <iostream>

int main() {
	int n;
	std::cin >> n;
	int moved[n] = {0};
	int a[n], b[n];

	for (int i = 0; i < n; i++) {
		std::cin >> a[i];
		a[i]--;
	}

	for (int i = 0; i < n; i++) {
		std::cin >> b[i];
		b[i]--;
	}

	int res = 0;
	int j = 0;

	for (int i = 0; i < n; i++) {
		while (j < n && moved[a[j]]) { j++; }

		if (a[j] == b[i]) {
			j++;
		} else {
			res++;
			moved[b[i]] = 1;
		}
	}

	std::cout << res << '\n';
}
```

</CPPSection>
<PySection>

```py
n = int(input())
a = [int(x) - 1 for x in input().split()]
b = [int(x) - 1 for x in input().split()]

moved = [0] * n
j = res = 0


for i in range(n):
	while j < n and moved[a[j]]:
		j += 1

	if a[j] == b[i]:
		j += 1
	else:
		res += 1
		moved[b[i]] = 1


print(res)
```

</PySection>
</LanguageSection>
</Spoiler>

## Problems

<Problems problems="general" />

## Quiz

<Quiz>
  <Quiz.Question>
    What is most useful when solving ad hoc problems?
    <Quiz.Answer>
      Being able to quickly recall complex algorithms and data structures.
      <Quiz.Explanation>
        Incorrect. Ad hoc solutions may use specific algorithms and data structures, but a majority of the solution relies on observations and understanding the problem.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer correct>
      Exploring lots of cases and making observations.
      <Quiz.Explanation>
        Correct. Trying small cases allows you to better understand the problem and helps you make more observations. Certain observations may be a crucial part of the solution.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer>
      Relying on previous knowledge on well-studied topics.
      <Quiz.Explanation>
        Incorrect. Ad hoc problems have solutions that are not well-studied and do not fall into any standard categories.
      </Quiz.Explanation>
    </Quiz.Answer>
  </Quiz.Question>
</Quiz>
