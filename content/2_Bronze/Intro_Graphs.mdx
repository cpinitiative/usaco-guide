---
id: intro-graphs
title: Introduction to Graphs
author: Darren Yao, Benjamin Qi
description: 'Visualizing problems as graphs with resources covering basic terminology.'
frequency: 3
---

import { Problem } from '../models';

export const problems = {
	general: [
		new Problem(
			'Silver',
			'Grass Planting',
			'894',
			'Normal',
			false,
			['tree', 'coloring'],
			'If the maximum degree of a vertex is $D$, the answer will be $D + 1$. See the editorial for a proof.'
		),
		new Problem(
			'Bronze',
			'The Great Revegetation',
			'916',
			'Hard',
			false,
			['coloring'],
			"Color each vertex a color that is not used by any of it's adjacent vertices. Since each vertex has at most three neighbors, there will always be a valid color."
		),
		new Problem(
			'Bronze',
			'Livestock Lineup',
			'965',
			'Hard',
			false,
			['path'],
			''
		),
		new Problem(
			'Bronze',
			'Milk Factory',
			'940',
			'Hard',
			false,
			['tree'],
			"The problem can be modelled as a directed tree. The answer is some vertex $x$ such that there are only edges directed towards $x$, and $x$ is the only vertex with this property. Check the editorial for a proof. Additionally, if you've studied depth first search (a silver topic), you can run a DFS from every vertex and check if some vertex can be visited by all other vertices."
		),
		new Problem(
			'Bronze',
			'Family Tree',
			'833',
			'Hard',
			false,
			['tree'],
			'Find the common ancestor between two cows and how many generations away each cow is from this ancestor.'
		),
		new Problem(
			'Bronze',
			'Swapity Swap',
			'1013',
			'Hard',
			false,
			['permutation', 'cycle'],
			'Keep swapping until the permutation returns to its original state. Then, since we know these moves form a cycle, we can do $x mod k$, where $x$ is the number of swaps that remain and $k$ is the length of the cycle, and simulate the rest of the moves.'
		),
		new Problem(
			'Bronze',
			'Cow Evolution',
			'941',
			'Very Hard',
			false,
			['tree'],
			'Check whether the sets of characteristics are nested, or form a proper evolutionary tree. Read the editorial for illustrations and a more detailed explanation.'
		),
	],
};

Graphs can be used to represent many things, from images to wireless signals, but one of the simplest analogies is to a map. Consider a map with several cities and bidirectional roads connecting the cities. Some problems relating to graphs are:

1.  Is city $A$ connected to city $B$? Consider a region to be a group of cities such that each city in the group can reach any other city in said group, but no other cities. How many regions are in this map, and which cities are in which region? (Silver)

2.  What's the shortest distance I have to travel to get from city $A$ to city $B$? (Gold)

For now, it suffices to learn how graphs are represented (usually **adjacency lists**).

<Resources>
	<Resource
		source="CSA"
		title="Introduction to Graphs"
		url="introduction_to_graphs"
		starred
	>
		interactive
	</Resource>
	<Resource
		source="CSA"
		title="Graph Representations"
		url="graph_representation"
		starred
	>
		interactive - adjacency lists and matrices
	</Resource>
	<Resource source="CPH" title="11 - Basics of Graphs" starred>
		graph terminology, representation
	</Resource>
	<Resource source="IUSACO" title="10.1 to 10.3 - Graph Theory">
		graph basics and representation, trees
	</Resource>
	<Resource source="PAPS" title="6.4 - Graphs">
		adjacency matrices, lists, maps
	</Resource>
	<Resource
		source="TC"
		title="Intro to Graphs Section 1"
		url="introduction-to-graphs-and-their-data-structures-section-1"
	></Resource>
</Resources>

## What Does a Bronze Graph Problem Look Like?

All of the problems below fall into at least one of the following two categories:

- The graph's structure is special (it's a tree, path, or a cycle).
- To solve the problem, all you need to do is iterate over the adjacency list of every vertex.

Knowing [DFS](/silver/dfs) can be helpful but it should not be required.

## Problems

<Problems problems={problems.general} />
