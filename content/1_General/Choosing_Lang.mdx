---
id: choosing-lang
title: Choosing a Language
author: Nathan Wang, Benjamin Qi
description: What languages you can use for programming contests.
prerequisites:
  - intro-cp
---

## What Languages Does The USACO Support?

The most popular languages that USACO supports are
[C++17](https://en.wikipedia.org/wiki/C%2B%2B),
[Java](<https://en.wikipedia.org/wiki/Java_(programming_language)>), and
[Python 3](<https://en.wikipedia.org/wiki/Python_(programming_language)>). C is
also supported, but it's essentially a strictly inferior version of C++ and
doesn't have the built-in data structures that are often used.

### What Are The Differences Between C++11 and C++17?

If you're just starting out, you probably won't be using any C++17-specific
features, so submitting in either C++11 or C++17 should suffice. For information
about the features introduced in C++11, C++14, and C++17, check the links below.

- [C++11 for Programming Contests](https://codeforces.com/blog/entry/10124)
- [C++ Tricks (C++11 onwards)](https://codeforces.com/blog/entry/15643)
- [C++14](https://codeforces.com/blog/entry/16262)
- [C++17](https://codeforces.com/blog/entry/57729)

### What Are The Differences Between Python 2 and Python 3?

As the link below mentions, there are many differences between Python 2 and 3.
Python 3 is newer and an overwhelming majority of USACO contestants use it over
Python 2.

- [Python 2 vs Python 3](https://www.geeksforgeeks.org/important-differences-between-python-2-x-and-python-3-x-with-examples/)

## What Language Should I Start Out With?

In general, we recommend the following:

- If you already know one or more of these languages, just use the one you are
  most comfortable with.
- If you don't know any of these languages, you might as well start with C++, as
  C++ users generally don't need to worry as much about their solutions being a
  constant factor too slow. Furthermore, most modules currently lack Java and
  Python support.

Don't overthink choosing a language -- you can always change languages later!

## Can I Pass Every Problem in Every Language?

C++ is typically faster than Java, which in turn is typically faster than
Python. Although both Python and Java receive two times the C++ time limit in
USACO, this is not the case for most other websites (ex. CodeForces, CSES). Even
with the extended time limits, Python and Java sometimes have trouble passing.

<!-- tl;dr no -->

<!-- - **For Bronze, any language will do.** It is possible to receive full credit
  with C++, Java, and Python in Bronze.
- **For Silver<Asterisk>However, if Python is the only language you know / you
  really want to use Python, you can still pass Silver with Python.</Asterisk>,
  Gold, and Platinum, Python is not recommended**, because it is a slow language
  and lacks an ordered map. -->

- It is guaranteed to be able to receive full credit on all Bronze contests with
  Python, C++, and Java.
- Python lacks a data structure that keeps its keys in sorted order (the
  equivalent of `set` in C++), which is required for some Silver problems.
- It is almost always possible to receive full credit on all contests with Java,
  though there are exceptions.

<!-- - Java does not support features such as [macros](/general/generic/#macros),
  [type aliases](/general/generic/#type-aliases-with-using), and `auto` that are
  present in C++ (which some contestants rely on extensively). -->

### Example - [Wormhole Sort](http://www.usaco.org/index.php?page=viewproblem2&cpid=992)

The Java solution presented in the analysis requires over 3s to run (out of a
time limit of 4s).

```java
import java.io.*;
import java.util.*;
public class wormsort {
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new FileReader("wormsort.in"));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		loc = new int[n];
		component = new int[n];
		edges = new LinkedList[n];
		for(int i = 0; i < n; i++) edges[i] = new LinkedList<>();
		lhs = new int[m];
		rhs = new int[m];
		weight = new int[m];
		st = new StringTokenizer(br.readLine());
		for(int i = 0; i < n; i++) loc[i] = Integer.parseInt(st.nextToken())-1;
		for(int i = 0; i < m; i++) {
			st = new StringTokenizer(br.readLine());
			lhs[i] = Integer.parseInt(st.nextToken())-1;
			rhs[i] = Integer.parseInt(st.nextToken())-1;
			weight[i] = Integer.parseInt(st.nextToken());
		}
		br.close();
		int minW = 0;
		int maxW = 1000000001;
		while(minW != maxW) {
			int mid = (minW + maxW + 1) / 2;
			if(valid(mid)) minW = mid;
			else maxW = mid-1;
		}
		if(minW > 1e9) minW = -1;
		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("wormsort.out")));
		pw.println(minW);
		pw.close();
	}
	static int[] loc, lhs, rhs, weight;
	static LinkedList<Integer>[] edges;
	static int[] component;
	private static void dfs(int curr, int label) {
		if(component[curr] == label) return;
		component[curr] = label;
		for(int child: edges[curr]) dfs(child, label);
	}
	private static boolean valid(int minW) {
		Arrays.fill(component, -1);
		for(int i = 0; i < edges.length; i++) edges[i].clear();
		for(int i = 0; i < lhs.length; i++) {
			if(weight[i] >= minW) {
				edges[lhs[i]].add(rhs[i]);
				edges[rhs[i]].add(lhs[i]);
			}
		}
		int numcomps = 0;
		for(int i = 0; i < component.length; i++) {
			if(component[i] < 0) {
				dfs(i, numcomps++);
			}
		}
		for(int i = 0; i < loc.length; i++) {
			if(component[i] != component[loc[i]]) return false;
		}
		return true;
	}
}
```

A comparable C++ solution runs in less than 800ms:

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
vector<int> loc, lhs, rhs, weight;
vector<vector<int>> edges;
vector<int> component;

void dfs(int curr, int label) {
	if(component[curr] == label) return;
	component[curr] = label;
	for(int child: edges[curr]) dfs(child, label);
}

bool valid(int minW) {
	component.assign(n,-1);
	for(int i = 0; i < edges.size(); i++) edges[i].clear();
	for(int i = 0; i < lhs.size(); i++) {
		if(weight[i] >= minW) {
			edges[lhs[i]].push_back(rhs[i]);
			edges[rhs[i]].push_back(lhs[i]);
		}
	}
	int numcomps = 0;
	for(int i = 0; i < component.size(); i++) {
		if(component[i] < 0) {
			dfs(i, numcomps++);
		}
	}
	for(int i = 0; i < loc.size(); i++) {
		if(component[i] != component[loc[i]]) return false;
	}
	return true;
}

int main() {
	freopen("wormsort.in","r",stdin);
	cin >> n >> m;
	loc = vector<int>(n);
	component = vector<int>(n);
	edges = vector<vector<int>>(n);
	lhs = vector<int>(m);
	rhs = vector<int>(m);
	weight = vector<int>(m);
	for(int i = 0; i < n; i++) {
		cin >> loc[i];
		--loc[i];
	}
	for(int i = 0; i < m; i++) {
		cin >> lhs[i] >> rhs[i] >> weight[i];
		--lhs[i], --rhs[i];
	}
	int minW = 0;
	int maxW = 1000000001;
	while(minW != maxW) {
		int mid = (minW + maxW + 1) / 2;
		if(valid(mid)) minW = mid;
		else maxW = mid-1;
	}
	if(minW > 1e9) minW = -1;
	freopen("wormsort.out","w",stdout);
	cout << minW << "\n";
}
```

A comparable Python solution only passes the first five test cases:

```py
import sys
sys.setrecursionlimit(1000000)

sys.stdin = open("wormsort.in","r")
sys.stdout = open("wormsort.out","w")

n,m = map(int,input().split())
loc = [0]*n
component = [0]*n
edges = [[] for i in range(n)]

lhs = [0]*m
rhs = [0]*m
weight = [0]*m

def dfs(curr,label):
	if component[curr] == label: return
	component[curr] = label
	for child in edges[curr]: dfs(child, label)

def valid(minW):
	global component
	component = [-1]*n
	for i in range(n):
		edges[i].clear()
	for i in range(m):
		if weight[i] >= minW:
			edges[lhs[i]].append(rhs[i])
			edges[rhs[i]].append(lhs[i])
	numcomps = 0
	for i in range(n):
		if component[i] < 0:
			dfs(i, numcomps)
			numcomps += 1
	for i in range(n):
		if component[i] != component[loc[i]]: return False
	return True

loc = list(map(lambda x: int(x)-1,input().split()))
for i in range(m):
	lhs[i],rhs[i],weight[i] = map(int,input().split())
	lhs[i] -= 1
	rhs[i] -= 1

minW = 0
maxW = 1000000001
while minW != maxW:
	mid = (minW + maxW + 1) // 2
	if valid(mid):
		minW = mid
	else:
		maxW = mid-1

if minW > 1e9: minW = -1
print(minW)
```

After some optimizations, this solution still passes only the first seven test
cases:

```py
import sys

sys.stdin = open("wormsort.in","r")
sys.stdout = open("wormsort.out","w")

n,m = map(int,input().split())
loc = [0]*n
edges = [[] for i in range(n)]

def valid():
	component = [-1]*n
	numcomps = 0
	for i in range(n):
		if component[i] < 0:
			todo = [i]
			component[i] = numcomps
			next_index = 0
			while next_index < len(todo):
				curr = todo[next_index]
				next_index += 1
				for child,weight in edges[curr]:
					if weight < mid and component[child] < 0:
						component[child] = numcomps
						todo.append(child)
			numcomps += 1
	for i in range(n):
		if component[i] != component[loc[i]]: return False
	return True

loc = list(map(lambda x: int(x)-1,input().split()))
all_edges = []
for i in range(m):
	lhs,rhs,weight = map(int,input().split())
	all_edges.append((weight,lhs-1,rhs-1))

all_edges.sort(reverse=True)
for i in range(m):
	_,lhs,rhs = all_edges[i]
	edges[lhs].append((rhs,i))
	edges[rhs].append((lhs,i))

lo,hi = 0,m
while lo != hi:
	mid = (lo + hi) // 2
	if valid():
		hi = mid
	else:
		lo = mid+1

print(-1 if lo == 0 else all_edges[lo-1][0])
```

We are not sure whether it is possible to modify the above approach to receive
full credit (please let us know if you manage to succeed)! Of course, it is
possible to pass this problem in Python using DSU (a Gold topic):

```py
# Author: Nicolas Hsu

file = open('wormsort.in')
N, M = map(int, file.readline().split())
P = tuple(map(int, ('0 '+file.readline()).split()))
W = [ tuple(map(int, file.readline().split())) for i in range(M) ]
W.sort(key=lambda w:-w[2])

par = list(range(N+1))
def find(u):
	if par[u]==u:
		return u
	else:
		par[u] = find(par[u])
		return par[u]

w = -1
for n in range(1, N+1):
	while find(n)!=find(P[n]):
		w += 1
		par[find(W[w][1])] = find(W[w][0])

out = open('wormsort.out', 'w')
out.write('-1' if w==-1 else str(W[w][2]))
out.close()
```

## What Am I Expected to Know?

You should know how to code in at least one of the languages listed above before
continuing onto the Bronze section of this guide. For a more detailed list on
what you should know, read the ["Expected Knowledge"](/general/expected) module.
