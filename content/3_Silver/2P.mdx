---
id: 2P
title: 'Two Pointers'
author: Darren Yao, Qi Wang
prerequisites:
  - sorting-custom
description:
  'Iterating two monotonic pointers across an array to search for a pair of
  indices satisfying some condition in linear time.'
frequency: 2
---

<Problems problems="sample" />

## Resources

<Resources>
	<Resource source="CPH" title="8.1 - Two Pointers" starred>
		solutions to the problems above
	</Resource>
	<Resource source="IUSACO" title="14.1 - Two Pointers">
		above + mention of max subarray sum
	</Resource>
	<Resource
		source="CF"
		title="CF Edu"
		url="https://codeforces.com/edu/course/2/lesson/9"
		starred
	>
		video explanation of two pointers
	</Resource>
</Resources>

## Two Pointers

The two pointers method iterates two pointers across an array, to track the start and end
of an interval. It can also be used to track two values in an array as show in CPH's 2SUM solution. 

<FocusProblem problem="book" />

## Solution - Books

We want to find the longest continuous segment of books that can be read within $t$ minutes. 

To accomplish this, we can define $\texttt{left}$ and $\texttt{right}$ as the start and end of the segment respectively.

Since being able to read segment $\texttt{left} \dots \texttt{right}$ implies we can read segment $\texttt{left} \dots \texttt{right}-1$, we can use two-pointers (or, alternatively, [binary search](/silver/binary-search)).

For every $\texttt{left}$ index, we need to increase our $\texttt{right}$ pointer until the total time for that segment exceeds $t$.

We will keep track of the max segment size with $\texttt{ans}$, and take the maximum $\texttt{right} - \texttt{left}$ value.

We can then increment $\texttt{left}$ by 1.

**The $\texttt{right}$ pointer does not restart after an iteration, it simply keeps moving right; therefore, since both pointers will move at most $N$ times, the overall time complexity is $\mathcal{O}(N).$**

<Info title="Pro-tip">

You can visualize these pointers as maintaining a sliding window of books for this problem.

</Info>

### Implementation

<LanguageSection>

<CPPSection>


```cpp
#include <bits/stdc++.h> // see /general/running-code-locally
using namespace std;

using ll = long long;

using vi = vector<int>;
#define pb push_back
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()

using pi = pair<int,int>;
#define f first
#define s second
#define mp make_pair

void setIO(string name = "") {
	cin.tie(0)->sync_with_stdio(0); // see /general/fast-io
	if (sz(name)) {
		freopen((name+".in").c_str(), "r", stdin); // see /general/io
		freopen((name+".out").c_str(), "w", stdout);
	}
}


int main() {
	setIO();
	int n, t, ans = 0;
	cin >> n >> t;
	vi books(n);
	for (int i = 0; i < n; i++){
		cin >> books[i];
	}

	int left = 0, right = 0, cur = 0;
	while (left < n && right < n) {
		// Finding the maximum right for which cur is less than t.
		while (right < n) {
			cur += books[right++];
			// Subtracting the exceeded book from cur.
			if (cur > t) {
				cur -= books[--right]; 
				break;
			}
		}

		ans = max(ans, right - left);
		cur -= books[left++];
	}

	cout << ans;
}
```

</CPPSection>

<JavaSection>

```java
import java.util.*;
import java.io.*;

public class Books {
	public static void main(String[] args) {
		Kattio io = new Kattio();

		int n = io.nextInt();
		int t = io.nextInt();
		int[] books = new int[n];
		for (int i = 0; i < n; i++) {
			books[i] = io.nextInt();
		}

		int left = 0, right = 0, cur = 0, ans = 0;
		while (left < n && right < n) {
			// Finding the maximum right for which cur is less than t.
			while (right < n) {
				cur += books[right++];
				// Subtracting the exceeded book from cur.
				if (cur > t) {
					cur -= books[--right]; 
					break;
				}
			}

			ans = Math.max(ans, right - left);
			cur -= books[left++];
		}

		io.println(ans);
		io.close();
	}

	CodeSnip{Kattio}
}
```

</JavaSection>

</LanguageSection>

## Problems

<Problems problems="ad" />
