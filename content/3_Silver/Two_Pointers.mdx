---
id: two-pointers
redirects:
 - /silver/2P
title: 'Two Pointers'
author: Darren Yao, Qi Wang, Ryan Chou, David Zhou
contributors: Aadit Ambadkar, Juheon Rhee
prerequisites:
  - intro-sorting
description:
  'Iterating two monotonic pointers across an array to search for a pair of
  indices satisfying some condition in linear time.'
frequency: 2
---

## Resources

<Resources>
	<Resource source="CPH" title="8.1 - Two Pointers" starred>
		solutions to the problems above
	</Resource>
	<Resource source="IUSACO" title="14.1 - Two Pointers">
		above + mention of max subarray sum
	</Resource>
	<Resource
		source="CF EDU"
		title="Two Pointers Method"
		url="https://codeforces.com/edu/course/2/lesson/9"
		starred
	>
		video explanation of two pointers
	</Resource>
</Resources>

<YouTube id = "zmadiUuUeAA"/>

## Two Pointers

The **Two Pointers** method iterates two pointers across an array to track indices satisfying some condition. There are two common variations:
1. Two pointers starting at different ends of the array and moving towards each other.
2. Two pointers moving in the same direction at different speeds. This variation is known as the **Sliding Window** algorithm.

## Sum of Two Values

<FocusProblem problem="sample1" />

### Solution - Sum of Two Values

The "Opposite Ends" method allows us to find the target pair in linear time if the array is sorted. Instead of checking every possible pair (which would take $\mathcal{O}(N^2)$ time), we use the sorted property to narrow down the search space in a single pass.

We want to find two indices $i$ and $j$ such that $a_i + a_j = x$.

We can start by sorting the array. Then, we can initialize a left pointer at the beginning of the array ($l=0$) and a right pointer at the end ($r=N-1$).

While $l < r$:
1. If $a[l] + a[r] == x$, we have found the target sum.
2. If $a[l] + a[r] < x$, the sum is too small. To increase the sum, we increment $l$.
3. If $a[l] + a[r] > x$, the sum is too large. To decrease the sum, we decrement $r$.

Since the array is sorted, moving the left pointer to the right will never decrease the sum, and moving the right pointer to the left will never increase the sum.

### Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>

using namespace std;

int main() {
	int n, x;
	cin >> n >> x;
	vector<pair<int, int>> nums(n);
	for (int i = 0; i < n; i++) {
		cin >> nums[i].first;
		nums[i].second = i;
	}
	sort(nums.begin(), nums.end());
	int l = 0, r = n - 1;
	while (l < r) {
		int sum = nums[l].first + nums[r].first;
		if (sum == x) {
			cout << nums[l].second + 1 << " " << nums[r].second + 1 << endl;
			return 0;
		} else if (sum < x) {
			l++;
		} else if (sum > x) {
			r--;
		}
	}
	cout << "IMPOSSIBLE" << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int x = Integer.parseInt(st.nextToken());

		List<int[]> nums = new ArrayList<>();
		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) {
			nums.add(new int[] {Integer.parseInt(st.nextToken()), i});
		}
		nums.sort(Comparator.comparingInt(a -> a[0]));
		int l = 0, r = n - 1;
		while (l < r) {
			int sum = nums.get(l)[0] + nums.get(r)[0];
			if (sum == x) {
				System.out.println((nums.get(l)[1] + 1) + " " + (nums.get(r)[1] + 1));
				return;
			} else if (sum < x) {
				l++;
			} else {
				r--;
			}
		}

		System.out.println("IMPOSSIBLE");
	}
}
```

</JavaSection>
<PySection>

```py
n, x = map(int, input().split())

nums = [(int(val), i) for i, val in enumerate(input().split())]
nums.sort()

l = 0
r = n - 1
while l < r:
	sum = nums[l][0] + nums[r][0]
	if sum == x:
		print(nums[l][1] + 1, nums[r][1] + 1)
		exit()
	elif sum < x:
		l += 1
	else:
		r -= 1

print("IMPOSSIBLE")
```

</PySection>
</LanguageSection>

## Problems

<Problems problems="general" />

## Quiz

<Quiz>
  <Quiz.Question>
    What is the two pointers algorithm?
    <Quiz.Answer>
      Keeping track of two indices to find a subarray that satisfies some condition.
      <Quiz.Explanation>
        Incorrect. The indices don't necessarily have to represent a subarray, they could just represent elements in the array.

      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer correct>
      Keeping track of two indices to find a pair of indices that satisfy some condition.
      <Quiz.Explanation>
        Correct.

      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer>
      A way to answer range sum queries in $\mathcal{O}(1)$ time.
      <Quiz.Explanation>
        Incorrect. You might be thinking of [Prefix Sums](/silver/prefix-sums), another silver topic.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer>
      A divide and conquer algorithm that splits an array into two halves to efficiently find an element satisfying a certain condition.
      <Quiz.Explanation>
        Incorrect.
      </Quiz.Explanation>
    </Quiz.Answer>
  </Quiz.Question>
  <Quiz.Question>
    What should go in place of `cond`?

	<LanguageSection>
		<CPPSection>

			```cpp
			/*
			 * find two elements at distinct positions in an array
			 * which add up to a target sum
			 */
			sort(begin(nums), end(nums));
			int l = 0;
			int r = n - 1;
			while (cond) {
				if (nums[l] + nums[r] == target) {
					// found pair
					break;
				} else if (nums[l] + nums[r] > target) {
					r--;
				} else {
					l++;
				}
			}
			```
		</CPPSection>
		<JavaSection>
		```java
		/*
		 * find two elements at distinct positions in an array
		 * which add up to a target sum
		 */
		Arrays.sort(nums);
		int l = 0;
		int r = n - 1;
		while (cond) {
			if (nums[l] + nums[r] == target) {
				// found pair
				break;
			} else if (nums[l] + nums[r] > target) {
				r--;
			} else {
				l++;
			}
		}
		```
		</JavaSection>
		<PySection>

			```py
			nums.sort()
			l = 0
			r = n - 1
			while cond:
				if nums[l] + nums[r] == target:
					# found pair
					break
				elif nums[l] + nums[r] > target:
					r -= 1
				else:
					l += 1
			```
		</PySection>
	</LanguageSection>
    <Quiz.Answer>
      `nums[r] - nums[l] != 0`
      <Quiz.Explanation>
        Incorrect. We already have an exit condition in the loop and we're looking for two elements which add up to a target sum.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer correct>
      `l < r`
      <Quiz.Explanation>
        Correct. When the pointers overlap, they're looking for another solution to test when it doesn't exist.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer>
      `l < 0 || l >= n || r < 0 || r >= n`
      <Quiz.Explanation>
        Incorrect. The pointers are moving towards the middle of the array.
      </Quiz.Explanation>
    </Quiz.Answer>
  </Quiz.Question>
  <Quiz.Question>
    Which of the following isn't true?
    <Quiz.Answer>
      The time complexity of a standard two pointers algorithm is $\mathcal{O}(N)$ when not considering any other operations on the array.
      <Quiz.Explanation>
        Incorrect. Assuming that both pointers move one step at a time, both pointers would take a maximum of $N$ steps.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer>
      The space complexity of a standard two pointers algorithm is $\mathcal{O}(1)$ when not considering the space taken up by the array.
      <Quiz.Explanation>
        Incorrect. Assuming that both pointers move one step at a time, there would be a constant space complexity.
      </Quiz.Explanation>
    </Quiz.Answer>
    <Quiz.Answer correct>
      The two pointers algorithm is only useful in a sorted array.
      <Quiz.Explanation>
        Correct. The array doesn't necessarily have to be sorted, such as when looking for a valid subarray with two pointers.
      </Quiz.Explanation>
    </Quiz.Answer>
  </Quiz.Question>
</Quiz>
