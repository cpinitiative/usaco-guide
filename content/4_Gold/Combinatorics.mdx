---
id: combo
title: 'Combinatorics'
author: Jesse Choe, Aadit Ambadkar, Dustin Miao, Mihnea Brebenel
prerequisites:
  - divisibility
  - modular
description: How to count.
frequency: 2
---

If you've never encountered any **combinatorics** before, AoPS is a good place
to start.

<Resources>
	<Resource
		source="AoPS"
		title="Alcumus"
		url="https://artofproblemsolving.com/alcumus/problem"
		starred
	>
		practice problems, set focus to Counting and Probability.
	</Resource>
	<Resource
		source="AoPS"
		title="Intro to Counting and Probability"
		url="https://artofproblemsolving.com/store/book/intro-counting"
	>
		good book
	</Resource>
</Resources>

## Resources

<Resources>
	<Resource source="CPH" title="22 - Combinatorics" url = "https://usaco.guide/CPH.pdf#page=217" starred>
		module is based off of this
	</Resource>
	<Resource source="cp-algo" title="Combinatorics" url = "https://cp-algorithms.com/algebra/factorial-divisors.html">

	</Resource>
	<Resource source="HE" title="Basics of Combinatorics" url = "https://www.hackerearth.com/practice/math/combinatorics/basics-of-combinatorics/tutorial/">
		teaches fundamental combinatorics with a practice problem at the end
	</Resource>
	<Resource source="AoPS" title="Introductory Combinatorics" url = "https://artofproblemsolving.com/wiki/index.php/Combinatorics/Introduction" starred>
		teaches basic combinatorics concepts
	</Resource>
	<Resource source="AoPS" title="Intermediate Combinatorics" url = "https://artofproblemsolving.com/wiki/index.php/Combinatorics/Intermediate">
		teaches more advanced combinatorics concepts
	</Resource>
	<Resource source="CF" title="Expected Value" url = "https://codeforces.com/blog/entry/62690">
		a good blog about the expected value
	</Resource>
	<Resource source="CF" title="Inclusion-Exclusion Principle" url = "https://codeforces.com/blog/entry/64625">
		a good blog about the inclusion-exclusion principle
	</Resource>
</Resources>

If you prefer watching videos instead, here are some options:

<Resources>
	<Resource source="YouTube" title="Deep Dive into Combinatorics" url = "https://www.youtube.com/playlist?list=PLDcSwjT2BF_W7hSCiSAVk1MmeGLC3xYGg">
		playlist by mathemaniac
	</Resource>
	<Resource source="YouTube" title="MIT 6.042J" url = "https://www.youtube.com/playlist?list=PLB7540DEDD482705B">
		lectures 16-23
	</Resource>
	<Resource source="YouTube" title="Sums and Expected Value #1" url = "https://www.youtube.com/watch?v=U_h3IjreRek">
		Errichto video regarding expected value and sums of subsets
	</Resource>
</Resources>

## Binomial Coefficients

<FocusProblem problem="sample1" />

The **binomial coefficient** $\binom{n}{k}$ (pronounced as "$n$ choose $k$" or
sometimes written as ${}_nC_k$) represents the number of ways to choose a subset
of $k$ elements from a set of $n$ elements. For example, $\binom{4}{2} = 6$,
because the set $\{1,2,3,4\}$ has $6$ subsets of $2$ elements:

$$
\{1, 2\}, \{1, 3\}, \{1, 4\}, \{2, 3\}, \{2, 4\}, \{3, 4\}
$$

There are two ways to calculate binomial coefficients:

### Method 1: Pascal's Triangle (Dynamic Programming) - $\mathcal{O}(n^2)$

Binomial coefficients can be recursively calculated as follows:

$$
	\binom{n}{k} = \binom{n - 1}{k - 1} + \binom{n - 1}{k}
$$

The intuition behind this is to fix an element $x$ in the set and choose $k − 1$
elements from $n − 1$ elements if $x$ is included in the set or choose $k$
elements from $n − 1$ elements, otherwise.

The base cases for the recursion are:

$$
	\binom{n}{0} = \binom{n}{n}  = 1
$$

because there is always exactly one way to construct an empty subset and a
subset that contains all the elements.

This recursive formula is commonly known as [Pascal's
Triangle](https://brilliant.org/wiki/pascals-triangle/).

A naive implementation of this would use a recursive formula, like below:

<LanguageSection>
<CPPSection>


```cpp
/** @return nCk mod p using naive recursion */
int binomial(int n, int k, int p) {
	if (k == 0 || k == n) { return 1; }
	return (binomial(n - 1, k - 1, p) + binomial(n - 1, k, p)) % p;
}
```

</CPPSection>
<JavaSection>

```java
/** @return nCk mod p using naive recursion */
public static int binomial(int n, int k, int p) {
	if (k == 0 || k == n) { return 1; }
	return (binomial(n - 1, k - 1, p) + binomial(n - 1, k, p)) % p;
}
```

</JavaSection>
<PySection>

```py
def binomial(n: int, k: int, p: int) -> int:
	""":return: nCk mod p using naive recursion"""
	if k == 0 or k == n:
		return 1
	return (binomial(n - 1, k - 1, p) + binomial(n - 1, k, p)) % p
```

</PySection>
</LanguageSection>

Additionally, we can optimize this from $\mathcal{O}(2^n)$ to $\mathcal{O}(n^2)$
using [dynamic programming](/gold/intro-dp) (DP) by caching the values of
smaller binomials to prevent recalculating the same values over and over again.
The code below shows a bottom-up implementation of this.

<LanguageSection>
<CPPSection>

```cpp
/** @return nCk mod p using dynamic programming */
int binomial(int n, int k, int p) {
	// dp[i][j] stores iCj
	vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));

	// base cases described above
	for (int i = 0; i <= n; i++) {
		/*
		 * i choose 0 is always 1 since there is exactly one way
		 * to choose 0 elements from a set of i elements
		 * (don't choose anything)
		 */
		dp[i][0] = 1;
		/*
		 * i choose i is always 1 since there is exactly one way
		 * to choose i elements from a set of i elements
		 * (choose every element in the set)
		 */
		if (i <= k) { dp[i][i] = 1; }
	}

	for (int i = 0; i <= n; i++) {
		for (int j = 1; j <= min(i, k); j++) {
			if (i != j) {  // skips over the base cases
				// uses the recurrence relation above
				dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % p;
			}
		}
	}

	return dp[n][k];  // returns nCk modulo p
}
```

</CPPSection>
<JavaSection>

```java
/** @return nCk mod p using dynamic programming */
public static int binomial(int n, int k, int p) {
	// dp[i][j] stores iCj
	int[][] dp = new int[n + 1][k + 1];

	// base cases described above
	for (int i = 0; i <= n; i++) {
		/*
		 * i choose 0 is always 1 since there is exactly one way
		 * to choose 0 elements from a set of i elements
		 * (don't choose anything)
		 */
		dp[i][0] = 1;
		/*
		 * i choose i is always 1 since there is exactly one way
		 * to choose i elements from a set of i elements
		 * (choose every element in the set)
		 */
		if (i <= k) { dp[i][i] = 1; }
	}

	for (int i = 0; i <= n; i++) {
		for (int j = 1; j <= Math.min(i, k); j++) {
			if (i != j) {  // skips over the base cases
				// uses the recurrence relation above
				dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % p;
			}
		}
	}

	return dp[n][k];  // returns nCk modulo p
}
```

</JavaSection>
<PySection>

```py
def binomial(n: int, k, p):
	""":return: nCk mod p using dynamic programming"""
	# dp[i][j] stores iCj
	dp = [[0] * (k + 1) for _ in range(n + 1)]

	# base cases described above
	for i in range(n + 1):
		"""
		i choose 0 is always 1 since there is exactly one way
		to choose 0 elements from a set of i elements
		(don't choose anything
		"""
		dp[i][0] = 1
		"""
		i choose i is always 1 since there is exactly one way
		to choose i elements from a set of i elements
		(choose every element in the set)
		"""
		if i <= k:
			dp[i][i] = 1

	for i in range(n + 1):
		for j in range(1, min(i, k) + 1):
			if i != j:  # skips over the base cases
				# uses the recurrence relation above
				dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % p

	return dp[n][k]  # returns nCk modulo p
```

</PySection>
</LanguageSection>

### Method 2: Factorial Definition (Modular Inverses) - $\mathcal{O}(n + \log MOD)$

Define $n!$ as $n \times (n - 1) \times (n - 2) \times \ldots 1$. $n!$
represents the number of permutations of a set of $n$ elements. See [this AoPS
Article](https://artofproblemsolving.com/wiki/index.php/Factorial) for more
details.

Another way to calculate binomial coefficients is as follows:

$$
	\binom{n}{k} = \frac{n!}{k!(n-k)!}
$$

Recall that $\binom{n}{k}$ also represents the number of ways to choose $k$
elements from a set of $n$ elements. One strategy to get all such combinations
is to go through all possible permutations of the $n$ elements, and only pick
the first $k$ elements out of each permutation. There are $n!$ ways to do so.
However, note the the order of the elements inside and outside the subset does
not matter, so the result is divided by $k!$ and $(n − k)!$.

Since these binomial coefficients are large, problems typically require us to
output the answer modulo a large prime $p$ such as $10^9 + 7$. Fortunately, we
can use [modular inverses](/gold/modular) to divide $n!$ by $k!$ and $(n - k)!$
modulo $p$ for any prime $p$. Computing inverse factorials **online** can be
very time costly. Instead, we can **precompute** all factorials in
$\mathcal{O}(n)$ time and inverse factorials in $\mathcal{O}(n + \log MOD)$.
First, we compute the modular inverse of the largest factorial using binary
exponentiation. For the rest, we use the fact that $(n!)^{-1} \equiv
(n!)^{-1}\times (n+1)^{-1} \times (n+1) \equiv ((n+1)!)^{-1}\times (n+1)$. See
the code below for the implementation.

<LanguageSection>
<CPPSection>

```cpp
const int MAXN = 1e6;

long long fac[MAXN + 1];
long long inv[MAXN + 1];

/** @return x^n modulo m in O(log p) time. */
long long exp(long long x, long long n, long long m) {
	x %= m;  // note: m * m must be less than 2^63 to avoid ll overflow
	long long res = 1;
	while (n > 0) {
		if (n % 2 == 1) { res = res * x % m; }
		x = x * x % m;
		n /= 2;
	}
	return res;
}

/** Precomputes n! from 0 to MAXN. */
void factorial(long long p) {
	fac[0] = 1;
	for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % p; }
}

/**
 * Precomputes all modular inverse factorials
 * from 0 to MAXN in O(n + log p) time
 */
void inverses(long long p) {
	inv[MAXN] = exp(fac[MAXN], p - 2, p);
	for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % p; }
}

/** @return nCr mod p */
long long choose(long long n, long long r, long long p) {
	return fac[n] * inv[r] % p * inv[n - r] % p;
}
```

</CPPSection>
<JavaSection>

```java
import java.util.*;

public class BinomialCoefficients {
	private static final int MAXN = (int)1e6;
	private static long[] fac = new long[MAXN + 1];
	private static long[] inv = new long[MAXN + 1];

	/** @return x^n modulo m in O(log p) time. */
	private static long exp(long x, long n, long m) {
		x %= m;  // note: m * m must be less than 2^63 to avoid ll overflow
		long res = 1;
		while (n > 0) {
			if (n % 2 == 1) { res = res * x % m; }
			x = x * x % m;
			n /= 2;
		}
		return res;
	}

	/** Precomputes n! from 0 to MAXN. */
	private static void factorial(long p) {
		fac[0] = 1;
		for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % p; }
	}

	/**
	 * Precomputes all modular inverse factorials
	 * from 0 to MAXN in O(n + log p) time
	 */
	private static void inverses(long p) {
		inv[MAXN] = exp(fac[MAXN], p - 2, p);
		for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % p; }
	}

	/** @return nCr mod p */
	private static long choose(long n, long r, long p) {
		return fac[(int)n] * inv[(int)r] % p * inv[(int)(n - r)] % p;
	}
}
```

</JavaSection>
<PySection>

```py
MAXN = 10**6

fac = [0] * (MAXN + 1)
inv = [0] * (MAXN + 1)


def exp(x: int, n: int, m: int) -> int:
	""":return: x^n modulo m in O(log p) time."""
	x %= m  # note: m * m must be less than 2^63 to avoid ll overflow
	res = 1
	while n > 0:
		if n % 2 == 1:
			res = (res * x) % m
		x = (x * x) % m
		n //= 2
	return res


def factorial(p: int):
	"""Precomputes n! from 0 to MAXN."""
	global fac
	fac[0] = 1
	for i in range(1, MAXN + 1):
		fac[i] = (fac[i - 1] * i) % p


def inverses(p: int):
	"""
	Precomputes all modular inverse factorials from 0 to MAXN in O(n + log p) time
	"""
	global inv
	inv[MAXN] = exp(fac[MAXN], p - 2, p)
	for i in range(MAXN, 0, -1):
		inv[i - 1] = (inv[i] * i) % p


def choose(n: int, r: int, p: int):
	""":return: nCr mod p"""
	return fac[n] * inv[r] % p * inv[n - r] % p
```

</PySection>
</LanguageSection>

### Solution - Binomial Coefficients

The first method for calculating binomial factorials is too slow for this
problem since the constraints on $a$ and $b$ are $(1 \leq b \leq a \leq 10^6)$
(recall that the first implementation runs in $\mathcal{O}(n^2)$ time
complexity). However, we can use the second method to answer each of the $n$
queries in constant time by precomputing factorials and their modular inverses.

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
using namespace std;
using ll = long long;

const int MAXN = 1e6;
const int MOD = 1e9 + 7;

ll fac[MAXN + 1];
ll inv[MAXN + 1];

// BeginCodeSnip{Counting functions}
ll exp(ll x, ll n, ll m) {
	x %= m;
	ll res = 1;
	while (n > 0) {
		if (n % 2 == 1) { res = res * x % m; }
		x = x * x % m;
		n /= 2;
	}
	return res;
}

void factorial() {
	fac[0] = 1;
	for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; }
}

void inverses() {
	inv[MAXN] = exp(fac[MAXN], MOD - 2, MOD);
	for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % MOD; }
}

ll choose(int n, int r) { return fac[n] * inv[r] % MOD * inv[n - r] % MOD; }
// EndCodeSnip

int main() {
	factorial();
	inverses();
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int a, b;
		cin >> a >> b;
		cout << choose(a, b) << '\n';
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class BinomialCoefficients {
	private static final int MAXN = (int)1e6;
	private static final int MOD = (int)1e9 + 7;
	private static long[] fac = new long[MAXN + 1];
	private static long[] inv = new long[MAXN + 1];

	public static void main(String[] args) {
		factorial();
		inverses();
		Kattio io = new Kattio();
		int n = io.nextInt();
		for (int i = 0; i < n; i++) {
			int a = io.nextInt();
			int b = io.nextInt();
			System.out.println(choose(a, b));
		}
	}

	// BeginCodeSnip{Counting Functions}
	private static long exp(long x, long n, long m) {
		x %= m;
		long res = 1;
		while (n > 0) {
			if (n % 2 == 1) { res = (res * x) % m; }
			x = (x * x) % m;
			n /= 2;
		}
		return res;
	}

	private static void factorial() {
		fac[0] = 1;
		for (int i = 1; i <= MAXN; i++) { fac[i] = (fac[i - 1] * i) % MOD; }
	}

	private static void inverses() {
		inv[MAXN] = exp(fac[MAXN], MOD - 2, MOD);
		for (int i = MAXN; i >= 1; i--) { inv[i - 1] = (inv[i] * i) % MOD; }
	}

	private static long choose(int n, int r) {
		return (((fac[n] * inv[r]) % MOD) * inv[n - r]) % MOD;
	}
	// EndCodeSnip

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
MAXN = 10**6
MOD = 10**9 + 7

fac = [0] * (MAXN + 1)
inv = [0] * (MAXN + 1)


# BeginCodeSnip{Counting Functions}
def exp(x: int, n: int, m: int) -> int:
	x %= m
	res = 1
	while n > 0:
		if n % 2 == 1:
			res = res * x % m
		x = x * x % m
		n //= 2
	return res


def factorial():
	fac[0] = 1
	for i in range(1, MAXN + 1):
		fac[i] = fac[i - 1] * i % MOD


def inverses():
	inv[MAXN] = exp(fac[MAXN], MOD - 2, MOD)
	for i in range(MAXN, 0, -1):
		inv[i - 1] = inv[i] * i % MOD


def choose(n: int, r: int):
	return fac[n] * inv[r] % MOD * inv[n - r] % MOD


# EndCodeSnip


factorial()
inverses()
n = int(input())
for _ in range(n):
	a, b = map(int, input().split())
	print(choose(a, b))
```

</PySection>
</LanguageSection>

## Derangements

<FocusProblem problem="sample2" />

The number of derangements of $n$ numbers, expressed as $!n$, is the number of
permutations such that no element appears in its original position. Informally,
it is the number of ways $n$ hats can be returned to $n$ people such that no
person recieves their own hat.

### Method 1: Principle of Inclusion-Exclusion

Suppose we had events $E_1, E_2, \dots, E_n$, where event $E_i$ corresponds to
person $i$ recieving their own hat. We would like to calculate $n! - \lvert E_1
\cup E_2 \cup \dots \cup E_n \rvert$.

We subtract from $n!$ the number of ways for each event to occur; that is,
consider the quantity $n! - \lvert E_1 \rvert - \lvert E_2 \rvert - \dots -
\lvert E_n \rvert$. This undercounts, as we are subtracting cases where more
than one event occurs too many times. Specifically, for a permutation where at
least two events occur, we undercount by one. Thus, add back the number of ways
for two events to occur. We can continue this process for every size of subsets
of indices. The expression is now of the form:

$$
n! - \lvert E_1 \cup E_2 \cup \dots \cup E_n \rvert = \sum_{k = 1}^n (-1)^k \cdot (\text{number of permutations with $k$ fixed points})
$$

For a set size of $k$, the number of permutations with at least $k$ indicies can
be computed by choosing a set of size $k$ that are fixed, and permuting the
other indices. In mathematical terms:

$$
{n \choose k}(n-k)! = \frac{n!}{k!(n-k)!}(n-k)! = \frac{n!}{k!}
$$

Thus, the problem now becomes computing

$$
n!\sum_{k=0}^n\frac{(-1)^k}{k!}
$$

which can be done in linear time.

<LanguageSection>
<CPPSection>

```cpp
#include <atcoder/modint>
#include <bits/stdc++.h>

using namespace std;
using mint = atcoder::modint;

int main() {
	int n, m;
	cin >> n >> m;
	mint::set_mod(m);

	mint c = 1;
	for (int i = 1; i <= n; i++) {
		c = (c * i) + (i % 2 == 1 ? -1 : 1);
		cout << c.val() << ' ';
	}
	cout << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int m = scanner.nextInt();

		long c = 1;
		for (int i = 1; i <= n; i++) {
			c = (c * i) + (i % 2 == 1 ? -1 : 1);
			c %= m;
			c += m;
			c %= m;
			System.out.print(c + " ");
		}
		System.out.println();
	}
}
```

</JavaSection>
<PySection>

```py
n, m = map(int, input().split())
c = 1
for i in range(1, n + 1):
	c = (c * i) + (-1 if i % 2 == 1 else 1)
	c %= m
	c += m
	c %= m
	print(c, end=" ")

print()
```

</PySection>
</LanguageSection>

### Method 2: Dynamic Programming

Suppose person 1 recieved person $i$'s hat. There are two cases:

1. If person $i$ recieves person 1's hat, then the problem is reduced to a
   subproblem of size $n - 2$. There are $n - 1$ possibilities for $i$ in this
   case, so we add to the current answer $(n - 1)\cdot !(n - 2)$.
2. If person $i$ does not recieve person 1's hat, then we can reassign person
   1's hat to be person $i$'s hat (if they recieved person 1's hat, then this
   would become first case). Thus, this becomes a subproblems with size $n - 1$,
   are there $n - 1$ ways to choose $i$.

Thus, we have

$$
!n = (n - 1)(!(n - 2) + !(n - 1))
$$

which can be computed in linear time with a simple DP. The base cases are that
$!0 = 1$ and $!1 = 0$.

<LanguageSection>
<CPPSection>

```cpp
#include <atcoder/modint>
#include <bits/stdc++.h>

using namespace std;
using mint = atcoder::modint;

int main() {
	int n, m;
	cin >> n >> m;
	mint::set_mod(m);

	mint a = 1, b = 0;
	cout << 0 << ' ';

	for (int i = 2; i <= n; i++) {
		mint c = (i - 1) * (a + b);
		cout << c.val() << ' ';
		a = b;
		b = c;
	}
	cout << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int m = scanner.nextInt();

		int a = 1;
		int b = 0;

		System.out.print("0 ");
		for (int i = 2; i <= n; i++) {
			int c = (int)(((long)(i - 1) * (a + b)) % m);
			System.out.print(c + " ");
			a = b;
			b = c;
		}
		System.out.println();
	}
}
```

</JavaSection>
<PySection>

```py
n, m = map(int, input().split())
a, b = 1, 0

print(0, end=" ")
for i in range(2, n + 1):
	c = (i - 1) * (a + b) % m
	print(c, end=" ")
	a, b = b, c

print()
```

</PySection>
</LanguageSection>

## Catalan Numbers

<Resources>
	<Resource
		source="cp-algo"
		title="Catalan Numbers"
		url="https://cp-algorithms.com/combinatorics/catalan-numbers.html"
		starred
	>
		Well documented article.
	</Resource>
</Resources>

The [Catalan numbers](https://en.wikipedia.org/wiki/Catalan_number) are a sequence of positive integers that can be very useful in counting problems in combinatorics.
The $n$-th Catalan can be expressed as following using binomial coeffiecients:

$$
C_n=\frac{1}{n+1}\cdot \binom{2n}{n}=\frac{(2n)!}{(n+1)!\,n!}
$$

They also have the recurrence formula
$$
C_{n+1}= \sum^{n}_{i=0}{C_i \cdot C_{n-i}} \,\,\, \text{ for } n \ge 0 \\
$$
which can also be expressed as
$$
C_n=\frac{2(2n-1)}{n+1} \cdot C_{n-1}
$$

The first $5$ Catalan numbers are

<center>

| n | 0| 1 | 2 | 3 | 4 | 5 |
|---| -| - | - | - | - | - |
| $C_n$| 1 | 1 | 2 | 5 | 14| 42 |

</center>

### Applications

The Catalan numbers can be used to represent a wide variety of things.

For example, $C_n$ is equal to the number of valid parenthesis expressions of length $2n$.
Take, for instance, $C_3=5$:
* `()()()`
* `(())()`
* `()(())`
* `((()))`
* `(()())`

It's also equal to the number of full binary trees with $n+1$ leaves.
The following image shows the $5$ binary trees with $4$ leaves:

![binary-trees](./assets/catalan-binary-trees.png)

$C_n$ is also the number of monotonic lattice paths along the edges of a $n \times n$ grid that don't pass above the diagonal.
The paths start in the lower left corner and ends in the upper right corner.

For example, there are $C_4=14$ paths in a $4 \times 4 grid$:

![lattice points](./assets/catalan-lattice-paths.png)

The next two examples are a bit more niche, but they're still interesting to think about.

Consider a convex polygon with $n+2$ sides divided into $n$ triangles by connecting vertices with non-intersecting lines.
The number of different ways to divide the polygon in this way is equal to $C_n$.

Here's the particular case for $n=3$ in which we have $C_3=5$:

![polygons](./assets/catalan-polygons.png)

$C_n$ is also equal to the number of [mountain ranges](https://mathcircle.berkeley.edu/sites/default/files/BMC6/pdf0607/catalan.pdf#page=2) of length $2n$ consisting of $n$ upstrokes and $n$ downstrokes.

![mountains](./assets/catalan-mountain-strokes.png)

<FocusProblem problem="sample3" />

### Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>

using namespace std;

const int MOD = 1e6;
const int MAX_N = 2e3;

int main() {
	int catalan[MAX_N][MAX_N];
	for (int i = 1; i < MAX_N; i++) {
		for (int j = 0; j <= i; j++) {
			if (j == 0) {
				catalan[i][j] = 1;
			} else {
				catalan[i][j] = (catalan[i][j - 1] + catalan[i - 1][j]) % MOD;
			}
		}
	}

	int n;
	while (cin >> n) {
		if (n == 0) { break; }
		cout << catalan[n][n] << '\n';
	}
}
```

</CPPSection>
</LanguageSection>

## Stars and Bars

<Resources>
	<Resource
		source="cp-algo"
		title="Stars and bars"
		url="https://cp-algorithms.com/combinatorics/stars_and_bars.html"
		starred
	>
	</Resource>
	<Resource
		source="Medium"
		title="The Stars and Bars Formula"
		url="https://medium.com/statistics-theory/the-stars-and-bars-formula-b1c09c2b27b4"
	>
		Well documented article.
	</Resource>
</Resources>

[Stars and Bars](https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)) is a useful method in combinatorics that involves
grouping indistinguishable objects into distinguishable boxes. The number ways to put $n$ indistinguishable objects into
$k$ distinguishable boxes is:

$$
\binom{n+k-1}{n}=\binom{n+k-1}{k-1}
$$

The second binomial coefficient from above can be derived from the property of binomial coefficients: $\binom{n}{k}=\binom{n}{n-k}$.

Let's take a look at a particular example for $n=3$ and $k=2$ that has $4$ possibilities. As the name implies, the visualization is usually done with stars
separated into groups by bars:

$$
||\bigstar \bigstar \bigstar  \\
|\bigstar |\bigstar \bigstar  \\
|\bigstar \bigstar| \bigstar  \\
\bigstar \bigstar \bigstar ||  \\
$$

As you've probably noticed, there can be empty boxes - when we put all the stars in the first or second box. There may be cases in
which the all the boxes should be non-empty. In that case, the number of ways to put $n$ indistinguishable objects into $k$
distinguishable **non-empty** boxes is: $\binom{n-1}{k-1}$

<FocusProblem problem="sample4" />

### Explanation

For this problem we should think the other way around: let's say that the $k$ colors from which we choose are in fact boxes and instead of choosing $n$ marbles we put them
in the respective boxes. The problem has the restriction that we should pick at least one marble of all kinds, which means in our new perspective that all the boxes should be
non-empty. Thus, the answer is obtained by the second formula: $\binom{n-1}{k-1}$

### Implementation

**Time Complexity:** $\mathcal(O)(T \cdot K)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>

using namespace std;

long long comb(int n, int k) {
	if (k > n - k) { k = n - k; }
	long long ans = 1;
	for (int i = 0; i < k; i++) { ans = ans * (n - i) / (i + 1); }
	return ans;
}

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int n, k;
		cin >> n >> k;
		cout << comb(n - 1, k - 1) << '\n';
	}
}
```

</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />
