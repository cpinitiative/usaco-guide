---
id: PURS
title: 'Point Update Range Sum'
author: Benjamin Qi, Dong Liu, Nathan Gong
contributors: Andrew Wang, Pramana Saldin
prerequisites:
  - prefix-sums
description:
  'Segment Tree, Binary Indexed Tree, and Order Statistic Tree (in C++).'
frequency: 3
---

Most gold range query problems require you to support following tasks in
$\mathcal{O}(\log N)$ time each on an array of size $N$:

- Update the element at a single position (point).
- Query the sum of some consecutive subarray.

Both **segment trees** and **binary indexed trees** can accomplish this.

## Segment Tree

<FocusProblem problem="segSam" />

A **segment tree** allows you to do point update and range query in
$\mathcal{O}(\log N)$ time each for **any** associative operation, not just
summation.

### Resources

<Info title="Pro Tip">

You can skip more advanced applications such as **lazy propagation** for now.
They will be covered in [platinum](/plat/seg-ext).

</Info>

<Resources>
	<Resource
		source="CF EDU"
		title="Segment Tree Pt 1 Steps 1, 3, 4"
		url="https://codeforces.com/edu/course/2/lesson/4/1"
		starred
	>
		basic operations, inversion counting
	</Resource>
	<Resource source="CSA" title="Segment Trees" url="segment_trees" starred>
		Interactive updates.
	</Resource>
	<Resource source="CPH" title="9.3 - Segment Trees" starred>
		Same implementation as AICash below.
	</Resource>
	<Resource source="CPC" title="3 - Data Structures" url="03_data_structures">
		See slides after union-find. Also introduces sqrt bucketing.
	</Resource>
	<Resource
		source="cp-algo"
		title="Simplest form of a Segment Tree"
		url="data_structures/segment_tree.html"
	>
		"Advanced versions" are covered in Platinum.
	</Resource>
</Resources>

### Solution - Dynamic Range Minimum Queries

<Resources>
	<Resource
		source="CF"
		title="AICash - Efficient and easy segment trees"
		url="18051"
	>
		simple implementation
	</Resource>
	<Resource
		source="KACTL"
		title="Segment Tree"
		url="https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/SegmentTree.h"
	>
		similar to above
	</Resource>
</Resources>

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::vector;

/** A data structure that can answer point update & range minimum queries. */
template <class T> class MinSegmentTree {
  private:
	const T DEFAULT = 1e18;  // Will overflow if T is an int

	vector<T> segtree;
	int len;

  public:
	MinSegmentTree(int len) : len(len), segtree(len * 2, DEFAULT) {}

	/** Sets the value at ind to val. */
	void set(int ind, T val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind / 2] = std::min(segtree[ind], segtree[ind ^ 1]);
		}
	}

	/** @return the minimum element in the range [start, end) */
	T range_min(int start, int end) {
		T sum = DEFAULT;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { sum = std::min(sum, segtree[start++]); }
			if (end % 2 == 1) { sum = std::min(sum, segtree[--end]); }
		}
		return sum;
	}
};

int main() {
	int arr_len;
	int query_num;
	std::cin >> arr_len >> query_num;

	MinSegmentTree<long long> segtree(arr_len);
	for (int i = 0; i < arr_len; i++) {
		int n;
		std::cin >> n;
		segtree.set(i, n);
	}

	for (int q = 0; q < query_num; q++) {
		int type, arg1, arg2;
		std::cin >> type >> arg1 >> arg2;
		if (type == 1) {
			segtree.set(arg1 - 1, arg2);
		} else if (type == 2) {
			cout << segtree.range_min(arg1 - 1, arg2) << '\n';
		}
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

/** A data structure that can answer point update & range minimum queries. */
public class MinSegmentTree {
	private final int[] segtree;
	private final int len;

	public MinSegmentTree(int len) {
		this.len = len;
		segtree = new int[len * 2];
		Arrays.fill(segtree, Integer.MAX_VALUE);
	}

	/** Sets the value at ind to val. */
	public void set(int ind, int val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind / 2] = Math.min(segtree[ind], segtree[ind ^ 1]);
		}
	}

	/** @return the minimum of all elements in [start, end). */
	public int rangeMin(int start, int end) {
		int min = Integer.MAX_VALUE;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { min = Math.min(min, segtree[start++]); }
			if (end % 2 == 1) { min = Math.min(min, segtree[--end]); }
		}
		return min;
	}

	public static void main(String[] args) {
		Kattio io = new Kattio();
		int arrLen = io.nextInt();
		int queryNum = io.nextInt();

		MinSegmentTree segtree = new MinSegmentTree(arrLen);
		for (int i = 0; i < arrLen; i++) { segtree.set(i, io.nextInt()); }

		for (int i = 0; i < queryNum; i++) {
			int type = io.nextInt();
			int arg1 = io.nextInt();
			int arg2 = io.nextInt();
			if (type == 1) {
				segtree.set(arg1 - 1, arg2);
			} else {
				io.println(segtree.rangeMin(arg1 - 1, arg2));
			}
		}

		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
class MinSegmentTree:
	"""A data structure that can answer point update & range minimum queries."""

	def __init__(self, len_: int):
		self.len = len_
		self.tree = [0] * (2 * len_)

	def set(self, ind: int, val: int) -> None:
		"""Sets the value at ind to val."""
		ind += self.len
		self.tree[ind] = val

		while ind > 1:
			self.tree[ind // 2] = min(self.tree[ind], self.tree[ind ^ 1])
			ind //= 2

	def range_min(self, start: int, end: int) -> int:
		""":return the minimum element of all elements in [start, end)"""
		start += self.len
		end += self.len
		min_ = float("inf")
		while start < end:
			if start % 2 == 1:
				min_ = min(min_, self.tree[start])
				start += 1
			if end % 2 == 1:
				end -= 1
				min_ = min(min_, self.tree[end])

			start //= 2
			end //= 2
		return min_


arr_len, query_num = map(int, input().split())
arr = list(map(int, input().split()))

segtree = MinSegmentTree(arr_len)
for i, v in enumerate(arr):
	segtree.set(i, v)

for _ in range(query_num):
	type_, arg1, arg2 = map(int, input().split())
	if type_ == 1:
		segtree.set(arg1 - 1, arg2)
	elif type_ == 2:
		print(segtree.range_min(arg1 - 1, arg2))
```

</PySection>
</LanguageSection>

### Solution - Dynamic Range Sum Queries

<LanguageSection>
<CPPSection>

Compared to the previous problem, all we need to change are `DEFAULT`
and how we combine the elements.

```cpp
#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::vector;

template <class T> class SumSegmentTree {
  private:
	const T DEFAULT = 0;

	vector<T> segtree;
	int len;

  public:
	SumSegmentTree(int len) : len(len), segtree(len * 2, DEFAULT) {}

	void set(int ind, T val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind / 2] = segtree[ind] + segtree[ind ^ 1];
		}
	}

	T range_sum(int start, int end) {
		T sum = DEFAULT;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { sum += segtree[start++]; }
			if (end % 2 == 1) { sum += segtree[--end]; }
		}
		return sum;
	}
};

int main() {
	int arr_len;
	int query_num;
	std::cin >> arr_len >> query_num;

	SumSegmentTree<long long> segtree(arr_len);
	for (int i = 0; i < arr_len; i++) {
		int n;
		std::cin >> n;
		segtree.set(i, n);
	}

	for (int q = 0; q < query_num; q++) {
		int type, arg1, arg2;
		std::cin >> type >> arg1 >> arg2;
		if (type == 1) {
			segtree.set(arg1 - 1, arg2);
		} else if (type == 2) {
			cout << segtree.range_sum(arg1 - 1, arg2) << '\n';
		}
	}
}
```

</CPPSection>
<JavaSection>

Compared to the previous problem, all we need to change is the way we aggregate
values (from `Math.min()` to summation) and the data type we use to store the
query (from `int` to `long`).

```java
import java.io.*;
import java.util.*;

public class SumSegmentTree {
	private final long[] segtree;
	private final int len;

	public SumSegmentTree(int len) {
		this.len = len;
		segtree = new long[len * 2];
		Arrays.fill(segtree, 0);
	}

	public void set(int ind, int val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind >> 1] = segtree[ind] + segtree[ind ^ 1];
		}
	}

	public long rangeSum(int start, int end) {
		long total = 0;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { total += segtree[start++]; }
			if (end % 2 == 1) { total += segtree[--end]; }
		}
		return total;
	}

	public static void main(String[] args) {
		Kattio io = new Kattio();
		int arrLen = io.nextInt();
		int queryNum = io.nextInt();

		SumSegmentTree segtree = new SumSegmentTree(arrLen);
		for (int i = 0; i < arrLen; i++) { segtree.set(i, io.nextInt()); }

		for (int i = 0; i < queryNum; i++) {
			int type = io.nextInt();
			int arg1 = io.nextInt();
			int arg2 = io.nextInt();
			if (type == 1) {
				segtree.set(arg1 - 1, arg2);
			} else {
				io.println(segtree.rangeSum(arg1 - 1, arg2));
			}
		}

		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

Compared to the previous problem, all we need to change is the way we aggregate
values (from `min()` to '+'), and change the initial value to 0.

```py
class SumSegmentTree:
	def __init__(self, len_: int):
		self.len = len_
		self.tree = [0] * (2 * len_)

	def set(self, ind: int, val: int) -> None:
		ind += self.len
		self.tree[ind] = val

		while ind > 1:
			self.tree[ind // 2] = self.tree[ind] + self.tree[ind ^ 1]
			ind //= 2

	def range_sum(self, start: int, end: int) -> int:
		start += self.len
		end += self.len
		total = 0
		while start < end:
			if start % 2 == 1:
				total += self.tree[start]
				start += 1
			if end % 2 == 1:
				end -= 1
				total += self.tree[end]

			start //= 2
			end //= 2
		return total


arr_len, query_num = map(int, input().split())
arr = list(map(int, input().split()))

segtree = SumSegmentTree(arr_len)
for i, v in enumerate(arr):
	segtree.set(i, v)

for _ in range(query_num):
	type_, arg1, arg2 = map(int, input().split())
	if type_ == 1:
		segtree.set(arg1 - 1, arg2)
	elif type_ == 2:
		print(segtree.range_sum(arg1 - 1, arg2))
```

</PySection>
</LanguageSection>

## Binary Indexed Tree

The implementation is shorter than segment tree, but maybe more confusing at
first glance.

### Resources

<Resources>
	<Resource source="CSA" title="Fenwick Trees" url="fenwick_trees" starred>
		interactive
	</Resource>
	<Resource source="CPH" title="9.2, 9.4 - Binary Indexed Tree" starred>
		similar to above
	</Resource>
	<Resource
		source="cp-algo"
		title="Fenwick Tree"
		url="data_structures/fenwick.html"
	>
		also similar to above
	</Resource>
	<Resource
		source="TC"
		title="Binary Indexed Trees"
		url="binary-indexed-trees"
	 />
</Resources>

### Solution - Dynamic Range Sum Queries (With a BIT)

<LanguageSection>
<CPPSection>

<Resources>
	<Resource
		source="CF"
		title="mouse_wireless - Multi-dimensional BITs with Templates"
		url="https://codeforces.com/blog/entry/64914"
	 />
	<Resource
		source="KACTL"
		title="FenwickTree"
		url="https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/FenwickTree.h"
	>
	</Resource>
</Resources>

#### Solution 1

```cpp
#include <cassert>
#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::vector;

/**
 * Short for "binary indexed tree",
 * this data structure supports point update and range sum
 * queries like a segment tree.
 */
template <class T> class BIT {
  private:
	int size;
	vector<T> bit;
	vector<T> arr;

  public:
	BIT(int size) : size(size), bit(size + 1), arr(size) {}

	/** Sets the value at index ind to val. */
	void set(int ind, int val) { add(ind, val - arr[ind]); }

	/** Adds val to the element at index ind. */
	void add(int ind, int val) {
		arr[ind] += val;
		ind++;
		for (; ind <= size; ind += ind & -ind) { bit[ind] += val; }
	}

	/** @return The sum of all values in [0, ind]. */
	T pref_sum(int ind) {
		ind++;
		T total = 0;
		for (; ind > 0; ind -= ind & -ind) { total += bit[ind]; }
		return total;
	}
};

int main() {
	int arr_len;
	int query_num;
	std::cin >> arr_len >> query_num;

	BIT<long long> bit(arr_len);
	for (int i = 0; i < arr_len; i++) {
		int n;
		std::cin >> n;
		bit.set(i, n);
	}

	for (int q = 0; q < query_num; q++) {
		int type, arg1, arg2;
		std::cin >> type >> arg1 >> arg2;
		if (type == 1) {
			bit.set(arg1 - 1, arg2);
		} else if (type == 2) {
			cout << bit.pref_sum(arg2 - 1) - bit.pref_sum(arg1 - 2) << '\n';
		}
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

/**
 * Short for "binary indexed tree",
 * this data structure supports point update and range sum
 * queries like a segement tree.
 */
public class BIT {
	private final long[] bit;
	private final long[] arr;
	private final int len;

	public BIT(int len) {
		bit = new long[len + 1];
		arr = new long[len];
		this.len = len;
	}

	/** Sets the value of index ind at the actual array to vall. */
	public void set(int ind, long val) { add(ind, val - arr[ind]); }

	/** Adds val to the element at index ind. */
	public void add(int ind, long val) {
		arr[ind] += val;
		ind++;
		for (; ind <= len; ind += ind & -ind) { bit[ind] += val; }
	}

	/** @return The sum of all values in [0, ind]. */
	public long prefSum(int ind) {
		ind++;
		long sum = 0;
		for (; ind > 0; ind -= ind & -ind) { sum += bit[ind]; }
		return sum;
	}

	public static void main(String[] args) {
		Kattio io = new Kattio();
		int arrLen = io.nextInt();
		int queryNum = io.nextInt();

		BIT bit = new BIT(arrLen);
		for (int i = 0; i < arrLen; i++) { bit.set(i, io.nextInt()); }

		for (int i = 0; i < queryNum; i++) {
			int type = io.nextInt();
			int arg1 = io.nextInt();
			int arg2 = io.nextInt();
			if (type == 1) {
				bit.set(arg1 - 1, arg2);
			} else if (type == 2) {
				io.println(bit.prefSum(arg2 - 1) - bit.prefSum((arg1 - 1) - 1));
			}
		}

		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
class BIT:
	"""
	Short for "binary indexed tree",
	this data structure supports point update and range sum
	queries like a segment tree.
	"""

	def __init__(self, len_: int) -> None:
		self.bit = [0] * (len_ + 1)
		self.arr = [0] * len_
		self.len = len_

	def set(self, ind: int, val: int):
		"""Sets the value at ind to val"""
		self.add(ind, val - self.arr[ind])

	def add(self, ind: int, val: int):
		"""Adds val to the element at index ind."""
		self.arr[ind] += val
		ind += 1
		while ind <= self.len:
			self.bit[ind] += val
			ind += ind & -ind

	def pref_sum(self, ind: int):
		""":return The sum of all values in [0, ind]."""
		ind += 1
		sum_ = 0
		while ind > 0:
			sum_ += self.bit[ind]
			ind -= ind & -ind
		return sum_


arr_len, query_num = map(int, input().split())
arr = list(map(int, input().split()))

bit = BIT(arr_len)
for i, v in enumerate(arr):
	bit.add(i, v)

for _ in range(query_num):
	q_type, arg1, arg2 = map(int, input().split())
	if q_type == 1:
		bit.set(arg1 - 1, arg2)
	elif q_type == 2:
		print(bit.pref_sum(arg2 - 1) - bit.pref_sum(arg1 - 2))
```

</PySection>
</LanguageSection>

## Finding the $k$-th Element

Suppose that we want a data structure that supports all the operations as a
`set` in C++ in addition to the following:

- `order_of_key(x)`: counts the number of elements in the set that are strictly
  less than `x`.
- `find_by_order(k)`: similar to `find`, returns the iterator corresponding to
  the `k`-th lowest element in the set (0-indexed).

### Order Statistic Tree

Luckily, such a built-in data structure already exists in C++.

<Resources>
	<Resource
		source="CF"
		url="11080"
		title="adamant - Policy Based Data Structures"
		starred
	 />
	<Resource source="CPH" title="4.5 - Policy Based Data Structures">
		brief overview with find_by_order and order_of_key
	</Resource>
	<Resource
		source="KACTL"
		url="https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/OrderStatisticTree.h"
		title="OrderStatisticTree"
	>
		code
	</Resource>
</Resources>

To use indexed sets locally, you need to
[install GCC](/general/cpp-command#installing-g).

### With a BIT

Assumes all updates are in the range $[1,N]$.

<Resources>
	<Resource source="CF" url="11275" title="adamant - About Ordered Set" starred>
		log N
	</Resource>
</Resources>

<!--   <Resource source="GFG" url="order-statistic-tree-using-fenwick-tree-bit" title="Order Statistic Tree using BIT"> log^2 N </Resource> -->

### With a Segment Tree

Covered in [Platinum](/plat/seg-ext).

## Example - Inversion Counting

<FocusProblem problem="inv" />

### Solution

<LanguageSection>
<CPPSection>

Using an indexed set, we can solve this in just a few lines.

```cpp
#include <bits/stdc++.h>
using namespace std;

#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template <class T>
using Tree =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		Tree<int> tree;

		int arr_len;
		cin >> arr_len;
		long long inv_num = 0;
		for (int i = 0; i < arr_len; i++) {
			int x;
			cin >> x;
			/*
			 * Calculate the # of elements in the tree
			 * that are greater than x.
			 * (.order_of_key(x) gives the # of elements less than x)
			 */
			inv_num += i - tree.order_of_key(x);
			tree.insert(x);
		}

		cout << inv_num << '\n';
	}
}
```

Note that if it were not the case that all elements of the input array were
distinct, then this code would be incorrect since `Tree<int>` would remove
duplicates. Instead, we would use an indexed set of pairs
(`Tree<pair<int,int>>`), where the first element of each pair would denote the
value while the second would denote the position of the value in the array.

</CPPSection>
<JavaSection>

Using a binary indexed tree, we can count the number of inversions.

```java
import java.io.*;
import java.util.*;

public class Main {
	public static void main(String[] args) {
		final int MAX_ELEM = (int)1e7;
		Kattio io = new Kattio();

		int testNum = io.nextInt();
		for (int t = 0; t < testNum; t++) {
			BIT bit = new BIT(MAX_ELEM + 1);

			int arrLen = io.nextInt();
			long invNum = 0;
			for (int i = 0; i < arrLen; i++) {
				int x = io.nextInt();
				bit.add(x, 1);
				invNum += bit.prefSum(MAX_ELEM) - bit.prefSum(x);
			}

			io.println(invNum);
		}

		io.close();
	}

	// CodeSnip{Kattio}
}

// BeginCodeSnip{BIT Code}
class BIT {
	private final long[] bit;
	private final int len;

	public BIT(int len) {
		bit = new long[len + 1];
		this.len = len;
	}

	public void add(int ind, long val) {
		ind++;
		for (; ind <= len; ind += ind & -ind) { bit[ind] += val; }
	}

	public long prefSum(int ind) {
		ind++;
		long sum = 0;
		for (; ind > 0; ind -= ind & -ind) { sum += bit[ind]; }
		return sum;
	}
}
// EndCodeSnip
```

</JavaSection>
<PySection>

```py
# BeginCodeSnip{BIT}
class BIT:
	def __init__(self, len_: int) -> None:
		self.bit = [0] * (len_ + 1)
		self.arr = [0] * len_
		self.len = len_

	def add(self, ind: int, val: int):
		self.arr[ind] += val
		ind += 1
		while ind <= self.len:
			self.bit[ind] += val
			ind += ind & -ind

	def pref_sum(self, ind: int):
		ind += 1
		sum_ = 0
		while ind > 0:
			sum_ += self.bit[ind]
			ind -= ind & -ind
		return sum_


# EndCodeSnip

MAX_ELEM = 10**7

test_num = int(input())
for _ in range(test_num):
	bit = BIT(MAX_ELEM + 1)

	input()
	arr_len = int(input())
	inv_num = 0
	for _ in range(arr_len):
		x = int(input())
		bit.add(x, 1)
		inv_num += bit.pref_sum(MAX_ELEM) - bit.pref_sum(x)

	print(inv_num)
```

</PySection>
</LanguageSection>

## Range Sum Problems

<Info title="Coordinate Compression">

If the coordinates are large (say, up to $10^9$), then you should apply
[coordinate compression](https://www.quora.com/What-is-coordinate-compression-and-what-is-it-used-for)
before using a BIT or segment tree (though
[sparse segment trees](/plat/sparse-seg) do exist).

</Info>

### General

<Problems problems="practice" />

### USACO

<!-- Haircut, Balanced Photo, and Circle Cross are just variations on inversion counting. -->

<Problems problems="usaco" />

A hint regarding Sleepy Cow Sort: There is only one correct output.
