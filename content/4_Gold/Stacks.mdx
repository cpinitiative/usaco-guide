---
id: stacks
title: Stacks
author: Darren Yao, Michael Cao
contributors: George Pong
description:
  'A data structure that only allows insertion and deletion at one end.'
prerequisites:
  - intro-ds
frequency: 1
---

<Resources>
	<Resource source="CPH" title="4.5 - Stacks">
		brief description of operations
	</Resource>
	<Resource
		source="CSA"
		title="Stack Introduction"
		url="stack_introduction"
		starred
	>
		Bracket Matching Application
	</Resource>
</Resources>

<!-- <Resource source="PAPS" title="3.3, 6.2 - Stacks" />
	<Resource
		source="CP2"
		title="2.2 - Data Structures with Built-in Libraries"
	 />
-->

## Stacks

A stack is a **Last In First Out** (LIFO) data structure that supports three
operations, all in $\mathcal{O}(1)$ time. Think of it like a real-world stack of
papers.

<LanguageSection>

<CPPSection>

### [C++](http://www.cplusplus.com/reference/stack/stack/)

- `push`: adds an element to the top of the stack
- `pop`: removes an element from the top of the stack
- `top`: retrieves the element at the top without removing it

```cpp
stack<int> s;
s.push(1);                 // [1]
s.push(13);                // [1, 13]
s.push(7);                 // [1, 13, 7]
cout << s.top() << endl;   // 7
s.pop();                   // [1, 13]
cout << s.size() << endl;  // 2
```

</CPPSection>

<JavaSection>

### Java

- `push`: adds an element to the top of the stack
- `pop`: removes an element from the top of the stack
- `peek`: retrieves the element at the top without removing it

```java
Stack<Integer> s = new Stack<Integer>();
s.push(1);                     // [1]
s.push(13);                    // [1, 13]
s.push(7);                     // [1, 13, 7]
System.out.println(s.peek());  // 7
s.pop();                       // [1, 13]
System.out.println(s.size());  // 2
```

</JavaSection>

<PySection>

### Python

Python does not have a built-in stack type, but a list can function
like a stack.

- `list.append()`: Appends an element to the end.
- `list[-1]`: Retrieves the last element without removing it.
- `list.pop()`: Removes the last element and returns it
  (but you don't need to use the returned value).
- `list.pop(n)`: Removes the nth element, 0-indexed. Note that removing
  elements is an `O(n)` operation.

```py
stack = []  # []
stack.append(1)  # [1]
stack.append(2)  # [1, 2]
stack.append(3)  # [1, 2, 3]
v = stack[-1]  # stack = [1, 2, 3] (unchanged), v = 3
stack.pop()  # [1, 2]
v = stack.pop()  # stack = [1], v = 2
stack.append(4)  # [1, 4]
v = stack.pop(0)  # stack = [4], v = 1
```

</PySection>

</LanguageSection>

## Application - Nearest Smaller Element

<FocusProblem problem="nearest" />

Consider the following problem:

> Given an array, $a$, of $N$ ($1 \le N \le 10^5$) integers, for every index
> $i$, find the rightmost index $j$ such that $j < i$ and $a_i > a_j$.

<Resources>
	<Resource
		source="CPH"
		title="8.2 - Nearest Smaller Element"
		starred
	 />
	<Resource
		source="CSA"
		title="Stack Application - Soldier's Row"
		url="stack_application_soldiers_row"
		starred
	>
		similar application w/ animation
	</Resource>
</Resources>

<!-- 	<Resource
		source="Medium"
		title="Monotonic Stack"
		url="https://medium.com/@vishnuvardhan623/monotonic-stack-e9dcc4fa8c3e"
	 /> -->

To solve this, let's store a stack of pairs of $value, index$ and iterate over
the array from left to right. For some index $i$, we will compute
$\texttt{ans}[i]$, the rightmost index for $i$, as follows:

- Keep popping the top element off the stack as long as $value \ge a_i$. This is
  because we know that the pair containing $value$ will never be the solution to
  any index $j > i$, since $a_i$ is less than or equal to than $value$ and has
  an index further to the right.
- If $value < a_i$, set $\texttt{ans}[i]$ to $index$, because a stack stores the
  most recently added values first (or in this case, the rightmost ones),
  $index$ will contain the rightmost value which is less than $a_i$. Then, add
  ($a_i, i$) to the stack.

The stack we used is called a **monotonic stack** because we keep popping off
the top element of the stack which maintains it's monotonicity (the same
property needed for algorithms like binary search) because the elements in the
stack are increasing.

### Implementation

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

int N;

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	cin >> N;
	stack<pair<int, int>> stack;
	stack.push({0, 0});

	for (int i = 1; i <= N; ++i) {
		int a;
		cin >> a;
		while (!stack.empty() && stack.top().first >= a) stack.pop();
		cout << stack.top().second << " ";
		stack.push({a, i});
	}
}
```

</CPPSection>

<JavaSection>

```java

/**
 * author: Kai Wang
 */

import java.io.*;
import java.util.*;
public class NearestSmallestVals {

	/**
	 * We keep a stack of pairs (ind, value)
	 * Traverse the array from left to right, use ans to store answers
	 * If the value of the a_i> (stk.peek()=a_k) then I remove the top of the
	 * stack. This is okay because for all j>k, a_j>=a_k, or (j,a_j) is in the
	 * stack If a_k < a_i then we set ans[i]=k and insert (i,a_i) Note the stack
	 * elements are sorted in order of index
	 *
	 */
	public static void main(String[] args) throws IOException {
		BufferedReader br =
		    new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int[] a = new int[N + 1];
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 1; i <= N; i++) {
			a[i] = Integer.parseInt(st.nextToken());
		}
		Stack<Integer> stk = new Stack<>();
		stk.add(0);
		stk.add(1);
		int[] ans = new int[N + 1];
		ans[1] = 0;
		for (int i = 2; i <= N; i++) {
			while (a[stk.peek()] >= a[i]) { stk.pop(); }
			// stk.peek()<a[i]
			// This exists because a[0]=0 and a[i]>0 for all i>0
			ans[i] = stk.peek();
			stk.push(i);
		}
		for (int i = 1; i <= N; i++) { System.out.print(ans[i] + " "); }
	}
}
```

</JavaSection>

<PySection>

```py
n = int(input())
nums = list(map(int, input().split()))

ans = []
stack = []  # stores (a_i, i)
for idx, num in enumerate(nums):
	while stack and stack[-1][0] >= num:
		stack.pop()

	ans.append(0 if not stack else stack[-1][1] + 1)
	stack.append((num, idx))

print(*ans)
```

</PySection>

</LanguageSection>

## Problems

<Problems problems="general" />

<!--

(actually go through these and check ...)

### Stack

  - UVa 00514 - Rails
  - UVa 00732 - Anagram by Stack
  - UVa 01062 - Containers

### Queue / Deque

  - UVa 10172 - The Lonesome Cargo
  - UVa 10901 - Ferry Loading III
  - UVa 11034 - Ferry Loading IV
 -->

## Quiz

<Quiz>
	<Quiz.Question>
		What is the output of the following code?
		<LanguageSection>

	`	<CPPSection>

		```cpp
		stack<int> s;
		s.push(9);
		s.push(5);
		s.pop();
		s.push(8);
		s.pop();
		s.push(7);
		s.push(3);
		s.push(9);
		s.push(8);
		s.pop();
		cout << s.top() << endl;   
		s.pop();                   
		cout << s.size() << endl;  
		```

		</CPPSection>

		</LanguageSection>
		<Quiz.Answer correct>
			Add the current node to the list, and then run DFS on all child nodes of the current node from left to right.
			<Quiz.Explanation>
				Correct! Adding the current node first is preorder traversal. Adding it between the two child nodes is inorder, and adding it after the two child nodes is postorder.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			Run DFS on the left node, add the current node to the list, and then run DFS on the right node.
			<Quiz.Explanation>
				Incorrect. This is inorder traversal.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			Run DFS on the right node, add the current node to the list, and then run DFS on the left node.
			<Quiz.Explanation>
				Incorrect. This is neither preorder, inorder, or postorder traversal.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			Run DFS on all child nodes of the current node from left to right, then add the current node to the list.
			<Quiz.Explanation>
				Incorrect. This is postorder traversal.
			</Quiz.Explanation>
		</Quiz.Answer>
	</Quiz.Question>
	<Quiz.Question>
		What is the diameter of a tree?
		<Quiz.Answer>
			The length of the longest path from root to leaf node
			<Quiz.Explanation>
				False. The diameter of a tree is the maximum distance between two nodes, which usually isn't the longest distance between the root and the leaf. The only exception is if the root is a leaf along the longest path of a tree.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			The length of the longest path that exists in the tree
			<Quiz.Explanation>
				This statement is true, but 3 is also true.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			The length of the longest path from two leaf nodes
			<Quiz.Explanation>
				This statement is true, but 2 is also true.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer correct>
			Both 2 and 3
			<Quiz.Explanation>
				Correct! The diameter is the longest path between two nodes in a tree, but the longest path must be a path between two leaf nodes. If we have a path between two nodes that are not leaves, it can't be the longest because we can extend our path further down the tree in either direction.
			</Quiz.Explanation>
		</Quiz.Answer>
	</Quiz.Question>
	<Quiz.Question>
		What would be a valid function header for DFS on an undirected tree to work in linear time *without* any other variables?
		<Quiz.Answer correct>
			`void dfs(int v, int p, vector<vector<int>>& adj)`
			<Quiz.Explanation>
				Correct! For a tree, we do not need a visited array. We only need to check if we are revisiting the parent node, so `v` as a current node and `p` as a parent node would work.

				Calling `adj` as a `vector<vector<int>>&` instead of just `vector<vector<int>>` ensures that the reference (instead of the entire list) is copied over each time, which takes constant instead of linear time. Therefore, the entire DFS would take linear time.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			`void dfs(int v, int p, vector<vector<int>> adj)`
			<Quiz.Explanation>
				Incorrect. This would not work in linear time because `adj` would be copied in $O(n)$ time every time DFS is called. As DFS is called $n$ times, this runs in $O(n^2)$.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			`void dfs(int v, vector<vector<int>> adj)`
			<Quiz.Explanation>
				Incorrect. This DFS function cannot check for a parent node, and therefore would never terminate.
			</Quiz.Explanation>
		</Quiz.Answer>
		<Quiz.Answer>
			`void dfs(vector<vector<int>>& adj)`
			<Quiz.Explanation>
				Incorrect. This DFS function cannot track the current node, therefore it cannot even run.
			</Quiz.Explanation>
		</Quiz.Answer>
	</Quiz.Question>
</Quiz>



