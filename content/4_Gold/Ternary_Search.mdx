---
id: ternary-search
title: Ternary Search
author: Chongtian Ma
prerequisites:
  - /silver/binary-search
description: Searching for a peak in a unimodal function.
frequency: 1
---
<Resources>
	<Resource
		source="CP-Algorithms"
		title="Ternary Search"
		url="https://cp-algorithms.com/num_methods/ternary_search.html"
		starred
	/>
</Resources>

In calculus terms, ternary search is the equivalent of binary searching for the zero on the
derivative function. The most basic function can be represented by the standard
form of a parabola: $ax^2+bx+c$. Depending on if $a$ is positive or negative,
you are searching for the local minimum or maximum of the function,
respectively. Note that the function must be unimodal (see the cp-algorithms resource for a definition)!

Unlike binary search where a checking function $f(x)$ only needs to return true
or false, we need $f(x)$ to output a real number. Between the bounds of $[l, r]$,
we need to compare the integer output of $f(m_1)$ with $f(m_2)$ where
$l < m_1 < m_2 < r$ to determine how $l$ and $r$ should be moved.

For example, if the function has a local maximum between $[l, r]$ and
$f(m_1) < f(m_2)$, then we know the local maximum cannot be between $[l, m_1]$,
so we continue searching in $[m_1, r]$. For a mini-proof, consider the following
cases:

- Let's denote the local maximum as $g$. If $m_1$ and $m_2$ are less than $g$,
  this means that $f(m_1)$ and $f(m_2)$ are both on the increasing side of the
  function. Therefore, we know $m_2 < g < r$, so we must keep searching between
  $[m_2, r]$.

- If $m_1 < g$ and $m_2 > g$, then $m_1 < g < m_2$. Therefore, we must keep
  searching betwen $[m_1, m_2]$.

- Note that $g < m_1 < m_2$ can never happen, becuase the function had to be
  strictly decreasing after $g$.

Since $[m_1, m_2] \cup [m_2, r] = [m_1, r]$, we cover all cases if we set $l$ to
$m_1$. A similar proof can be given for $f(m_1) \geq f(m_2)$ or if we are
searching for a local minimum.

It is usually optimal to set $m_1$ and $m_2$ in a way so that we can maximize the amount of distance we eliminate per
search. If we are working with integers, we can set $m_1 = \lfloor \frac{l+r}{2} \rfloor$ and $m_2 = m_1 + 1$.

# Sample Problem - Haybale Distribution

<FocusProblem problem="sample" />

## Solution - Haybale Distribution

### Explanation

Consider the function $f(y)$, which returns the number of haybales wasted if $y$
is the chosen integer point. The problem asks for the local minimum for $f(y)$
in the range of integers $[0, 10^6]$. It can be shown the function is unimodal
because:

- If we assume $y'$ is the optimal value of $y$ (i.e. the local minimum), there are two integers $a$ and $b$ such that $1 \leq a \leq y' \leq b \leq 10^6$ and $f(x)$ is strictly decreasing in the interval $[1, a]$, flat in the interval $[a, b]$, and strictly increasing in the interval $[b, 10^6]$. In simpler terms, as you slide $x$ away from $y'$, you are pulling away from the optimal value.

Therefore, we can run a ternary search to find the local minimum. If
$f(m_1) < f(m_2)$, then we can move the search range to $[l, m_2]$, otherwise,
our search range is $[m_1, r]$.

All that's left is computing $f(y)$. Let's sort the haybales first. We can
obtain the greatest $i$ such that $x_i < f(y)$ using binary search. Then, we can
obtain the sum of the piecewise function for haybales in the range $[1, i]$ and
$[i+1, n]$ separately, using $a$ and $b$ respectively. This can be done with
prefix sums. For more details, refer to the implementation.

### Implementation

Time Complexity: $\mathcal{O}(N \log Y)$ where $Y$ is the maximum value for $y$.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int Y = 1e6;

int main() {
	int n;
	cin >> n;
	vector<ll> a(n);
	for (int i = 0; i < n; i++) { cin >> a[i]; }
	sort(a.begin(), a.end());

	vector<ll> cum(n + 1);  // cumulative sums for a
	for (int i = 1; i <= n; i++) { cum[i] = a[i - 1] + cum[i - 1]; }

	int query_num;
	cin >> query_num;
	for (int q = 0; q < query_num; q++) {
		ll left, right;
		cin >> left >> right;

		auto f = [&](ll x) -> ll {
			int low_idx = lower_bound(a.begin(), a.end(), x) - a.begin() - 1;
			ll left_cost = (ll)(low_idx + 1) * x - cum[low_idx + 1];

			int high_idx = low_idx + 1;
			ll right_cost =
			    (ll)(cum[n] - cum[high_idx]) - (ll)(n - high_idx) * x;

			return left * left_cost + right * right_cost;
		};

		ll l = 0, r = Y;
		while (r - l > 3) {
			ll mid1 = l + (r - l) / 3;
			ll mid2 = r - (r - l) / 3;
			if (f(mid1) > f(mid2)) {
				l = mid1;
			} else {
				r = mid2;
			}
		}

		ll ans = INT64_MAX;
		for (int i = l; i <= r; i++) { ans = min(ans, f(i)); }
		cout << ans << '\n';
	}
}
```

</CPPSection>

</LanguageSection>

<Problems problems="probs" />

<Optional title="Multidimensional Ternary Search">
See this [blog](https://codeforces.com/blog/entry/98524).
</Optional>
