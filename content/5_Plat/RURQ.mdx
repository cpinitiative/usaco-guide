---
id: RURQ
title: 'Range Update Range Query'
author: Benjamin Qi
prerequisites:
  - PURS
description: Lazy updates on segment trees and two binary indexed trees in conjunction.
frequency: 1
---



export const problems = {
	bitSample: [
		new Problem(
			'SPOJ',
			'Horrible Queries',
			'HORRIBLE',
			'Easy',
			false,
			['1DRQ'],
			''
		),
	],
	bitProb: [
		new Problem(
			'CSES',
			'Polynomial Queries',
			'1736',
			'Easy',
			false,
			['1DRQ'],
			'equivalent to https://dmoj.ca/problem/acc3p4'
		),
		new Problem(
			'Baltic OI',
			'2011 - Growing Trees',
			'https://oj.uz/problem/view/BOI11_grow',
			'Normal',
			false,
			['1DRQ', 'Binary search'],
			''
		),
		new Problem(
			'IOI',
			'2007 - Sails',
			'http://oj.uz/problem/view/IOI07_sails',
			'Normal',
			true,
			['1DRQ', 'Binary search'],
			''
		),
	],
	lazySample: [
		new Problem(
			'CSES',
			'Range Updates & Sums',
			'1735',
			'Easy',
			false,
			['Lazy SegTree'],
			''
		),
	],
	lazySegTree: [
		new Problem(
			'YS',
			'Range Affine Range Sum',
			'range_affine_range_sum',
			'Easy',
			false,
			['Lazy SegTree'],
			''
		),
		new Problem(
			'Plat',
			'Counting Haybales',
			'578',
			'Easy',
			false,
			['Lazy SegTree'],
			''
		),
		new Problem(
			'Old Gold',
			'The Lazy Cow',
			'418',
			'Easy',
			false,
			['Lazy SegTree'],
			''
		),
		new Problem(
			'CSES',
			'Prefix Sum Queries',
			'2166',
			'Normal',
			false,
			[],
			'cses-2166'
		),
		new Problem(
			'IOI',
			'2014 - Wall',
			'https://oj.uz/problem/view/IOI14_wall',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2005 - Mountain',
			'https://dmoj.ca/problem/ioi05p3',
			'Normal',
			false,
			[],
			'https://ioinformatics.org/files/ioi2005solutions.pdf'
		),
		new Problem(
			'Plat',
			'Snow-Cow',
			'973',
			'Normal',
			false,
			['Lazy SegTree'],
			'Can use lazy seg in place of two BITs'
		),
		new Problem(
			'JOI',
			'2018 - Bubble Sort 2',
			'JOI18_bubblesort2',
			'Very Hard',
			false,
			['Lazy SegTree'],
			'http://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2018/2018-open-bubblesort2-sol-en.pdf'
		),
		new Problem(
			'DMOJ',
			'Victor Identifies Software',
			'dmopc20c1p6',
			'Very Hard',
			false,
			['Lazy SegTree'],
		)
	],
};

## BIT Revisited

<FocusProblem problem={problems.bitSample[0]} />

Binary Indexed Trees can support range increments in addition to range sum queries.

<Resources>
	<Resource
		source="GFG"
		title="Range Update Point Query"
		url="binary-indexed-tree-range-updates-point-queries/"
	></Resource>
	<Resource
		source="GFG"
		title="Range Update Range Query"
		url="binary-indexed-tree-range-update-range-queries/"
	></Resource>
	<Resource
		source="bmerry"
		title="Interval Trees"
		url="https://saco-evaluator.org.za/presentations/camp2_2014/interval-trees.pdf#page=36"
		starred
	></Resource>
</Resources>

### Implementation

<Resources>
	<Resource
		source="Benq"
		title="BITrange"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/data-structures/1D%20Range%20Queries%20(9.2)/BITrange.h"
	>
		{' '}
	</Resource>
</Resources>

<IncompleteSection />

### Problems

<Problems problems={problems.bitProb} />

## Lazy Segment Tree

<FocusProblem problem={problems.lazySample[0]} />

### Tutorial

<Resources>
	<Resource source="CF" title="EDU: Segment Tree Pt 2" url="https://codeforces.com/edu/course/2/lesson/5" starred>
	</Resource>
	<Resource source="CPH" title="28.1 - Segment Trees Revisited" starred>
		short description
	</Resource>
	<Resource source="CSA" title="Segment Trees" url="segment_trees" starred>
		interactive
	</Resource>
	<Resource
		source="cp-algo"
		title="Segment Tree"
		url="data_structures/segment_tree.html"
		starred
	>
		adding on segments, assigning
	</Resource>
	<Resource source="CF" title="Efficient and easy segment trees" url="18051">
		code is more confusing than recursive version
	</Resource>
</Resources>

### Implementation

Implementation of segment tree with lazy propagation (also implicit segment tree). 

```cpp
struct segtree_node {
	segtree_node* left_child, * right_child;
	int left_bound, right_bound;
	ll sum;
	ll lazy;

	void update(ll val) {
		sum += ((ll)right_bound - left_bound + 1) * val;
		lazy += val;
	}
	void merge() {
		sum = 0;
		if (left_child != NULL) {
			sum += left_child->sum;
		}
		if (right_child != NULL) {
			sum += right_child->sum;
		}
	}
	void prop() {
		if (lazy == 0) return;
		if (left_child != NULL) {
			left_child->update(lazy);
		}
		if (right_child != NULL) {
			right_child->update(lazy);
		}
		lazy = 0;
	}

	void update(int left, int right, ll val) {
		prop();
		if (left_bound >= left && right_bound <= right) {
			update(val);
			return;
		}
		int mid = left_bound + (right_bound - left_bound) / 2;
		if (left <= mid) {
			if (left_child == NULL) {
				left_child = new segtree_node(left_bound, mid);
			}
			left_child->update(left, right, val);
		}
		if (right > mid) {
			if (right_child == NULL) {
				right_child = new segtree_node(mid + 1, right_bound);
			}
			right_child->update(left, right, val);
		}
		merge();
	}
	ll query(int left, int right) {
		prop();
		if (left_bound >= left && right_bound <= right) {
			return sum;
		}
		int mid = left_bound + (right_bound - left_bound) / 2;
		ll res = 0;
		if (left <= mid) {
			if (left_child == NULL) {
				left_child = new segtree_node(left_bound, mid);
			}
			res += left_child->query(left, right);
		}
		if (right > mid) {
			if (right_child == NULL) {
				right_child = new segtree_node(mid + 1, right_bound);
			}
			res += right_child->query(left, right);
		}
		return res;
	}

	segtree_node() {
		left_child = right_child = NULL;
		left_bound = right_bound = -1;
		sum = 0; lazy = 0;
	}
	segtree_node(int left, int right) {
		left_child = right_child = NULL;
		left_bound = left; right_bound = right;
		sum = 0; lazy = 0;
	}
};
```

<IncompleteSection />

### Problems

<Problems problems={problems.lazySegTree} />
