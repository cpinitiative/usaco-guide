---
id: centroid
title: 'Centroid Decomposition'
author: Siyong Huang, Benjamin Qi
prerequisites:
  - intro-tree
description: 'Decomposing a tree to facilitate path computations.'
frequency: 1
---

<!--

TODO:
 - Add more resources

-->

## Introduction

### Centroids

A **centroid** of a tree is defined as a node such that when the tree is rooted
at it, no other nodes have a subtree of size greater than $\frac{N}{2}$.

<FocusProblem problem="sam" />

We can find a centroid in a tree by starting at the root. Each step, loop
through all of its children. If all of its children have subtree size less than
or equal to $\frac{N}{2}$, then it is a centroid. Otherwise, move to the child
with a subtree size that is more than $\frac{N}{2}$ and repeat until you find a
centroid.

<LanguageSection>

<CPPSection>

### Implementation

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int maxn = 200010;

int n;
vector <int> adj[maxn];
int subtree_size[maxn];

int get_subtree_size(int node, int par = -1) {
	int& res = subtree_size[node];
	res = 1;
	for (int i : adj[node]) {
		if (i == par) continue;
		res += get_subtree_size(i, node);
	}
	return res;
}

int get_centroid(int node, int par = -1) {
	for (int i : adj[node]) {
		if (i == par) continue;

		if (subtree_size[i] * 2 > n) {
			return get_centroid(i, node);
		}
	}
	return node;
}

int main() {
	cin >> n;
	for (int i = 0; i < n - 1; i++) {
		int a, b;
		cin >> a >> b;
		a--; b--;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

	get_subtree_size(0);
	cout << get_centroid(0) + 1 << endl;
}
```

</CPPSection>

</LanguageSection>

### Centroid decomposition

<FocusProblem problem="sam2" />

**Centroid Decomposition** is a divide and conquer technique for trees.
**Centroid Decomposition** works by repeated splitting the tree and each of the
resulting subgraphs at the centroid, producing $\mathcal{O}(\log N)$ layers of
subgraphs.

<Resources>
	<Resource
		source="Carpanese"
		title="Illustrated Intro to Centroid Decomposition"
		url="https://medium.com/carpanese/an-illustrated-introduction-to-centroid-decomposition-8c1989d53308"
		starred
	>
		how to solve above problem
	</Resource>
	<Resource
		source="CF"
		title="galen_colin - Centroid Decomposition"
		url="https://codeforces.com/blog/entry/81661"
	>
		blog + video for above problem. LCA isn't necessary though.
	</Resource>
	<Resource
		source="GFG"
		title="Centroid Decomposition of Tree"
		url="centroid-decomposition-of-tree"
	></Resource>
</Resources>

## Implementation

General centroid code is shown below.

<IncompleteSection>

Ben - this is not easy to understand :/

</IncompleteSection>

<LanguageSection>

<CPPSection>

<!-- pulled from https://codeforces.com/contest/1303/submission/76216413, which I think is my most recent centroid problem -->

```cpp
bool r[MN];//removed
int s[MN];//subtree size
int dfs(int n, int p = 0)
{
	s[n] = 1;
	for(int x : a[n])
		if(x != p && !r[x])
			s[n] += dfs(x, n);
	return s[n];
}
int get_centroid(int n, int ms, int p = 0)//n = node, ms = size of tree, p = parent
{
	for(int x : a[n])
		if(x != p && !r[x])
			if(s[x]*2 > ms)
				return get_centroid(x, ms, n);
	return n;
}
void centroid(int n = 1)
{
	int C = get_centroid(n, dfs(n));

	//do something

	r[C] = 1;
	for(int x : a[C])
		if(!r[x])
			centroid(x);
}
```

</CPPSection>

<JavaSection>

<!-- I used the code on a successful submission to "Xenia and Tree" https://codeforces.com/contest/342/submission/113088188 -->

```java
private static class Centroid {
	int n;
	int[][] g;
	int[] size;
	int[] parent;
	boolean[] seen;

	Centroid(int n, int[][] g) {
		this.n = n;
		this.g = g;
		size = new int[n];
		parent = new int[n];
		seen = new boolean[n];
		initCentroid(0, -1);
	}

	private int getSize(int u, int v) {
		if (seen[u]) {
			return 0;
		}
		size[u] = 1;
		for (int next : g[u]) {
			if (next != v) {
				size[u] += getSize(next, u);
			}
		}
		return size[u];
	}

	private void initCentroid(int u, int v) {
		getSize(u, v);
		final int c = findCentroid(u, -1, size[u]);
		seen[c] = true;
		parent[c] = v;
		for (int next : g[c]) {
			if (!seen[next]) {
				initCentroid(next, c);
			}
		}
	}

	private int findCentroid(int u, int v, int currSize) {
		for (int x : g[u]) {
			if (x != v) {
				if (!seen[x] && size[x] > currSize / 2) {
					return findCentroid(x, u, currSize);
				}
			}
		}
		return u;
	}
}
```

</JavaSection>

</LanguageSection>

## Solution - Xenia & Tree

<!-- code from https://codeforces.com/contest/342/submission/114241456 (with a couple of minor modifications) -->

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
 
const int inf = 2000000011;
#define PB push_back
 
int N, Q, W[100005], P[100005], ans[100005];
vector<int> adj[100005];
bool col[100005];

// W[] is weight(size) of subtree (excluding deleted nodes)
// P[] is parent in centroid tree
// ans[] is closest red node in subtree of centroid tree
// adj[] stores original tree given in input
// col[] stores if node has already been colored red (optional)
 
bool r[100005];
// r[] stores if a node has been deleted
 
int dfs_w(int u, int p = 0) {
	if (r[u])
		return 0;
	W[u] = 1;
	for (int v : adj[u])
		if (v != p && !r[v])
			W[u] += dfs_w(v, u);
	return W[u];
}
 
int centroid(int u, int n, int p = 0) {
	for (int v : adj[u])
		if (v != p && !r[v])
			if (W[v] * 2 > n) 
				return centroid(v, n, u);
	return u;
}
 
void build(int u = 1, int p = 0) {
	int c = centroid(u, dfs_w(u));
	P[c] = p;
	r[c] = 1;
	for (int v : adj[c])
		if (!r[v]) 
			build(v, c);
}
 
// this stuff is for tree distance, see binary jumping mondule
int dep[100005], anc[100005][18];
// dep[] stores depth of node
// anc[][] stores id of kth ancestor
 
void dfs_d(int u, int p, int d) {
	dep[u] = d;
	anc[u][0] = p;
	for (int v : adj[u])
		if (v != p)
			dfs_d(v, u, d + 1);
}
 
void init() {
	dfs_d(1, 1, 0);
	for (int k = 1; (1 << k) <= N; k++)
		for (int i = 1; i <= N; i++)
			anc[i][k] = anc[anc[i][k - 1]][k - 1];
}
 
int lca(int u, int v) {
	if (dep[u] > dep[v])
		swap(u, v);
	for (int i = 17; i >= 0; i--)
		if (dep[v] - (1 << i) >= dep[u]) 
			v = anc[v][i];
 
	if (u == v)
		return u;
	for (int i = 17; i >= 0; i--) 
		if (anc[u][i] != anc[v][i]) {
			u = anc[u][i];
			v = anc[v][i];
		}
	return anc[u][0];	
}
 
inline int dist(int u, int v) {
	int l = lca(u, v);
	return dep[u] + dep[v] - dep[l] - dep[l];
}

// update all ancestors 
void update(int u) {
	if (col[u])
		return;
	col[u] = 1;
	for (int v = u; v; v = P[v])
		ans[v] = min(ans[v], dist(u, v));
}
 
 // query all ancestors
int query(int u) {
	int res = inf;
	for (int v = u; v != P[v]; v = P[v]) 
		res = min(res, ans[v] + dist(u, v));
	return res;
}
 
int main(void) {
	ios_base::sync_with_stdio(0); cin.tie(0);
 
	cin >> N >> Q;
	for (int i = 1; i <= N; i++)
		ans[i] = inf;
	for (int i = 1, a, b; i < N; i++) {
		cin >> a >> b;
		adj[a].PB(b);
		adj[b].PB(a);
	}  
 
	init();
	build();
	
	update(1);
	for (int t, u; Q--;) {
		cin >> t >> u;
		if (t == 1)
			update(u);
		else if (t == 2)
			cout << query(u) << '\n';
	}
}
```

## Problems

<!-- Note: Unfortunately, it seems like constant factor is especially important for DMOJ.  -->

<Problems problems="general" />
