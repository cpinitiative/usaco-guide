---
id: hld
title: 'Heavy-Light Decomposition'
author: Benjamin Qi, Andrew Cheng, Jack Lim
prerequisites:
  - tree-euler
  - RURQ
description: Path and subtree updates and queries.
frequency: 1
---

Suppose that you want to support the following operations on a tree:

- Update all nodes along the path from node $x$ to node $y$.

- Find the sum, maximum, minimum (or any other operation that satisfies the
  associative property) along the path from node $x$ to node $y$.

Heavy Light Decomposition (or HLD) supports both operations efficiently.


<Resources>
	<Resource
		source="cp-algo"
		title="HLD"
		url="https://cp-algorithms.com/graph/hld.html"
		starred
	>
		For an alternate implementation, see below
	</Resource>
	<Resource
		source="CF"
		title="galen_colin - HLD"
		url="https://codeforces.com/blog/entry/81317"
	>
		blog + video for USACO Cowland. Binary jumping isn't necessary though.
	</Resource>
</Resources>

<Optional title="Tree Queries in O(NQ)">

[This](https://codeforces.com/blog/entry/82211?#comment-691472) is why you don't
set problems where $\Theta(Q\sqrt N\log N)$ is intended ...

</Optional>


## Tutorial

### Definitions

- A **heavy child** of a node is the child with the largest subtree size rooted
  at the child.
- A **light child** of a node is any child that is not a **heavy child**.
- A **heavy edge** connects a node to its **heavy child**.
- A **light edge** connects a node to any of its **light children**.
- A **heavy path** is the path formed by a collection **heavy edges**.
- A **light path** is the path formed by a collection **light edges**.

### Properties

**Any path from node $x$ to node $y$ on the tree can pass through at most
  $\mathcal{O}(\log N)$ light edges.**

<Spoiler title="Proof">

Consider a path from node $x$ to node $y$, this path can be broken down into a
path from node $x$ to $LCA(x,y)$ and another path from node $y$ to $LCA(x,y)$.

$LCA(x,y)$ must be an ancestor of both $x$ and $y$ by definition. Hence now we
only need to prove that the path from any node to any of its ancestors can only
pass through $\mathcal{O}(\log N)$ light edges to prove the property above.

Suppose that a light edge connects node $x$ and node $y$, where $y$ is a child
of $x$. By the definition of light edge, $y$ must be a light child of $x$. This
means that there has to be another child of $x$ with a larger subtree size than
$y$, or else $y$ will become the heavy child of $x$. Hence the size of the
subtree rooted at $x$ must be at least two times of the size of the subtree
rooted at $y$.

Since the subtree size of a node can not exceed the total number
of nodes $N$, the doubling process can only happen at most $\mathcal{O}(\log N)$
times when traversing up from an arbitrary node to its parent along a light
edge. Given this, we now know that there could be at most $\mathcal{O}(\log N)$
light edges in both the path from $x$ to $LCA(x,y)$ and the path from $LCA(x,y)$
to $y$. Hence there are at most $\mathcal{O}(\log N + \log N)$ =
$\mathcal{O}(\log N)$ light edges in the path from an arbitrary node $x$ to an
arbitrary node $y$.

</Spoiler>

Since a heavy path can only be broken by a light edge (or else the edge will be a part of the heavy
path), we can know that there are at most $\mathcal{O}(\log N)$ heavy paths on
any path from an arbitrary node $x$ to an arbitrary node $y$.

In addition, by using segment trees (or any other RURQ data structure) we can
calculate the value of any consecutive interval on any heavy path in
$\mathcal{O}(\log N)$ time.

Since there are at most $\mathcal{O}(\log N)$ heavy paths and
$\mathcal{O}(\log N)$ light edges, computing the value on the path from node $x$
to node $y$ will take $\mathcal{O}(\log^2 N + \log N)$ = $\mathcal{O}(\log^2 N)$
time. We can answer $Q$ queries in $\mathcal{O}(Q \log^2 N)$ time.

Here's an animation of how the algorithm works:
<video width="960" height="720" controls>
	<source src="/animations/hld.mp4" type="video/mp4"/>
</video>



## Implementation

<Resources>
	<Resource
		source="CF"
		title="AI-Cash - HLD Implementation"
		url="22072"
		starred
	/>
	<Resource
		source="CF"
		title="adamant - Easiest HLD with subtree queries"
		url="53170"
		starred
	>
		not complete
	</Resource>
	<Resource
		source="Benq"
		title="Complete HLD Implementation"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Trees%20(10)/HLD%20(10.3).h"
		starred
	>
		complete implementation following the above two articles with minor
		modifications
	</Resource>
</Resources>

Below is an example implementation of Heavy Light Decomposition based on the resources above. See the solution below, as well as the solutions for [Subtrees & Paths](/problems/hr-subtrees--paths/solution) and [Query on a tree again!](/problems/spoj-query-on-a-tree-again/solution), for examples of how this implementation can be used.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

template <class T, bool VALS_IN_EDGES> class HLD {
  private:
	int N, R, tim = 0;  // n, root node, time
	vector<vector<int>> adj;
	vector<int> par, siz, depth, rt, pos;  // parent, size, depth, root, position arrays
	LazySegtree<T> segtree;                // Modify as needed

	/** Compute the size of each subtree and set parent-child relationship
	 * Subtree of node v corresponds to segment [ pos[v], pos[v] + sz[v] ) */
	void dfs_sz(int v) {
		if (par[v] != -1) adj[v].erase(find(adj[v].begin(), adj[v].end(), par[v]));
		for (int &u : adj[v]) {
			par[u] = v, depth[u] = depth[v] + 1;
			dfs_sz(u);
			siz[v] += siz[u];
			if (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);
		}
	}

	/** Assign positions for nodes
	  * Path from v to the last vertex in ascending heavy path
	    corresponds to [ pos[rt[v]], pos[v] ] */
	void dfs_hld(int v) {
		pos[v] = tim++;
		for (int u : adj[v]) {
			rt[u] = (u == adj[v][0] ? rt[v] : u);
			dfs_hld(u);
		}
	}

	/** process all heavy path and combine their results */
	template <class B> void process(int u, int v, B op) {
		for (; rt[u] != rt[v]; v = par[rt[v]]) {
			if (depth[rt[u]] > depth[rt[v]]) swap(u, v);
			op(pos[rt[v]], pos[v]);
		}
		if (depth[u] > depth[v]) swap(u, v);
		op(pos[u] + VALS_IN_EDGES, pos[v]);
	}

  public:
	HLD(vector<vector<int>> adj_, int _R)
	    : N(adj_.size()), R(_R), adj(adj_), par(N, -1), siz(N, 1), depth(N), rt(N),
	      pos(N), segtree(vector<ll>(N, 0ll))  // modify if need
	{
		rt[R] = R;
		dfs_sz(R);
		dfs_hld(R);
	}

	T query_path(int u, int v) {
		T res = 0;  // default value, modify depending on problem
		process(u, v, [&](int l, int r) {
			res = max(res, segtree.range_max(l, r));  // modify depending on problem
		});
		return res;
	}

	void modify_node(int u, T val) { segtree.set(pos[u], val); }

	void modify_subtree(int v, T val) {
		segtree.range_update(pos[v] + VALS_IN_EDGES, pos[v] + siz[v] - 1,
		                     Query{ADD, val});  // modify if need
	}
};
```

</CPPSection>
</LanguageSection>

## Path Queries II

<FocusProblem problem="sample" />

### Explanation

We can label each edge as either heavy or light, then use a segment tree to keep track of the maximum value in each heavy chain.

Now, to change the value at node $i$ to $x$, we can just update the value in the segment tree. To query the maximum value in the path from $a$ to $b$, we first find the [Lowest Common Ancestor](/gold/tree-euler#lca). We combine the path from $a$ to $lca(a,b)$ and the path from $b$ to $lca(a,b)$ to find our answer.

### Implementation

**Time Complexity:** $\mathcal{O}(\log^2N)$ per query

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Segment Tree}
/** A data structure that can answer point update & range max queries. */
template <class T> class MaxSegmentTree {
  private:
	// const T DEFAULT = std::numeric_limits<T>().max();
	const T DEFAULT = 0;

	int len;
	vector<T> segtree;

  public:
	MaxSegmentTree(int len) : len(len), segtree(len * 2, DEFAULT) {}

	void set(int ind, T val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind / 2] = std::max(segtree[ind], segtree[ind ^ 1]);
		}
	}

	T range_max(int start, int end) {
		T max = DEFAULT;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { max = std::max(max, segtree[start++]); }
			if (end % 2 == 1) { max = std::max(max, segtree[--end]); }
		}
		return max;
	}
};
// EndCodeSnip

// BeginCodeSnip{HLD}
template <class T, bool VALS_IN_EDGES> class HLD {
  private:
	int N, R, tim = 0;  // n, root node, time
	vector<vector<int>> adj;
	vector<int> par, siz, depth, rt, pos;  // parent, size, depth, root, position arrays
	MaxSegmentTree<T> segtree;             // Modify as needed

	/** Compute the size of each subtree and set parent-child relationship
	 * Subtree of node v corresponds to segment [ pos[v], pos[v] + sz[v] ) */
	void dfs_sz(int v) {
		if (par[v] != -1) adj[v].erase(find(adj[v].begin(), adj[v].end(), par[v]));
		for (int &u : adj[v]) {
			par[u] = v, depth[u] = depth[v] + 1;
			dfs_sz(u);
			siz[v] += siz[u];
			if (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);
		}
	}

	/** Assign positions for nodes
	  * Path from v to the last vertex in ascending heavy path
	    corresponds to [ pos[rt[v]], pos[v] ] */
	void dfs_hld(int v) {
		pos[v] = tim++;
		for (int u : adj[v]) {
			rt[u] = (u == adj[v][0] ? rt[v] : u);
			dfs_hld(u);
		}
	}

	/** process all heavy path and combine their results */
	template <class B> void process(int u, int v, B op) {
		for (; rt[u] != rt[v]; v = par[rt[v]]) {
			if (depth[rt[u]] > depth[rt[v]]) swap(u, v);
			op(pos[rt[v]], pos[v]);
		}
		if (depth[u] > depth[v]) swap(u, v);
		op(pos[u] + VALS_IN_EDGES, pos[v]);
	}

  public:
	HLD(vector<vector<int>> adj_, int _R)
	    : N(adj_.size()), R(_R), adj(adj_), par(N, -1), siz(N, 1), depth(N), rt(N),
	      pos(N), segtree(N)  // modify as needed
	{
		rt[R] = R;
		dfs_sz(R);
		dfs_hld(R);
	}

	T query_path(int u, int v) {
		T res = 0;  // default value, modify depending on problem
		process(u, v, [&](int l, int r) {
			res = max(res, segtree.range_max(l, r + 1));  // modify depending on problem
		});
		return res;
	}

	void modify_node(int u, T val) { segtree.set(pos[u], val); }
};
// EndCodeSnip

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int n, q;
	cin >> n >> q;
	vector<int> v(n);
	vector<vector<int>> adj(n);
	for (int i = 0; i < n; i++) { cin >> v[i]; }

	for (int i = 0; i < n - 1; i++) {
		int a, b;
		cin >> a >> b;
		--a, --b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

	HLD<int, 0> H(adj, 0);

	for (int i = 0; i < n; i++) { H.modify_node(i, v[i]); }

	while (q--) {
		int type, s, a, b, x;
		cin >> type;
		if (type == 1) {
			cin >> s >> x;
			--s;
			H.modify_node(s, x);
		} else if (type == 2) {
			cin >> a >> b;
			--a, --b;
			cout << H.query_path(a, b) << " ";
		}
	}
}
```

</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />

<Warning>

"Grass Planting" isn't submittable on the USACO website. Use
[this link](https://www.acmicpc.net/problem/5916) to submit.

</Warning>
