---
id: hld
title: 'Heavy-Light Decomposition'
author: Benjamin Qi, Andrew Cheng, Jack Lim, David Zhou
prerequisites:
  - tree-euler
  - RURQ
description: Path and subtree updates and queries.
frequency: 1
---

Suppose we want to support the following operations on a tree:

1.  Update all nodes along the path from node $x$ to node $y$.
2.  Query the sum, maximum, minimum, or any other operation that satisfies the associative property along the path from node $x$ to node $y$.

Heavy Light Decomposition (HLD) supports both of these operations efficiently. Naively performing these operations can be slow on large trees, but HLD decomposes the tree into paths to allow updates and queries in logarithmic time.

<Resources>
	<Resource
		source="cp-algo"
		title="HLD"
		url="https://cp-algorithms.com/graph/hld.html"
		starred
	>
		For an alternate implementation, see below
	</Resource>
	<Resource
		source="CF"
		title="galen_colin - HLD"
		url="https://codeforces.com/blog/entry/81317"
	>
		blog + video for USACO Cowland. Binary jumping isn't necessary though.
	</Resource>
</Resources>

<Optional title="Tree Queries in O(NQ)">

[This](https://codeforces.com/blog/entry/82211?#comment-691472) is why you don't
set problems where $\Theta(Q\sqrt N\log N)$ is intended ...

</Optional>


## Tutorial

### Definitions

- A **heavy child** of a node is the child with the largest subtree size rooted
  at the child.
- A **light child** of a node is any child that is not the **heavy child**.
- A **heavy edge** connects a node to its **heavy child**.
- A **light edge** connects a node to any of its **light children**.
- A **heavy path** is a **maximal** and contiguous path formed by **only heavy edges**. The set of all **heavy paths** spans every node in the tree.
*Note that there is no notion of **"light paths"** in HLD; **light edges** simply connect heavy paths to each other.*

### Properties

**Any path from node $x$ to node $y$ on the tree can pass through at most
  $\mathcal{O}(\log N)$ light edges.**

<Spoiler title="Proof">

Consider a path from node $x$ to node $y$. This path can be broken down into a path from node $x$ to $LCA(x,y)$ and a path from node $y$ to $LCA(x,y)$. Since $LCA(x,y)$ is an ancestor of both endpoints, we only need to prove that the path from any node up to any of its ancestors passes through $\mathcal{O}(\log N)$ light edges.

Suppose a light edge connects a parent node $u$ and a child node $v$. By the definiton of a light edge, $v$ must be a light child. This implies that $u$ has a heavy child with a subtree size greater than or equal to $v$'s. Therefore, the size of the subtree rooted at $u$ must be at least twice the size of the subtree rooted at $v$ since it contains both $v$'s subtree as well as the heavy child's subtree.

Since the subtree size of a node cannot exceed the total number of nodes, $N$, this doubling process can occur at most $\mathcal{O}(\log N)$ times when traversing up from any node to the root. Therefore, there are at most $\mathcal{O}(\log N)$ light edges on the path from $x$ to $LCA(x,y)$ and on the path from $y$ to $LCA(x,y)$. In total, the path from $x$ to $y$ contains $\mathcal{O}(\log N)+\mathcal{O}(\log N)=\mathcal{O}(\log N)$ light edges.
</Spoiler>

A heavy path can only be broken by crossing a light edge; otherwise, the heavy path would simply continue on. Because of this, we know there are at most ${O}(\log N)$ heavy paths on
any path from an arbitrary node $x$ to an arbitrary node $y$.

Additionally, by using a [Segment Tree](/gold/PURS#segment-tree) (or similar structure), we can process queries on a contiguous segment of any heavy chain in $\mathcal{O}(\log N)$ time.

Since the process requires performing $\mathcal{O}(\log N)$ Segment Tree operations, the total time for a path query or update is $\mathcal{O}(\log N) \times \mathcal{O}(\log N) = \mathcal{O}(\log^2 N)$.
Therefore, we can answer $Q$ queries in $\mathcal{O}(Q \log^2 N)$ time.

Here's an animation of how the algorithm works:
<video width="960" height="720" controls>
	<source src="/animations/hld.mp4" type="video/mp4"/>
</video>



## Implementation

<Resources>
	<Resource
		source="CF"
		title="AI-Cash - HLD Implementation"
		url="22072"
		starred
	/>
	<Resource
		source="CF"
		title="adamant - Easiest HLD with subtree queries"
		url="53170"
		starred
	>
		not complete
	</Resource>
	<Resource
		source="Benq"
		title="Complete HLD Implementation"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Trees%20(10)/HLD%20(10.3).h"
		starred
	>
		complete implementation following the above two articles with minor
		modifications
	</Resource>
</Resources>

Below is an example implementation of Heavy Light Decomposition based on the resources above. See the solution below, as well as the solutions for [Subtrees & Paths](/problems/hr-subtrees--paths/solution) and [Query on a tree again!](/problems/spoj-query-on-a-tree-again/solution), for examples of how this implementation can be used.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

template <class T, bool VALS_IN_EDGES> class HLD {
  private:
	int N, R, tim = 0;  // n, root node, time
	vector<vector<int>> adj;
	vector<int> par, siz, depth, rt, pos;  // parent, size, depth, root, position arrays
	LazySegtree<T> segtree;                // Modify as needed

	/** Compute the size of each subtree and set parent-child relationship
	 * Subtree of node v corresponds to segment [ pos[v], pos[v] + sz[v] ) */
	void dfs_sz(int v) {
		if (par[v] != -1) adj[v].erase(find(adj[v].begin(), adj[v].end(), par[v]));
		for (int &u : adj[v]) {
			par[u] = v, depth[u] = depth[v] + 1;
			dfs_sz(u);
			siz[v] += siz[u];
			if (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);
		}
	}

	/** Assign positions for nodes
	  * Path from v to the last vertex in ascending heavy path
	    corresponds to [ pos[rt[v]], pos[v] ] */
	void dfs_hld(int v) {
		pos[v] = tim++;
		for (int u : adj[v]) {
			rt[u] = (u == adj[v][0] ? rt[v] : u);
			dfs_hld(u);
		}
	}

	/** process all heavy path and combine their results */
	template <class B> void process(int u, int v, B op) {
		for (; rt[u] != rt[v]; v = par[rt[v]]) {
			if (depth[rt[u]] > depth[rt[v]]) swap(u, v);
			op(pos[rt[v]], pos[v]);
		}
		if (depth[u] > depth[v]) swap(u, v);
		op(pos[u] + VALS_IN_EDGES, pos[v]);
	}

  public:
	HLD(vector<vector<int>> adj_, int _R)
	    : N(adj_.size()), R(_R), adj(adj_), par(N, -1), siz(N, 1), depth(N), rt(N),
	      pos(N), segtree(vector<ll>(N, 0ll))  // modify if need
	{
		rt[R] = R;
		dfs_sz(R);
		dfs_hld(R);
	}

	T query_path(int u, int v) {
		T res = 0;  // default value, modify depending on problem
		process(u, v, [&](int l, int r) {
			res = max(res, segtree.range_max(l, r));  // modify depending on problem
		});
		return res;
	}

	void modify_node(int u, T val) { segtree.set(pos[u], val); }

	void modify_subtree(int v, T val) {
		segtree.range_update(pos[v] + VALS_IN_EDGES, pos[v] + siz[v] - 1,
		                     Query{ADD, val});  // modify if need
	}
};
```

</CPPSection>
</LanguageSection>

## Path Queries II

<FocusProblem problem="sample" />

### Explanation

We can label each edge as either heavy or light, then use a segment tree to keep track of the maximum value in each heavy chain.

Now, to change the value at node $i$ to $x$, we can just update the value in the segment tree. To query the maximum value in the path from $a$ to $b$, we first find the [Lowest Common Ancestor](/gold/tree-euler#lca). We combine the path from $a$ to $lca(a,b)$ and the path from $b$ to $lca(a,b)$ to find our answer.

### Implementation

**Time Complexity:** $\mathcal{O}(\log^2N)$ per query

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Segment Tree}
/** A data structure that can answer point update & range max queries. */
template <class T> class MaxSegmentTree {
  private:
	// const T DEFAULT = std::numeric_limits<T>().max();
	const T DEFAULT = 0;

	int len;
	vector<T> segtree;

  public:
	MaxSegmentTree(int len) : len(len), segtree(len * 2, DEFAULT) {}

	void set(int ind, T val) {
		ind += len;
		segtree[ind] = val;
		for (; ind > 1; ind /= 2) {
			segtree[ind / 2] = std::max(segtree[ind], segtree[ind ^ 1]);
		}
	}

	T range_max(int start, int end) {
		T max = DEFAULT;
		for (start += len, end += len; start < end; start /= 2, end /= 2) {
			if (start % 2 == 1) { max = std::max(max, segtree[start++]); }
			if (end % 2 == 1) { max = std::max(max, segtree[--end]); }
		}
		return max;
	}
};
// EndCodeSnip

// BeginCodeSnip{HLD}
template <class T, bool VALS_IN_EDGES> class HLD {
  private:
	int N, R, tim = 0;  // n, root node, time
	vector<vector<int>> adj;
	vector<int> par, siz, depth, rt, pos;  // parent, size, depth, root, position arrays
	MaxSegmentTree<T> segtree;             // Modify as needed

	/** Compute the size of each subtree and set parent-child relationship
	 * Subtree of node v corresponds to segment [ pos[v], pos[v] + sz[v] ) */
	void dfs_sz(int v) {
		if (par[v] != -1) adj[v].erase(find(adj[v].begin(), adj[v].end(), par[v]));
		for (int &u : adj[v]) {
			par[u] = v, depth[u] = depth[v] + 1;
			dfs_sz(u);
			siz[v] += siz[u];
			if (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);
		}
	}

	/** Assign positions for nodes
	  * Path from v to the last vertex in ascending heavy path
	    corresponds to [ pos[rt[v]], pos[v] ] */
	void dfs_hld(int v) {
		pos[v] = tim++;
		for (int u : adj[v]) {
			rt[u] = (u == adj[v][0] ? rt[v] : u);
			dfs_hld(u);
		}
	}

	/** process all heavy path and combine their results */
	template <class B> void process(int u, int v, B op) {
		for (; rt[u] != rt[v]; v = par[rt[v]]) {
			if (depth[rt[u]] > depth[rt[v]]) swap(u, v);
			op(pos[rt[v]], pos[v]);
		}
		if (depth[u] > depth[v]) swap(u, v);
		op(pos[u] + VALS_IN_EDGES, pos[v]);
	}

  public:
	HLD(vector<vector<int>> adj_, int _R)
	    : N(adj_.size()), R(_R), adj(adj_), par(N, -1), siz(N, 1), depth(N), rt(N),
	      pos(N), segtree(N)  // modify as needed
	{
		rt[R] = R;
		dfs_sz(R);
		dfs_hld(R);
	}

	T query_path(int u, int v) {
		T res = 0;  // default value, modify depending on problem
		process(u, v, [&](int l, int r) {
			res = max(res, segtree.range_max(l, r + 1));  // modify depending on problem
		});
		return res;
	}

	void modify_node(int u, T val) { segtree.set(pos[u], val); }
};
// EndCodeSnip

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int n, q;
	cin >> n >> q;
	vector<int> v(n);
	vector<vector<int>> adj(n);
	for (int i = 0; i < n; i++) { cin >> v[i]; }

	for (int i = 0; i < n - 1; i++) {
		int a, b;
		cin >> a >> b;
		--a, --b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

	HLD<int, 0> H(adj, 0);

	for (int i = 0; i < n; i++) { H.modify_node(i, v[i]); }

	while (q--) {
		int type, s, a, b, x;
		cin >> type;
		if (type == 1) {
			cin >> s >> x;
			--s;
			H.modify_node(s, x);
		} else if (type == 2) {
			cin >> a >> b;
			--a, --b;
			cout << H.query_path(a, b) << " ";
		}
	}
}
```

</CPPSection>
</LanguageSection>

## Problems

<Problems problems="general" />

<Warning>

"Grass Planting" isn't submittable on the USACO website. Use
[this link](https://www.acmicpc.net/problem/5916) to submit.

</Warning>
