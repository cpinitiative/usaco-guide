---
id: geo-pri
title: 'Geometry Primitives'
author: Mihnea Brebenel, Benjamin Qi
description: Basic setup for geometry problems.
frequency: 1
---

You should know operations such as the cross product and dot product.

## Standard Problems

### Location of a point
<FocusProblem problem="pointlocationtest" />

To check the $P$ location towards the $P_1$ $P_2$ line we use following formula: $(P.y - P_1.y) * (P_2.x - P_1.x) - (P.x - P_1.x) * (P_2.y - P_1.y)$
If it's equal to $0$ it means that $P$, $P_1$ and $P_2$ are collinear. Otherwise the value's sign indicated if $P$ is under the line - negative - or above the line - positive.

<Spoiler title="Demonstration">

Let $m_1=\frac{P_1.y - P_2.y}{P_1.x - P_2.x}$ be the slope of the linear function that goes through the points $P_1$ and $P_2$ and
$m_2=\frac{P_2.y - P.y}{P_2.x - P.x}$ be the slope of the linear function that goes through the points $P_2$ and $P$.

The points are collinear if and only if the slopes are equal i.e. $m_1 = m_2 \Leftrightarrow \frac{P_1.y - P_2.y}{P_1.x - P_2.x} = \frac{P_2.y - P.y}{P_2.x - P.x}
\Leftrightarrow (P_1.y - P_2.y) * (P_2.x - P.x) = (P_1.x - P_2.x) * (P_1.x - P_2.x) \Leftrightarrow (P_1.y - P_2.y) * (P_2.x - P.x) - (P_1.x - P_2.x) * (P_1.x - P_2.x) = 0$.
And this way we obtained the previously mentioned formula.

This formula doesn't only tell us whether the points are collinear, but where the point $P$ is located too.

![Dem](/assets/dem-collinear.png)

</Spoiler>

#### Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Point Class}
struct Point {
	int x, y;
	Point(int a = 0, int b = 0) : x(a), y(b) {}

	friend istream &operator>>(istream &in, Point &p) {
		int x, y;
		in >> p.x >> p.y;
		return in;
	}
};
// EndCodeSnip

long long collinear(Point p, Point p1, Point p2) {
	return 1LL * (p.y - p1.y) * (p2.x - p1.x) -
	       1LL * (p.x - p1.x) * (p2.y - p1.y);
}

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		Point p1, p2, p3;
		cin >> p1 >> p2 >> p3;

		if (collinear(p1, p2, p3) == 0) {
			cout << "TOUCH" << '\n';
		} else if (collinear(p1, p2, p3) < 0) {
			cout << "RIGHT" << '\n';
		} else {
			cout << "LEFT" << '\n';
		}
	}
}
```

</CPPSection>
</LanguageSection>

### Segment intersection
<FocusProblem problem="line" />

We can quickly dismiss the segment intersection by treating them as rectangles having the segments as diagonals which can be easily done.
If it turns out the rectangles intersect then we just check if the segment's ends are on different sides of the other segment.

#### Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Point Class}
struct Point {
	int x, y;
	Point(int a = 0, int b = 0) : x(a), y(b) {}

	friend istream &operator>>(istream &in, Point &p) {
		int x, y;
		in >> p.x >> p.y;
		return in;
	}
};
// EndCodeSnip

int sign(long long num) {
	if (num < 0) {
		return -1;
	} else if (num == 0) {
		return 0;
	} else {
		return 1;
	}
}

long long trigonometric_sense(Point p, Point p1, Point p2) {
	return sign(1LL * (p1.x - p.x) * (p2.y - p.y) -
	            1LL * (p2.x - p.x) * (p1.y - p.y));
}

// Check if the rectangles with [P1, P2] and [P3, P4] as diagonals intersect
bool quick_check(Point p1, Point p2, Point p3, Point p4) {
	int x1, x2, x3, x4, y1, y2, y3, y4;
	x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);
	y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);
	x3 = min(p3.x, p4.x), x4 = max(p3.x, p4.x);
	y3 = min(p3.y, p4.y), y4 = max(p3.y, p4.y);
	return x2 < x3 || x4 < x1 || y2 < y3 || y4 < y1;
}

bool check(Point p1, Point p2, Point p3, Point p4) {
	if (trigonometric_sense(p1, p2, p3) * trigonometric_sense(p1, p2, p4) > 0) {
		return false;
	}
	if (trigonometric_sense(p3, p4, p1) * trigonometric_sense(p3, p4, p2) > 0) {
		return false;
	}
	return true;
}

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		Point p1, p2, p3, p4;
		cin >> p1 >> p2 >> p3 >> p4;

		if (quick_check(p1, p2, p3, p4)) {
			puts("NO");
		} else if (check(p1, p2, p3, p4)) {
			puts("YES");
		} else {
			puts("NO");
		}
	}
}
```

</CPPSection>
</LanguageSection>

### Polygon area
<FocusProblem problem="polygon" />

The following algorithm uses the [Shoelace formula](https://en.wikipedia.org/wiki/Shoelace_formula).

#### Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Point Class}
struct Point {
	int x, y;
	Point(int a = 0, int b = 0) : x(a), y(b) {}

	friend istream &operator>>(istream &in, Point &p) {
		int x, y;
		in >> p.x >> p.y;
		return in;
	}
};
// EndCodeSnip

int main() {
	int n;
	cin >> n;
	vector<Point> points(n);
	for (auto &p : points) { cin >> p; }
	points.push_back(points[0]);

	long long area = 0;
	for (int i = 0; i < points.size(); i++) {
		area += (1LL * points[i].x * points[i + 1].y -
		         1LL * points[i].y * points[i + 1].x);
	}
}
```

</CPPSection>
</LanguageSection>

### Point's location relative to polygon

<FocusProblem problem="polygon2" />

We can cast a ray from the point $P$ going in any fixed direction (people usually go to the right).
If the point is located on the outside of the polygon the ray will intersect its edges an even number of times.
If the point is on the inside of the polygon then it will intersect the edge an odd number of times.

This approach is called [ray casting](https://en.wikipedia.org/wiki/Point_in_polygon).

#### Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Point Class}
struct Point {
	int x, y;
	Point(int a = 0, int b = 0) : x(a), y(b) {}

	friend istream &operator>>(istream &in, Point &p) {
		int x, y;
		in >> p.x >> p.y;
		return in;
	}
};
// EndCodeSnip

int sign(long long num) {
	if (num < 0) {
		return -1;
	} else if (num == 0) {
		return 0;
	} else {
		return 1;
	}
}

long long trigonometric_sense(Point p, Point p1, Point p2) {
	return sign(1LL * (p1.x - p.x) * (p2.y - p.y) -
	            1LL * (p2.x - p.x) * (p1.y - p.y));
}

// Check if the rectangles with [P1, P2] and [P3, P4] as diagonals intersect
bool quick_check(Point p1, Point p2, Point p3, Point p4) {
	int x1, x2, x3, x4, y1, y2, y3, y4;
	x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);
	y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);
	x3 = min(p3.x, p4.x), x4 = max(p3.x, p4.x);
	y3 = min(p3.y, p4.y), y4 = max(p3.y, p4.y);
	return x2 < x3 || x4 < x1 || y2 < y3 || y4 < y1;
}

bool check(Point p1, Point p2, Point p3, Point p4) {
	if (quick_check(p1, p2, p3, p4)) { return false; }
	if (trigonometric_sense(p1, p2, p3) * trigonometric_sense(p1, p2, p4) > 0) {
		return false;
	}
	if (trigonometric_sense(p3, p4, p1) * trigonometric_sense(p3, p4, p2) > 0) {
		return false;
	}
	return true;
}

bool collinear(Point p, Point p1, Point p2) {
	return 1LL * (p.y - p1.y) * (p2.x - p1.x) -
	           1LL * (p.x - p1.x) * (p2.y - p1.y) ==
	       0;
}

int main() {
	int n, m;
	cin >> n >> m;
	// Polygon's edges
	vector<Point> poly(n);
	for (auto &p : poly) { cin >> p; }

	poly.push_back(poly[0]);
	for (int j = 0; j < m; j++) {
		Point A;
		cin >> A;
		// The infinite casting ray from A
		Point B = {INT32_MAX, A.y};
		// Intersection count
		int cnt = 0;
		bool on_boundary = false;
		for (int i = 1; i < poly.size() - 1; i++) {
			// Check if point A is on the edge
			if (collinear(A, poly[i], poly[i + 1])) {
				puts("BOUNDARY");
				on_boundary = true;
				break;
			}
			// Check the intersectio with the polygon's edge
			if (check(A, B, poly[i], poly[i + 1])) { cnt++; }
		}

		if (!on_boundary) { cout << (cnt % 2 ? "INSIDE" : "OUTSIDE") << '\n'; }
	}
}
```

</CPPSection>
</LanguageSection>

### Lattice points in polygon
<FocusProblem problem="latticepoints" />

Let's first focus on the lattice points on the polygon's boundary. We'll process each edge individually. The number of intersections of a line with lattice points is the greatest
common divisor of $P_1.x - P_2.x$ and $P_1.y - P_2.y$.

<Spoiler title="Demonstration">
Using the linear function it can be proven. Denote the segment ends with ($x_1$,$y_1$) and ($x_2$, $y_2$). The function has the following
form: &f(x) = ax + b&. The slope of $f(x)$, in our case $a$, is $\frac{y_1-y_2}{x_1-x_2}$, so $f(x)$ becomes $f(x) = \frac{y_1-y_2}{x_1-x_2} * x + b$.

This means that every points along the line has the following form: $(x, f(x))$ which has become $(x, \frac{y_1-y_2}{x_1-x_2} * x + b)$. Number $x$ can
be any integer, but &f(x)& no. In order to be lattice point &f(x)& has to be an integer, by eliminating the fraction resulting in $x$ divisible by $x_1 - x_2$.

</Spoiler>

Now that we know the number of lattice points on the boundary we can find the number of lattice points inside the polygon using [Pick's theorem](https://en.wikipedia.org/wiki/Pick%27s_theorem).
Let's denote $A$ polygon's area, $i$ the number of integer points inside and $b$ the number of integer points on its boundary. Then, according to Pick's theorem, we have the following
equation: $A = i + b/2 - 1$. Changing the order a little bit to get $i = A - b/2 + 1$. We've found $b$ and, as you've probably already solved [Polygon Area](https://cses.fi/problemset/task/2191) from above,
$A$ can be computed using cross-product.

#### Implementation

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>

using namespace std;

// BeginCodeSnip{Point Class}
struct Point {
	int x, y;
	Point(int a = 0, int b = 0) : x(a), y(b) {}
	Point operator-(const Point &other) { return {x - other.x, y - other.y}; }
	friend istream &operator>>(istream &in, Point &p) {
		int x, y;
		in >> p.x >> p.y;
		return in;
	}
};
// EndCodeSnip

int main() {
	int n;
	cin >> n;
	vector<Point> points(n);
	for (Point &point : points) { cin >> point; }
	points.push_back(points[0]);
	long long area = 0;
	for (int i = 0; i < n; i++) {
		area += (1LL * points[i].x * points[i + 1].y -
		         1LL * points[i].y * points[i + 1].x);
	}
	area = abs(area);
	long long boundary_points = 0;
	for (int i = 0; i < n; i++) {
		Point diff = points[i + 1] - points[i];
		int g = gcd(abs(diff.x), abs(diff.y));
		boundary_points += g;
	}
	long long interior_points = (area - boundary_points) / 2 + 1;
	cout << interior_points << ' ' << boundary_points;
}
```
</CPPSection>
</LanguageSection>

### Euclidean minimum spanning tree - EMST

<FocusProblem problem="emst"/>

#### Initial Approach

The problem is a combination of EMST - euclidean minimum spanning tree - and LCA. We can compute the EMST using Kruskal's or Prim's algorithm. Using this approach, the algorithm
will run on $n^2$ edges, which causes TLE.

<LanguageSection>
<CPPSection>

```cpp
#include <functional>
#include <iostream>
#include <unordered_set>
#include <vector>

using namespace std;

struct Point {
	int x, y, idx;
};

// BeginCodeSnip{DSU}
class DisjointSets {
  private:
	vector<int> parents;
	vector<int> sizes;

  public:
	DisjointSets(int size) : parents(size), sizes(size, 1) {
		for (int i = 0; i < size; i++) { parents[i] = i; }
	}

	/** @return the "representative" node in x's component */
	int find(int x) {
		return parents[x] == x ? x : (parents[x] = find(parents[x]));
	}

	/** @return whether the merge changed connectivity */
	bool unite(int x, int y) {
		int x_root = find(x);
		int y_root = find(y);
		if (x_root == y_root) { return false; }

		if (sizes[x_root] < sizes[y_root]) { swap(x_root, y_root); }
		sizes[x_root] += sizes[y_root];
		parents[y_root] = x_root;
		return true;
	}

	/** @return whether x and y are in the same connected component */
	bool connected(int x, int y) { return find(x) == find(y); }
};
// EncCodeSnip

// BeginCodeSnip{Binary jumping}
class BinaryJumping {
  private:
	const int MAX_LOG = 20;
	vector<vector<int>> up;
	vector<vector<int>> val;
	vector<int> depth;

  public:
	BinaryJumping(vector<vector<pair<int, int>>> &tree) {
		up.resize((int)tree.size());
		depth.resize((int)tree.size());
		val.resize((int)tree.size());
		for (int i = 0; i < (int)tree.size(); i++) {
			up[i].resize(MAX_LOG);
			val[i].resize(MAX_LOG);
		}
		dfs(0, 0, tree);
	}

	void dfs(int node, int parent, vector<vector<pair<int, int>>> &tree) {
		depth[node] = depth[parent] + 1;
		up[node][0] = parent;
		for (int i = 1; i < MAX_LOG; i++) {
			up[node][i] = up[up[node][i - 1]][i - 1];
			val[node][i] = max(val[node][i - 1], val[up[node][i - 1]][i - 1]);
		}
		for (auto [son, dist] : tree[node]) {
			if (son == parent) { continue; }
			val[son][0] = dist;
			dfs(son, node, tree);
		}
	}

	int jump(int x, int d) {
		for (int i = 0; (1 << i) <= d; i++) {
			if ((1 << i) & d) { x = up[x][i]; }
		}
		return x;
	}
	// Lca for x and y
	int get_lca(int x, int y) {
		if (depth[x] < depth[y]) { swap(x, y); }
		x = jump(x, depth[x] - depth[y]);
		if (x == y) { return x; }
		for (int i = MAX_LOG; i >= 0; i--) {
			if (up[x][i] != up[y][i]) {
				x = up[x][i];
				y = up[y][i];
			}
		}
		return up[x][1];
	}
	// Query for max values on chain x - ... - y
	int query(int x, int y) {
		int z = get_lca(x, y), ans = 0, d;
		d = depth[x] - depth[z];
		for (int i = 0; (1 << i) <= d; i++) {
			if ((1 << i) & d) {
				ans = max(ans, val[x][i]);
				x = up[x][i];
			}
		}
		d = depth[y] - depth[z];
		for (int i = 0; (1 << i) <= d; i++) {
			if ((1 << i) & d) {
				ans = max(ans, val[y][i]);
				y = up[y][i];
			}
		}
		return ans;
	}
};
// EndCodeSnip

// Manhattan distance
int dist(const Point &a, const Point &b) {
	return abs(a.x - b.x) + abs(a.y - b.y);
}

vector<pair<Point, Point>> compute_mst(vector<pair<Point, Point>> edges) {
	sort(edges.begin(), edges.end(),
	     [&](pair<Point, Point> a, pair<Point, Point> b) {
		     return dist(a.first, a.second) < dist(b.first, b.second);
	     });
	DisjointSets ds((int)edges.size());
	vector<pair<Point, Point>> mst;
	for (int i = 0; i < (int)edges.size(); i++) {
		if (ds.connected(edges[i].first.idx, edges[i].second.idx)) { continue; }
		ds.unite(edges[i].first.idx, edges[i].second.idx);
		mst.push_back(edges[i]);
	}
	return mst;
}

void test_case() {
	int n;
	cin >> n;
	vector<Point> Points;
	for (int i = 0; i < n; i++) {
		int x, y;
		cin >> x >> y;
		Points.push_back({x, y, i});
	}

	vector<pair<Point, Point>> mst;
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			mst.push_back({Points[i], Points[j]});
		}
	}

	mst = compute_mst(mst);
	vector<vector<pair<int, int>>> tree(n);
	for (pair<Point, Point> edge : mst) {
		tree[edge.first.idx].push_back(
		    {edge.second.idx,
		     dist(Points[edge.first.idx], Points[edge.second.idx])});
		tree[edge.second.idx].push_back(
		    {edge.first.idx,
		     dist(Points[edge.first.idx], Points[edge.second.idx])});
	}

	int q;
	BinaryJumping lca(tree);
	cin >> q;
	while (q--) {
		int x, y;
		cin >> x >> y;
		x--;
		y--;
		cout << lca.query(x, y) << '\n';
	}
}

int main() {
	int t;
	cin >> t;
	while (t--) { test_case(); }
	return 0;
}
```

**Time Complexity:** $\mathcal{O}(N^2 \cdot \log_{2}{N})$


</CPPSection>
</LanguageSection>

### Algorithms Overview

<Problems problems="standard" />

## Resources

<Resources>
	<Resource source="CF" title="C++ - std::complex" url="22175" starred>
		short description of operations
	</Resource>
	<Resource source="CPH" title="29 - Geometry" starred>
		Complex #s, Points & Lines, Polygons, Distances
	</Resource>
	<Resource source="CF" title="Point Struct" url="48122" starred>
		code, examples
	</Resource>
	<Resource
		source="cp-algo"
		title="Geometry - Elementary Operations"
		url="https://cp-algorithms.com/"
		starred
	 />
	<Resource source="CPC" title="12 - geometry" url="12_geometry" starred>
		basics, polygon area, point in polygon
	</Resource>
	<Resource
		source="CF"
		title="vlecomte - Geometry Handbook"
		url="59129"
		starred
	>
		some material is quite advanced
	</Resource>
	<Resource source="CP2" title="7.2, 7.3 - Basic Geo, Polygons"/>
</Resources>

<!-- 	<Resource
		source="TC"
		title="Basic Geometry Concepts Pts 1,2"
		url="geometry-concepts-basic-concepts"
	>
		broken code format
	</Resource> -->

- [My Templates](<https://github.com/bqi343/USACO/tree/master/Implementations/content/geometry%20(13)/Primitives>)

## Misc Problems

Some European Olympiads, like the CEOI, Balkan OI, and the Croatian OI, tend to
have a lot of geometry problems. These problems tend to be quite difficult as
well, so look for problems there when you run out of problems to practice!

<Problems problems="other" />

<!-- - [TopCoder Watchtower](https://community.topcoder.com/stat?c=problem_statement&pm=2014&rd=4685) -->
