---
id: cses-1136
source: CSES
title: Counting Paths
author: Dustin Miao
---

**Time Complexity**: $\mathcal O(m\log n + n)$

For each path $(a, b)$, we can split it into two paths: $(a, lca(a, b)), (b, lca(a, b))$. We 
can find the LCA with any method, but the easiest is with binary lifting. For each node, 
keep track of the number paths that begin at that node and the number that end at that node. 

If $k$ is the number of paths coming from a node's children, $s$ is the number of paths 
starting at the current node, and $e$ is the number of paths ending at the current node, 
then the answer for that node is $k + s - e / 2$. The $e / 2$ is because by splitting up
the paths, we double count the lca for each path. The number of paths going to the node's
parent is $k + s - e$. Thus, we can process all the paths at once using a single post-order 
traversal of the tree. 

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <cassert>
using namespace std;
 
#define PB push_back
 
int N, M;
vector<int> adj[200005];
 
int dep[200005], par[200005][20];

// initializes depth and par
void init_bl(int u, int p, int d) {
	dep[u] = d;
	par[u][0] = p;
	for (int v : adj[u])
		if (v != p)
			init_bl(v, u, d + 1);
}
 
// initializes binary lifting
void init_bl() {
	init_bl(1, 1, 0);
	for (int k = 1; (1 << k) <= N; k++)
		for (int i = 1; i <= N; i++)
			par[i][k] = par[par[i][k - 1]][k - 1];
}

// queries lca of a and b
int query_lca(int a, int b) {
	if (dep[a] > dep[b])
		swap(a, b);
	for (int k = 19; k >= 0; k--)
		if (dep[b] - (1 << k) >= dep[a])
			b = par[b][k];
	assert(dep[a] == dep[b]);
	if (a == b)
		return a;
	for (int k = 19; k >= 0; k--)
		if (par[a][k] != par[b][k])
			a = par[a][k], b = par[b][k];
	assert(par[a][0] == par[b][0]);
	return par[a][0];
} 
 
int ans[200005], S[200005], E[200005];

// initializes ans
int dfs_ans(int u, int p) {
	int sum = 0;
	for (int v : adj[u])
		if (v != p)
			sum += dfs_ans(v, u);
	ans[u] = sum + S[u] - E[u] / 2;
	return sum + S[u] - E[u];
}
 
int main() {
	cin >> N >> M;
	for (int i = 1; i < N; i++) {
		int a, b; cin >> a >> b;
		adj[a].PB(b);
		adj[b].PB(a);
	}
	init_bl();
	while (M--) {
		int a, b; cin >> a >> b;
		S[a]++, S[b]++, E[query_lca(a, b)] += 2; 
	}
 
	dfs_ans(1, 0);
 
	for (int i = 1; i <= N; i++) 
		cout << ans[i] << ' ';
	cout << '\n';
}
```

</CPPSection>

</LanguageSection>
