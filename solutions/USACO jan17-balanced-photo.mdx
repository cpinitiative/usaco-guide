---
id: usaco-693
source: USACO Gold 2017 January
title: Balanced Photo
author: Andy Wang
---

[Official Analysis](http://usaco.org/current/data/sol_bphoto_gold_jan17.html)

The official solution uses [binary indexed tree](https://usaco.guide/gold/PURS/#binary-indexed-tree)

An alternative solution uses order statistic tree.(C++ only)

## Solution(C++ only)

In order to find the cows taller than the current cow on its left and right, we maintain two balanced binary search trees storing the heights of the cows on the left and right of the current cow. Then, using function `lower_bound`, we can find the first cow in the set that is higher than the current cow. 

However, STL `set` is **NOT** a random access data-structure, which means that the time complexity of finding all cows higher than the current cow is $O(N)$.(e.g using `distance()`)

To lower the time complexity, we can use an [order statistic tree](https://usaco.guide/gold/PURS/#order-statistic-tree) to find the number of cows that are higher than the current one in $O(Nlog(N))$ time.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> // for policy-based data structures
using namespace __gnu_pbds;				 // for policy-based data structures
using namespace std;

typedef tree<int, null_type, less<int>, rb_tree_tag,
			 tree_order_statistics_node_update>
	indexed_set; // indexed_set -> order_of_key & find_by_order
int N, h, ans;
vector<int> height;
indexed_set cow; // store height of cows on the right
indexed_set woc; // store height of cows on the left
int main()
{
	FILE *in, *out;
	in = fopen("bphoto.in", "r");
	out = fopen("bphoto.out", "w");
	fscanf(in, "%d", &N);
	for (int i = 0; i < N; i++)
	{
		fscanf(in, "%d", &h);
		cow.insert(h);
		height.push_back(h);
	}
	for (int i : height)
	{
		cow.erase(i);							   //remove current cow from right
		int le = woc.size() - woc.order_of_key(i); // order_of_key counts the number of elements in the set that are strictly less than i
		int ri = cow.size() - cow.order_of_key(i); // we want to count the number of elemtns that are larger than i
		woc.insert(i);							   //add current cow to left
		if (max(le, ri) > 2 * min(le, ri))
			ans++;
	}
	fprintf(out, "%d\n", ans);
}
```

</CPPSection>
</LanguageSection>
