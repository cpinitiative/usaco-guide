---
id: usaco-810
source: USACO Silver 2018 February
title: Rest Stops
author: Vivian Han
---

[Official Analysis](http://www.usaco.org/current/data/sol_reststops_silver_feb18.html)

(Analysis by Dhruv Rohatgi)

Suppose that early in the hike there is a rest stop with tastiness $c$, but later there is a rest stop with tastiness $C$, where $C>c$. 
Then it is never optimal for Bessie to spend any time at the first rest stop: 
if she did, she could spend the same amount of time at the later rest stop instead, and she would still never be behind Farmer John. 
So the only rest stops which Bessie might stop at are the rest stops which have more tastiness than any subsequent rest stops.

We can find these "right-maximal" rest stops in a single right-to-left scan, keeping track of the largest tastiness seen so far. 
Now we can simply perform a greedy algorithm: never stop at non-right-maximal rest stops. 
At a right-maximal rest stop, Bessie should stop there as long as possible (i.e. until Farmer John catches up with her). 
Then she proceeds, until the next right-maximal rest stop.

To see correctness of this greedy algorithm, suppose Bessie did not spend as long as possible at some right-maximal rest stop $r$. 
Then she would leave this rest stop $t$ seconds early, for some positive $t$. Suppose the next place Bessie stops is rest stop $r′$. 
We could improve Bessie's tastiness intake by having her spend $1$ less second at $r′$, and $1$ more second at rest stop $r$. 

It can be verified that Bessie will still never be behind Farmer John, and since the tastiness at $r$ is greater than the tastiness at $r′$, we improved Bessie's outcome. 
Therefore no optimal solution will leave a right-maximal rest stop early, and our greedy algorithm is correct.
## Implementation

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <fstream>
using namespace std;

int32_t trailLen, stopNum, fRate, bRate;
int32_t x[100000];
int32_t c[100000];
bool good[100000];

int main()
{

	ifstream in;
	in.open("reststops.in");
	in >> trailLen >> stopNum >> fRate >> bRate;
//	scan in rest stop data
	for (int i = 0 ; i < stopNum; i++) {
		in >> x[i] >> c[i];
	}

	//find all "best" stops
	int32_t max = 0;
	for (int i = stopNum-1; i >= 0; i--) {
		good[i] = false;
		if (c[i] > max) { //there are no stops after stop i that are "better"
			good[i] = true;
			max = c[i];
		}
	}

	//simulate the whole trail
	long long prevStopPos = 0;
	long long ans = 0;
	for (int i = 0; i < stopNum; i++) {
		if (good[i]) {
			long long travelDist = x[i] - prevStopPos;
			long long fTime = travelDist * fRate;
			long long bTime = travelDist * bRate;
			long long restTime = fTime - bTime;
			ans += restTime * c[i];
			prevStopPos = x[i];
		}
	}
// */
	ofstream out;
	out.open("reststops.out");
	out << ans << endl;
	out.close();

	//cout << ans << endl;

	return 0;
}
```
</CPPSection>

<JavaSection>

```java
import java.io.*;

public class RestStops {

    static int[] x, c;
    static boolean[] good;

    public static void main(String[] args) {
        try {
            BufferedReader br = new BufferedReader(new FileReader("reststops.in"));
            String[] line = br.readLine().split(" ");
            int trailLen = Integer.parseInt(line[0]); //this value is never used...
            int stopNum = Integer.parseInt(line[1]);
            int fRate = Integer.parseInt(line[2]);
            int bRate = Integer.parseInt(line[3]);

            x = new int[stopNum];
            c = new int[stopNum];
            good = new boolean[stopNum];

            //scan in rest stop data
            for (int i = 0 ; i < stopNum; i++) {
                line = br.readLine().split(" ");
                x[i] = Integer.parseInt(line[0]);
                c[i] = Integer.parseInt(line[1]);
            }
            br.close();

            //find all "best" stops
            int max = 0;
            for (int i = stopNum-1; i >= 0; i--) {
                if (c[i] > max) { //there are no stops after stop i that are "better"
                    good[i] = true;
                    max = c[i];
                }
            }

            //simulate the whole trail
            int prevStopPos = 0;
            long ans = 0;
            for (int i = 0; i < stopNum; i++) {
                if (good[i]) {
                    long travelDist = x[i] - prevStopPos;
                    long fTime = travelDist * fRate;
                    long bTime = travelDist * bRate;
                    long restTime = fTime - bTime;
                    ans += restTime * c[i];
                    prevStopPos = x[i];
                }
            }

            BufferedWriter bw = new BufferedWriter(new FileWriter("reststops.out"));
            bw.write(ans + "\n");
            bw.close();
        }
        catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
```
</JavaSection>

</LanguageSection>
