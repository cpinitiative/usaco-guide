---
id: usaco-380
source: USACO Silver 2014 January
title: Cross Country Skiing
author: Nathan Gong
---

[Official Analysis](http://www.usaco.org/current/data/sol_ccski.html)

## Implementation

**Time Complexity:** $\mathcal{O}(NM\log R)$, where $R$ denotes the maximum
height difference between any two cells

<LanguageSection>

<JavaSection>

```java
import java.util.*;
import java.io.*;

public class CrossCountrySkiing {
	static int n, m;
	static int startI, startJ; // Stores starting position of each floodfill
	static int[][] course; // Stores the skiing course heights
	static boolean[][] waypoints; // Stored as booleans instead of 1s and 0s
	static boolean[][] vis; // Visited array for floodfill

	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("ccski");

		n = io.nextInt();
		m = io.nextInt();

		int minHeight = Integer.MAX_VALUE;
		int maxHeight = Integer.MIN_VALUE;

		course = new int[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				course[i][j] = io.nextInt();
				minHeight = Math.min(minHeight, course[i][j]);
				maxHeight = Math.max(maxHeight, course[i][j]);
			}
		}
		
		waypoints = new boolean[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (io.nextInt() == 1) {
					waypoints[i][j] = true;

					// Keep one of the waypoints as the starting position
					startI = i;
					startJ = j;
				} else {
					waypoints[i][j] = false;
				}
			}
		}

		// Binary search for the minimum possible value of d that works
		// We can set "hi" to maxHeight - minHeight because that will be the
		// maximum value of d we need to try
		int lo = 0;
		int hi = maxHeight - minHeight;
		int minD = -1;
		while (lo <= hi) {
			int d = (lo + hi) / 2;
			if (reachable(d)) {
				minD = d;
				hi = d - 1;
			} else {
				lo = d + 1;
			}
		}
		
		io.println(minD);
		io.close();
	}

	// i and j store current position
	// d stores current value of d
	// prevHeight stores the height of the previous cell
	static void floodfill(int i, int j, int d, int prevHeight) {
		// Check if we are out of bounds
		if (i < 0 || i >= n || j < 0 || j >= m) {
			return;
		}
		// Check if current position has already been visited
		if (vis[i][j]) {
			return;
		}
		// Check if current position can be visited from previous position
		if (Math.abs(course[i][j] - prevHeight) > d) {
			return;
		}

		// Mark position as visited if all checks pass
		vis[i][j] = true;

		// Visit each adjacent cell
		floodfill(i + 1, j, d, course[i][j]);
		floodfill(i - 1, j, d, course[i][j]);
		floodfill(i, j + 1, d, course[i][j]);
		floodfill(i, j - 1, d, course[i][j]);
	}

	static boolean reachable(int d) {
		// Reset visited array and begin floodfill (DFS) from start position
		vis = new boolean[n][m];
		floodfill(startI, startJ, d, course[startI][startJ]);
		
		// Check each cell: if it is a waypoint and it hasn't been visited,
		// we know not all waypoints are reachable from one another
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (waypoints[i][j] && !vis[i][j]) {
					return false;
				}
			}
		}
		
		return true;
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

#define pb push_back

int r, c;
vector<vector<int>> grid; // grid stores the elevation

// this will be true if the corresponding location
// of the grid has been visited atleast once
vector<vector<bool>> visited;

// right bottom left top
int dy[4] = {0, 1, 0, -1};
int dx[4] = {1, 0, -1, 0};

// this will contain all the waypoints
vector<pair<int, int>> wpts;

void dfs(int row, int col, int mid)
{
	if (row < 0 || col >= c)
	{
		return;
	}
	visited[row][col] = true;
	for (int i = 0; i <= 3; i++)
	{
		int newRow = row + dy[i];
		int newCol = col + dx[i];

		// all three conditions below need to be met simultaneously

		if (newRow >= 0 && newRow < r && newCol >= 0 && newCol < c)
			if (abs(grid[newRow][newCol] - grid[row][col]) <= mid)
				if (!visited[newRow][newCol])
					dfs(newRow, newCol, mid);
	}
	return;
}

bool check()
{
	for (auto i : wpts)
	{
		// checking if all the wpts were visited in the last dfs, or not
		if (visited[i.first][i.second] == false)
			return false;
	}
	return true;
}


int main()
{
	freopen("ccski.in", "r", stdin);
	freopen("ccski.out", "w", stdout);

	cin >> r >> c;
	grid = vector<vector<int>>(r, vector<int>(c));
	visited = vector<vector<bool>>(r, vector<bool>(c, false));
	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < c; j++)
		{
			cin >> grid[i][j];
		}
	}
	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < c; j++)
		{
			int x;
			cin >> x;
			if (x == 1)// wpts contains all the waypoints
				wpts.pb(make_pair(i, j)); 
		}
	}

	// Binary search for the minimum possible value of d that works
	// We can set "hi" to 1e9 because that will be the
	// maximum value of d we need to try
	int lo = 0, hi = 1e9;
	while (lo < hi)
	{
		int mid = lo + (hi - lo) / 2;

		// mid is the maximum absolute elevation difference
		dfs(0, 0, mid);

		// checking if all the waypoints were visited or not
		if (check())
		{
			hi = mid;
		}
		else
			lo = mid + 1;

		visited = vector<vector<bool>>(r, vector<bool>(c, false));
	}
	cout << lo << endl;
}

```

</CPPSection>

</LanguageSection>

