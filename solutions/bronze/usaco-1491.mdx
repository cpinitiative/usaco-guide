---
id: usaco-1491
source: USACO Bronze 2025 February
title: Reflection
author: Sachet Abeysinghe
---

[Official Analysis (C++)](https://usaco.org/current/data/sol_prob1_bronze_feb25.html)

## Explanation

Let's consider each individual square in the top left quadrant and find the minimum number of operations required for this square and the corresponding cells in the other three quadrants to match.
1. If there are three painted squares, we paint the remaining cell, taking one operation.
2. If there are two painted squares, we can either paint the two other cells or remove paint on the two cells, taking two operations.
3. If there is one painted square, we remove paint on the cell, taking one operation.
4. Finally, if all four are painted or not painted, they already match, so zero operations.
Adding up all the contributions for each cell will give us the minimum number of operations needed to achieve the reflective condition. Then, for each of the $U$ updates, we only need to consider the change of contribution of the updated cell and its corresponding cells in the other three quadrants. The simplest way to handle this is to remove the current contribution for those four cells, update the grid, and then add the new contribution.

## Implementation

**Time Complexity:** $\mathcal{O}(N^{2}+U)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, U;
vector<string> grid;

int contribution(int r, int c) {
    vector<char> cells = {
        grid[r][c],
        grid[N - r - 1][c],
        grid[r][N - c - 1],
        grid[N - r - 1][N - c - 1]
    };

    int painted = 0;
    for (char ch : cells) {
        if (ch == '#') painted++;
    }
    return min(painted, 4 - painted);
}

int main() {
    cin >> N >> U;
    grid.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> grid[i];
    }

    long long ans = 0;
    for (int row = 0; row < N / 2; row++) {
        for (int col = 0; col < N / 2; col++) {
            ans += contribution(row, col);
        }
    }

    cout << ans << '\n';

    for (int i = 0; i < U; i++) {
        int r, c;
        cin >> r >> c;
        r--; c--;
        ans -= contribution(r, c);
        grid[r][c] = (grid[r][c] == '.') ? '#' : '.';
        ans += contribution(r, c);
        cout << ans << '\n';
    }
}
```

</CPPSection>

<PySection>

```py
N, U = map(int, input().split())
grid = [list(input()) for i in range(N)]

def contribution(r, c):
    cells = [grid[r][c], grid[N - r - 1][c], grid[r][N - c - 1], grid[N - r - 1][N - c - 1]]
    painted = cells.count("#")
    return min(painted, 4 - painted)

ans = 0
for row in range(N // 2):
    for column in range(N // 2):
        ans += contribution(row, column)
print(ans)

for i in range(U):
    r, c = map(int, input().split())
    r -= 1
    c -= 1
    ans -= contribution(r, c)
    grid[r][c] = "#" if grid[r][c] == "." else "."
    ans += contribution(r, c)
    print(ans)
```

</PySection>

</LanguageSection>