---
id: usaco-642
source: USACO Silver 2016 US Open
title: Field Reduction
author: Sachet Abeysinghe
---

[Official Analysis (C++)](https://usaco.org/current/data/sol_reduce_silver_open16.html)

## Explanation

To start, consider the problem without removing three cows. The minimum area of the enclosing fence is the product of the difference between the largest x-coordinate and smallest x-coordinate and the difference between the largest y-coordinate and smallest y-coordinate.

To reduce this bounding box, we must remove the cows near the four boundaries of the rectangle. Since we can only remove at most three cows, we should only consider the three extremes on each direction. That means our candidates include the three cows with the smallest x-values, the three with the largest x-values, the three with the smallest y-values, and the three with the largest y-values. This candidate set thus includes no more than twelve cows. Finally, we can simply brute force removing all combinations of three candidates and find the minimum enclosing rectangle of the new set of coordinates.

Note that removing less than three cows is not beneficial, as removing one more cow will either decrease the area or make it stay the same.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <vector>
#include <set>

using namespace std;

int main(){
    int n; cin >> n;

    vector<pair<int, int>> cows(n);
    
    vector<int> xs(n);
    vector<int> ys(n);
    
    for (int i = 0; i < n; i++){
        int x, y; cin >> x >> y;
        cows[i] = {x,y};
        
        xs[i] = x;
        ys[i] = y;
    }

    sort(xs.begin(), xs.end());
    sort(ys.begin(), ys.end());

    vector<int> candinates;
    for (int i = 0; i < n; i++){
        auto [x1, y1] = cows[i];
        
        // the 3 most extreme in any of the 4 directions.
        if (x1 <= xs[3] || x1 >= xs[n-3] || y1 <= ys[2] || y1 >= ys[n-3]){
            candinates.push_back(i);
        }
    }
    
    // Generating subsets with bitmasks
    int bestArea = INT32_MAX;
    for (int i = 0; i <= 1 << candinates.size(); i++){
        set<int> removing;
        for (int b = 0; b < candinates.size(); b++){
            if (i&(1<<b)) removing.insert(candinates[b]);
        }
        if (removing.size() != 3) continue;
        
        // Compute area
        int minX = INT32_MAX;
        int maxX = INT32_MIN;
        int minY = INT32_MAX;
        int maxY = INT32_MIN;
        for (int i = 0; i < cows.size(); i++){
            if (removing.count(i)) continue;
            
            minX = min(minX, cows[i].first);
            maxX = max(maxX, cows[i].first);
            minY = min(minY, cows[i].second);
            maxY = max(maxY, cows[i].second);
        }
    
        bestArea = min(bestArea, (maxX-minX)*(maxY-minY));
    }

    cout << bestArea;
}
```

</CPPSection>

<PySection>

```py
import itertools

with open("reduce.in") as read:
	n = int(read.readline())
	coordinates = [tuple(map(int, read.readline().split())) for i in range(n)]

sort_by_x = sorted(coordinates)
sort_by_y = sorted(coordinates, key=lambda coord: coord[1])
candidates = sort_by_x[:3] + sort_by_x[-3:] + sort_by_y[:3] + sort_by_y[-3:]
min_area = float("inf")

for removed in itertools.combinations(candidates, 3):
	new_coords = [c for c in coordinates if c not in removed]
	x_coords = [coord[0] for coord in new_coords]
	y_coords = [coord[1] for coord in new_coords]
	area = (max(x_coords) - min(x_coords)) * (max(y_coords) - min(y_coords))
	min_area = min(min_area, area)

print(min_area, file=open("reduce.out", "w"))
```

</PySection>

</LanguageSection>
