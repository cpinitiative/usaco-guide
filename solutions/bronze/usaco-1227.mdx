---
id: usaco-1227
source: USACO Bronze 2022 US Open
title: Photoshoot
author: Kevin Sheng, David Guo
---

[Official Analysis (C++, Java, and Python)](http://usaco.org/current/data/sol_prob1_bronze_open22.html)

## Explanation

We want to maximize the number of Guernseys in even positions. Looking at pairs of adjacent cows, HH contributes nothing, GG always contributes one, and GH/HG can contribute one depending on its orientation. We only consider adjacent pairs with the first cow being in an odd position to avoid overlapping. We say a mixed GH/HG pair is *aligned* if it is HG and *misaligned* if it is GH.

Since reversing a prefix flips the orientation of all earlier pairs, we can iterate through pairs from right to left, keeping track of whether our flips have switched the orientation or not.

If a mixed pair is already aligned under the current orientation, we leave it. Otherwise, we must flip it. A pair is misaligned exactly when its Guernsey ends up on an odd position under the current parity of flips. Each flip is both necessary and sufficient, so the number of times we need to flip misaligned pairs is exactly the minimum number of reversals needed.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <cassert>
#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

int main() {
	int cow_num;
	string cows;
	std::cin >> cow_num >> cows;
	assert(cows.size() == cow_num && cow_num % 2 == 0);

	int flips = 0;
	for (int c = cow_num - 2; c >= 0; c -= 2) {
		string sub = cows.substr(c, 2);
		if (sub[0] == sub[1]) { continue; }
		if ((sub == "GH" && flips % 2 == 0) || (sub == "HG" && flips % 2 == 1)) {
			flips++;
		}
	}

	cout << flips << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;

public class Photoshoot {
	public static void main(String[] args) throws IOException {
		BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
		int cowNum = Integer.parseInt(read.readLine());
		String cows = read.readLine();
		assert cows.length() == cowNum && cowNum % 2 == 0;
		read.close();

		int flips = 0;
		for (int c = cowNum - 2; c >= 0; c -= 2) {
			String sub = cows.substring(c, c + 2);
			if (sub.charAt(0) == sub.charAt(1)) { continue; }
			if ((sub.equals("GH") && flips % 2 == 0) ||
			    (sub.equals("HG") && flips % 2 == 1)) {
				flips++;
			}
		}

		System.out.println(flips);
	}
}
```

</JavaSection>
<PySection>

```py
cow_num = int(input())
cows = input()
assert len(cows) == cow_num and cow_num % 2 == 0

flips = 0
for c in range(cow_num - 2, -1, -2):
	sub = cows[c : c + 2]
	if sub[0] == sub[1]:
		continue
	if (sub == "GH" and flips % 2 == 0) or (sub == "HG" and flips % 2 == 1):
		flips += 1

print(flips)
```

</PySection>
</LanguageSection>
