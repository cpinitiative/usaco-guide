---
id: usaco-1088
source: USACO Silver 2021 January
title: Spaced Out
author: Melody Yu (Video), Tyler Xiao (Video), Maggie Liu
---

## Hint

<Spoiler title="Hint">

Look at the two following possible configurations:

```
C.C.   C..C
.C.C   .CC.
.C.C   C..C
C.C.   .CC.
```

Do you see anything interesting?

</Spoiler>

<Spoiler title="Answer to Hint">

Check out the rows of the first example, and the columns of the second.

Some pattern is definitely at play!

</Spoiler>

## Solution

[Official Analysis (C++ and Java)](http://usaco.org/current/data/sol_prob3_silver_jan21.html)


<Spoiler title="Solution">

### Explanation

The key idea is that in any valid arrangement, either every row alternates between cow and no-cow, or every column alternates between cow and no-cow.

<Spoiler title = "Proof">

If no two cows are adjacent, the claim holds trivially—both rows and columns will alternate in this case.

Otherwise, suppose there exist two cows positioned next to each other. Without loss of generality, assume they are placed horizontally:

```
?????
?CC??
?????
?????
?????
```

The only way to consistently fill the columns containing these two cows is by alternating cow and no-cow entries:

```
?..??
?CC??
?..??
?CC??
?..??
```

Next, we must fill in the remaining columns. Begin with a column adjacent to one that is already filled. We observe that these too must alternate between cow and no-cow; failing to do so inevitably creates a 2 by 2 block with exactly 1 or 3 cows, which is invalid. This same reasoning applies inductively to all remaining columns. Hence, the claim follows.

```
C..C.
.CC.C
C..C.
.CC.C
C..C.
```

</Spoiler>

To solve the problem, we only need to check both scenarios—either rows alternate or columns alternate.
For each row (or column), there are only two possible alternating patterns, so we pick the arrangement that maximizes beauty.

### Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
using namespace std;

const int MAX_N = 1000;
int grid[MAX_N][MAX_N];

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) { cin >> grid[i][j]; }
	}
	// max beauty if each row alternates between cow and no cow
	int rows_alternate = 0;
	// max beauty if each column alternates
	int cols_alternate = 0;

	// each row has an alternating pattern of cow and no cow
	for (int i = 0; i < n; i++) {
		int sum[2]{};
		// there are two ways to alternate, odd index and even index
		for (int j = 0; j < n; j++) { sum[j % 2] += grid[i][j]; }
		rows_alternate += max(sum[0], sum[1]);
	}

	// each column has an alternating pattern of cow and no cow
	for (int i = 0; i < n; i++) {
		int sum[2]{};
		// two ways to alternate
		for (int j = 0; j < n; j++) { sum[j % 2] += grid[j][i]; }
		cols_alternate += max(sum[0], sum[1]);
	}

	cout << max(rows_alternate, cols_alternate) << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class SpacedOut {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		int n = io.nextInt();
		int[][] grid = new int[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) { grid[i][j] = io.nextInt(); }
		}
		// max beauty if each row alternates between cow and no cow
		int rowsAlternate = 0;
		// max beauty if each column alternates
		int colsAlternate = 0;
		// each row has an alternating pattern of cow and no cow
		for (int i = 0; i < n; i++) {
			int[] sum = new int[2];
			// there are two ways to alternate, odd index and even index
			for (int j = 0; j < n; j++) { sum[j % 2] += grid[i][j]; }
			rowsAlternate += Math.max(sum[0], sum[1]);
		}

		// each column has an alternating pattern of cow and no cow
		for (int i = 0; i < n; i++) {
			int[] sum = new int[2];
			// two ways to alternate
			for (int j = 0; j < n; j++) { sum[j % 2] += grid[j][i]; }
			colsAlternate += Math.max(sum[0], sum[1]);
		}
		io.println(Math.max(rowsAlternate, colsAlternate));
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
n = int(input())
# grid_by_rows[i] is the ith row
grid_by_rows = [list(map(int, input().split())) for _ in range(n)]
# grid_by_cols[i] is the ith column
grid_by_cols = zip(*grid_by_rows)

rows_alternate = 0  # max beauty if each row alternates between cow and no cow
cols_alternate = 0  # max beauty if each column alternates

for i in range(n):
	# each row has an alternating pattern of cow and no cow
	row = grid_by_rows[i]  # the ith row
	# row[::2] is a list of every other element, starting with index 0
	# row[1::2] is a list of every other element, starting with index 1
	rows_alternate += max(sum(row[::2]), sum(row[1::2]))

	# each column has an alternating pattern of cow and no cow
	col = next(grid_by_cols)  # the ith column
	cols_alternate += max(sum(col[::2]), sum(col[1::2]))

print(max(rows_alternate, cols_alternate))
```

</PySection>
</LanguageSection>

</Spoiler>

## Video Solution

By Maggie Liu

<YouTube id="u6Qlpo9qgvg" />
