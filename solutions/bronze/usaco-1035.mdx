---
id: usaco-1035
source: USACO Bronze 2020 US Open
title: Social Distancing I
author: Aarav Sethi
---

[Official Analysis](https://usaco.org/current/data/sol_socdist1_bronze_open20.html)

## Explanation
The sample testcase can be solved by fitting two cows in the two largest gaps.
**ex.** `10001001000010` -> `10[1]010010[1]0010`.

However, this strategy isn't optimal for cases like `1000001`. We can use casework to consider each case separately.

All the cases are:
1. `100010001` - Place two cows in the two largest gaps.
2. `10000001` - Fit two cows within the $1/3$ and $2/3$ marks of the largest gap.
3. `00001000` - Place at the two far edges.
4. `10000000`/`00000001` - Place a cow in one of the far edges, and one in the largest gap.

We can now test all of these cases, and maximize $D$.

## Implementation
**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>
```cpp
#include <bits/stdc++.h>

using namespace std;

int compute_D(string stalls) {
	int d = INT32_MAX;
	int last1 = -1;

	for (int i = 0; i < stalls.length(); i++) {
		if (stalls[i] == '1') {
			if (last1 != -1) d = min(d, i - last1);
			last1 = i;
		}
	}

	return d;
}
pair<int, int> get_largest_zeros(string stalls) {
	// we can then get the two with maximum (end-start)
	pair<int, int> largestZero = {-1, -1};

    // get sizes
	int zeros_start = -1;
	for (int i = 0; i < stalls.size(); i++) {
		// if entered a '0' and not already counting, start counting
		if (stalls[i] == '0' && zeros_start == -1) { zeros_start = i; }

		// hit a '1' & we have counted some zeros, or we have reached the end
		if ((stalls[i] == '1' && zeros_start != -1) || i == stalls.size() - 1) {
			// insert the zero sequence
			pair<int, int> zero = {zeros_start, i};
            if ((zero.second-zero.first) > (largestZero.second-largestZero.first)){
                largestZero = zero;
            }
			zeros_start = -1;
		}
	}

	return largestZero;
}

int main() {
	int n;
	cin >> n;
	string stalls;
	cin >> stalls;

	auto largest = get_largest_zeros(stalls);

	int d = 0;
	if (largest.first != -1) {
		// 100010001
		// place at the most spaced locations
		string c = stalls;

        c[(largest.first + largest.second) / 2] = '1';
	    
        auto nextLargest = get_largest_zeros(c);
        c[(nextLargest.first + nextLargest.second) / 2] = '1';

		d = max(d, compute_D(c));
	}
	if (largest.first != -1) {
		// 100000001
		// place one at 1/3 and one at 2/3
		int gap = largest.second - largest.first;

		string c = stalls;
		c[largest.first + gap / 3] = '1';
		c[largest.first + (gap * 2) / 3] = '1';

		d = max(d, compute_D(c));
	}
	if (stalls[0] == '0' && stalls[stalls.size() - 1] == '0') {
		// 000010000
		// place at two edges
		string c = stalls;
		c[0] = '1';
		c[stalls.size() - 1] = '1';

		d = max(d, compute_D(c));
	}
	if (stalls[0] == '0') {
		// 00010001
		// place at furthest point & within largest zero
		string c = stalls;
		c[0] = '1';

		auto nextLargest = get_largest_zeros(c);
		c[(nextLargest.first + nextLargest.second) / 2] = '1';

		d = max(d, compute_D(c));
	}
	if (stalls[stalls.size() - 1] == '0') {
		// 10010000
		// place at furthest point & within largest zero
		string c = stalls;
		c[stalls.size() - 1] = '1';

		auto nextLargest = get_largest_zeros(c);
		c[(nextLargest.first + nextLargest.second) / 2] = '1';

		d = max(d, compute_D(c));
	}

	cout << d << "\n";
}
```
</CPPSection>

</LanguageSection>
