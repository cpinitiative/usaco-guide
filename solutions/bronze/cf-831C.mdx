---
id: cf-831C
source: CF
title: Jury Marks
author: Danh Ta Chi Thanh, Brad Ma, David Guo
---

[Official Editorial](https://codeforces.com/blog/entry/53302)

## Explanation

Observe that we are given all of the jury's marks in chronological order. Therefore, if we knew the participant's initial score, we could compute the participant's announced score after each of the $k$ judges gives their respective ratings.

This motivates us to use prefix sums. Consider the prefix sum array $S$ such that $S[i]$ equals the sum of the first $i$ jury marks.

Now consider the value $b_1$, the first of the values that Polycarp remembers being announced. Letting the initial score be denoted by $I$, we observe that $b_1 = I + S[i]$ for some $i$ from $1$ to $k$. Thus, we must have that $I = b_1 - S[i]$ for some $i$. We can then iterate through $i$ to find our candidates for the participant's initial score.

Now, we must check if each of our candidates is an actually valid starting score. Recall that Polycarp remembers some of the announced scores, all of which were the participant's score at some point. Therefore, if we arbitrarily pick one of our candidate values, say $C$, then the set of values of the form $C + S[i]$ for $i$ ranging from $1$ to $k$ must contain all of Polycarp's remembered scores.

Thus, we check if each candidate yields a valid starting score, and use the count of valid candidates to compute our answer.

## Implementation

**Time Complexity:** $\mathcal{O}(K^2 \log K)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int mark_num;
	int remember_num;
	cin >> mark_num >> remember_num;

	// All net changes in the score
	vector<int> changes(mark_num + 1);
	vector<int> scores(remember_num);
	for (int i = 1; i <= mark_num; ++i) {
		cin >> changes[i];
		changes[i] += changes[i - 1];
	}
	for (int &p : scores) { cin >> p; }

	set<int> poss_starts;
	for (int m = 1; m <= mark_num; ++m) {
		poss_starts.insert(scores.front() - changes[m]);
	}

	int ans = 0;
	for (int s : poss_starts) {
		// What all the scores are going to now be given the starting score
		set<int> points;
		for (int i = 1; i <= mark_num; ++i) { points.insert(s + changes[i]); }

		bool valid = true;
		for (int p : scores) { valid &= points.count(p); }

		ans += valid;
	}
	cout << ans << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class JuryMarks {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		int numJury = io.nextInt();
		int numScores = io.nextInt();
		// All net changes in the score
		int[] changes = new int[numJury + 1];
		int[] scores = new int[numScores];

		for (int x = 1; x <= numJury; x++) {
			changes[x] = io.nextInt() + changes[x - 1];
		}
		for (int x = 0; x < numScores; x++) { scores[x] = io.nextInt(); }

		Set<Integer> possStarts = new TreeSet<>();
		for (int x = 1; x <= numJury; x++) { possStarts.add(scores[0] - changes[x]); }

		int validStarts = 0;
		for (int s : possStarts) {
			// What all the scores are going to now be given the starting score
			Set<Integer> points = new TreeSet<>();
			for (int i = 1; i <= numJury; i++) { points.add(s + changes[i]); }

			boolean valid = true;
			for (int p : scores) { valid &= points.contains(p); }

			validStarts += valid ? 1 : 0;
		}
		io.println(validStarts);
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
mark_num, remember_num = [int(i) for i in input().split()]

# All net changes in the score
changes = [0] + [int(i) for i in input().split()]
scores = {int(i) for i in input().split()}
assert mark_num == len(changes) - 1 and len(scores) == remember_num

for i in range(1, len(changes)):
	changes[i] += changes[i - 1]

poss_starts = set()
random_score = next(iter(scores))
for c in range(1, len(changes)):
	poss_starts.add(random_score - changes[c])

valid_starts = 0
for s in poss_starts:
	# What all the scores are going to now be given the starting score
	resulting_scores = set()
	for c in range(1, len(changes)):
		resulting_scores.add(s + changes[c])

	valid_starts += scores.issubset(resulting_scores)

print(valid_starts)
```

</PySection>
</LanguageSection>
