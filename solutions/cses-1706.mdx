---
id: cses-1706
source: CSES
title: School Excursion
author: Brebenel Mihnea
---
## Solution
**Time complexity:** $\mathcal{O}(N\log^2N)$

The solution of the problem is based on DSU ( [Disjoin Set Union](https://usaco.guide/gold/dsu?lang=cpp) )
For example: if 2 and 3 want  the same thing and 3 and 4 want the same think ==> It means that 2, 3 and 4 want the same thing. After we make the components of the DSU, we are going to use their sizes. After that, we need to find out every combination of these sizes. To do that, we gonna use a knapsack DP ( you can find a good tutorial [here](https://usaco.guide/gold/knapsack?lang=cpp)). But it would tale too long to do this, it would take O(N ^ 2) => TLE. In order to speed it up, we gonna use a bitset as a knpasack.


```cpp
#include <bitset>
#include <iostream>
#include <vector>

using namespace std;

const int NMAX = 2e5;

int n, m;

class DSU {  // Disjoint Set Union
  private:
	int t[NMAX], sz[NMAX];

  public:
	DSU() {
		for (int i = 1; i < NMAX; i++) {
			t[i] = i;
			sz[i] = 1;
		}
	}
	int FindSize(int x) { return sz[FindRoot(x)]; }
	int FindRoot(int x) {
		if (t[x] == x) return x;
		t[x] = FindRoot(t[x]);
		return t[x];
	}
	void unite(int x, int y) {
		x = FindRoot(x), y = FindRoot(y);
		sz[y] += sz[x];
		t[x] = y;
	}
} ds;

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d %d", &x, &y);
		ds.unite(x, y);
	}
	vector<int> sizes;
	for (int i = 1; i <= n; i++) {
		if (ds.FindRoot(i) != i) continue;
		sizes.push_back(ds.FindSize(i));
	}

	bitset<100003> dp;
	dp[0] = 1;
	for (auto sz : sizes) dp |= dp << sz;

	// The above line shifts the knapsack to the right by sz bits

	for (int i = 1; i <= n; i++) cout << dp[i];
	puts("");

	return 0;
}
```
