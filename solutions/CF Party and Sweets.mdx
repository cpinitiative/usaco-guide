---
id: cf-1158A
source: CF
title: The Party and Sweets
author: Jesse Choe
---

[Official Editorial](https://codeforces.com/blog/entry/66993)

Let's consider the following example:

```
2 2
0 1
1 0
```

The answer to this example is $-1$ since boy $2$ ends up giving girl $2$ too
many sweets, even if boy $2$ gives girl $2$ the minimum number of sweets he
could possibly give, which is $1$. However, girl $2$ received a maximum of no
sweets, making it impossible.

If a single boy gives more sweets than a girl received, then any arrangement of
sweets is impossible with the constraints. More formally, if

$$
\max(b_1, b_2, \dots, b_{n-1}, b_n) > \min(g_1, g_2, \dots, g_{m-1}, g_m),
$$

then the answer is $-1$.

If the input provided has an arrangement of sweets that follow the given
constraints, then we can greedily find the answer.

Since our objective is to minimize the total sum of sweets, it is optimal to
make each sweet in the arrangement as small as possible. Since the smallest
number of sweets a boy $i$ could give to a girl $j$ is $b_i$. Thus, the minimum number of sweets he could give out in total is $b_i * m$. Thus, the answer to this problem is lower bounded by $\sum\limits_{i=1}^{n} b_i \cdot m$.

We are not done yet, however. The previous sum does not necessarily satisfy the condition
that $g_i$ is the maximum number of sweets a single girl received. Each girl $j$ has some boy $i$ who gave her $g_j$ sweets instead of $b_i$ sweets. This raises our lower bound by $g_j-b_i$. We would like to choose $i$ such that $b_i$ is maximal. Since we know $\max(b) \leq \min(g)$, we would always choose the boy who gives the most sweets.

However, this boy still must give $b_i$ sweets to some girl; thus if no $g_j$ is equal to $b_i$, then he needs to have given some girl $b_i$ sweets and the boy who gives the second most sweets can give this girl her maximal sweets.

**Time Complexity:** $\mathcal{O}(N\log N + M\log M)$

<LanguageSection>

<CPPSection>

### C++ Implementation

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

int main(){

	int n, m; cin >> n >> m;
	vector<int> b(n), g(m);
	ll res = 0;

	for(int i = 0; i < n; i++){
		cin >> b[i];
		res += b[i];
	}

	for(int i = 0; i < m; i++){
		cin >> g[i];
	}

	// The initial sum without accounting for the constraints on the maximum values of g_i
	res *= m;

	// Sort b_i and g_i in descending order to improve the ease of using 2P
	sort(b.begin(), b.end(), greater<int>());
	sort(g.begin(), g.end(), greater<int>());

	int maxB = b[0], minG = g[0];
	for(int i = 1; i < n; i++){
		maxB = max(maxB, b[i]);
	}
	for(int i = 1; i < m; i++){
		minG = min(minG, g[i]);
	}

	// If it's impossible to satisfy the constraints
	if(maxB > minG){
		cout << -1 << endl;
		return 0;
	}

	// Two pointers to find the sum of (g_i - c_i).
	int p1 = 0, p2 = 0, cur = 0;
	while(p2 < m){
		++cur;
		res += (g[p2] - b[p1]);
		if((cur == m - 1 && g[p2 + 1] != b[p1]) || cur == m){
			cur = 0;
			p1++;
		}
		p2++;
	}

	cout << res << endl;
}
```

</CPPSection>

</LanguageSection>
