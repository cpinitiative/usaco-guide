---
id: cses-1144
source: CSES
title: Salary Queries
author: Benjamin Qi, Ã“scar Garries, Jeffrey Zhang
---

## Solution 1

As mentioned in the module, you can apply coordinate compression before using a
segment tree or a BIT.

Stick with arrays (or `vector`s) whenever possible; using a `map` instead may
TLE.

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAX = 4e5 + 5;

ll bit[MAX]; // binary-indexed tree
vector<int> vals; // values sorted for coordinate compression
int n, q;

void add(int value, int amount) {
	int index = upper_bound(vals.begin(), vals.end(), value) - vals.begin();
	for (; index <= MAX; index += index&(-index)) {
		bit[index] += amount;
	}
}

ll sums(int value) {
	int index = upper_bound(vals.begin(), vals.end(), value) - vals.begin();
	ll total = 0;
	for (; index; index -= index&(-index)) {
		total += bit[index];
	}
	return total;
}

int main() {
	cin >> n >> q;
	vector<int> salaries(n); // salaries of n employees
	vector<array<int, 3>> queries; // store the input queries offline

	for (int i = 0; i < n; i++) {
		cin >> salaries[i];
	}
	vals = salaries;
	for (int i = 0; i < q; i++) {
		char t;
		int a, b;
		cin >> t >> a >> b;
		queries.push_back({t == '?', a, b});
		if (t == '!') {
			vals.push_back(b);
		}
	}
	sort(vals.begin(), vals.end());
	vals.erase(unique(vals.begin(), vals.end()), vals.end());
	for (int i = 0; i < n; i++) {
		add(salaries[i], 1);
	}

	for (auto query : queries) {
		query[1]--;
		if (query[0] == 0) {
			add(salaries[query[1]], -1);
			salaries[query[1]] = query[2];
			add(salaries[query[1]], 1);
		} else {
			cout <<  sums(query[2]) - sums(query[1]) << '\n';
		}
	}
}
```

Here is a similar solution with a `map` that passes slightly under the time
limit.

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const int MAX = 1e6 + 5;

int bit[MAX]; // binary-indexed tree
map<int,int> vals; // values sorted for coordinate compression
int N,Q;

void add(int value, int amount) {
	int index = vals[a];
	for (; index <= MAX; index += index&(-index)) {
		bit[index] += amount;
	}
}

int sums(int x) {
	auto it = vals.upper_bound(x);
	int index;
	if (it == end(vals)) {
		index = vals.size();
	}
	else index = it->second-1;
	int total = 0;
	for (; index; index -= index&(-index)) {
		total += bit[index];
	}
	return total;
}

//BeginCodeSnip{setIO}
void setIO() {
	cin.tie(0)->sync_with_stdio(0);
	cout << fixed << setprecision(15);
}
//EndCodeSnip

int main() {
	setIO(); 
	cin >> N >> Q;
	vector<int> salaries(N); // salaries of n employees
	vector<array<int, 3>> queries; // store the input queries offline

	for (int i = 0; i < N; i++){
		cin >> salaries[i];
	}
	for (auto& t: salaries) {
		vals[t] = 0;
	}
	for (int i = 0; i < Q; ++i){
		char t; 
		int a, b; 
		cin >> t >> a >> b;
		queries.push_back({t == '?', a, b});
		if (t == '!') {
			vals[b] = 0;
		}
	}
	int count = 0; 
	for (auto& t: vals) {
		t.second = ++count;
	}
	for (auto& p: salaries){
		add(p, 1);
	}
	for (auto& query: queries) {
		query[1]--;
		if (query[0] == 0) {
			add(salaries[query[1]], -1);
			salaries[query[1]] = query[2];
			add(salaries[query[1]], 1);
		} else {
			cout << sums(query[2]) - sums(query[1]);
		}
	}
}
```

## Solution 2

Just use indexed set!

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

typedef pair<int, int> pii;
template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

const int MOD = 1000000007;

int n,q, a[200001];
Tree<pii> indexed_set;

int main() {
	ios_base::sync_with_stdio(0); 
	cin.tie(0);
	cin >> n >> q;
	for (i = 1; i < n + 1; ++i) {
		cin >> a[i];
		indexed_set.insert({a[i], i});
	}
	for (i = 0; i < Q; ++i) {
		char c; 
		cin >> c;
		if (c == '!') {
			int x, y; 
			cin >> x >> y;
			indexed_set.erase({a[x], x});
			a[x] = y;
			indexed_set.insert({a[x], x});
		} else {
			int x, y;
			cin >> x >> y;
			int a = indexed_set.order_of_key({y,MOD});
			int b = indexed_set.order_of_key({x - 1, MOD});
			cout << a - b << "\n";
		}
	}
}
```
