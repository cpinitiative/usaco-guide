---
id: cses-2073
source: CSES
title: Substring Reversals
author: Ashok Narayan
---

## Explanation


We have to apply `m` reversals. Following a brute force approach leads to $\mathcal{O}(N * M)$. Thus it is not feasible. Instead, we can use **Implicit Treap** along with **Lazy Propogation**.

### What is implicit in this Treap?

In a regular treap, each node stores an explicit key that determines its position in the BST order.
In an implicit treap, there is **no stored key for ordering** â€” the position of each element is computed implicitly using subtree sizes.

The `in-order traversal` (*DFS*) represents the current sequence, and the index of any node is determined by how many nodes exist in its left subtree. This allows us to split and merge by position efficiently without maintaining or updating explicit indices(after applying reversal operations).

To reverse a substring from index $L$ to $R$, we perform the following steps:
1. **Isolate the Substring:** We use the `split` function to divide our Treap into three separate trees: `T1` (elements before index $L$), `T2` (elements from $L$ to $R$), and `T3` (elements after index $R$).
2. **Lazy Reversal:** Physically reversing every node in `T2` would be too slow. Instead, we use a bool, `rev`. We simply toggle this flag at the root of `T2`.
3. **Reassemble:** We use the `merge` function to stitch `T1`, `T2`, and `T3` back together.



Whenever we traverse the tree (during `split`, `merge`, `print`), we call the `push` function on the current node. If the `rev` flag is active, `push` physically swaps the left and right child pointers of the node and passes the `rev` flag down to its children. This delays the actual work until a node absolutely needs to be accessed.

Finally, a `dfs` pushes all remaining lazy updates downwards and prints the final string.


## Implementation

**Time Complexity:** $\mathcal{O}((N + M) \log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{Implicit Treap template}
struct ImplicitTreap {
	struct Node {
		char val;
		int prior, sz;
		bool rev;
		Node *l, *r;
		Node(char v, int p) : val(v), prior(p), sz(1), rev(0), l(nullptr), r(nullptr) {}
	};

	using pNode = Node *;
	mt19937 rng{chrono::steady_clock::now().time_since_epoch().count()};
	pNode root = nullptr;

	int sz(pNode t) { return t ? t->sz : 0; }

	void pull(pNode t) {
		if (t) t->sz = 1 + sz(t->l) + sz(t->r);
	}

	void push(pNode t) {
		if (!t || !t->rev) return;
		swap(t->l, t->r);
		if (t->l) t->l->rev ^= 1;
		if (t->r) t->r->rev ^= 1;
		t->rev = 0;
	}

	void split(pNode t, pNode &l, pNode &r, int k) {
		if (!t) {
			l = r = nullptr;
			return;
		}
		push(t);
		if (sz(t->l) >= k) {
			split(t->l, l, t->l, k);
			r = t;
		} else {
			split(t->r, t->r, r, k - sz(t->l) - 1);
			l = t;
		}
		pull(t);
	}

	pNode merge(pNode l, pNode r) {
		if (!l || !r) return l ? l : r;
		if (l->prior > r->prior) {
			push(l);
			l->r = merge(l->r, r);
			pull(l);
			return l;
		} else {
			push(r);
			r->l = merge(l, r->l);
			pull(r);
			return r;
		}
	}

	void build(const string &s) {
		for (char c : s) root = merge(root, new Node(c, rng()));
	}

	void reverse(int l, int r) {
		pNode t1, t2, t3;
		split(root, t1, t2, l - 1);
		split(t2, t2, t3, r - l + 1);
		if (t2) t2->rev ^= 1;
		root = merge(t1, merge(t2, t3));
	}

	void dfs(pNode t) {
		if (!t) return;
		push(t);
		dfs(t->l);
		cout << t->val;
		dfs(t->r);
	}

	void print() { dfs(root); }
};
// EndCodeSnip

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int n, m, l, r;
	string s;
	cin >> n >> m >> s;

	ImplicitTreap treap;
	treap.build(s);

	while (m--) {
		cin >> l >> r;
		treap.reverse(l, r);
	}

	treap.print();
}
```
</CPPSection>
</LanguageSection>
