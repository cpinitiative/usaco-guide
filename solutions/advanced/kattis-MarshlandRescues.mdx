---
id: kattis-MarshlandRescues
source: Kattis
title: Marshland Rescues
author: Ashok Narayan
---

## Explanation

Each water-logged region is given as a **convex polygon**.  
MAPS wants to know how far a rescuer may need to wade into such a region.

Formally, for a given convex polygon, we must find a point inside it that is **as far as possible from the boundary**, and report that maximum distance.  
This is equivalent to finding the **radius of the largest circle that can be completely inscribed inside the polygon**.

So, the task reduces to computing the **maximum possible minimum distance from a point inside the polygon to all its edges**.

---
### About Half Plane idea

For any fixed distance `d`, we want to check whether there exists a point inside the polygon that is at least `d` away from **every edge**.

For each edge of the convex polygon, this set of points at distance atleast `d` from edge can be represented as a **half-plane** whose boundary line is at distance `d` from edge (*on it's inward side*).

If there exists a common intersection for all these planes, then we can be certain that there is a point that is atleast at distance `d` from **ALL** edges. (Morover, all the points in this intersection satisfy this.)

[Half Plane Intersection](https://codeforces.com/blog/entry/61710)


---
### Solution

For any `d` we know how to **check** if a solution exits. Now we can **Binary Search** on all possible values of `d`. 


---
## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$


<LanguageSection>
<CPPSection>

```cpp


#include <bits/stdc++.h>
using namespace std;

using ld = long double;
const ld EPS = 1e-9, INF = 1e18;


vector<Point> poly;
int n;

// BeginCodeSnip{Point Template}
struct Point{
    ld x,y;
    Point(ld x=0, ld y=0):x(x),y(y){}
    Point operator+(const Point& o) const { return {x+o.x,y+o.y}; }
    Point operator-(const Point& o) const { return {x-o.x,y-o.y}; }
    Point operator*(ld k) const { return {x*k,y*k}; }
    ld dot(const Point& o) const { return x*o.x+y*o.y; }
    ld cross(const Point& o) const { return x*o.y-y*o.x; }
    ld norm() const { return sqrtl(x*x+y*y); }
    Point rot90() const { return {-y,x}; }
};
// EndCodeSnip

//BeginCodeSnip{Half Plane Template}
struct HalfPlane{
    Point p,dir;
    ld ang;
    HalfPlane(){}
    HalfPlane(Point a, Point b):p(a),dir(b-a){
        ang=atan2l(dir.y,dir.x);
    }
    bool outside(const Point& r) const {
        return dir.cross(r-p)<-EPS;
    }
};

Point intersect(const HalfPlane& a, const HalfPlane& b){
    ld t=(b.p-a.p).cross(b.dir)/a.dir.cross(b.dir);
    return a.p+a.dir*t;
}

vector<Point> halfPlaneIntersection(vector<HalfPlane>& h){
    vector<Point> box={{INF,INF},{-INF,INF},{-INF,-INF},{INF,-INF}};
    for(int i=0;i<4;i++) h.emplace_back(box[i],box[(i+1)%4]);

    sort(h.begin(),h.end(),[](auto& a, auto& b){return a.ang<b.ang;});
    deque<HalfPlane> dq;

    for(auto& hp:h){
        while(dq.size()>1 && hp.outside(intersect(dq.back(),dq[dq.size()-2]))) dq.pop_back();
        while(dq.size()>1 && hp.outside(intersect(dq[0]    ,dq[1]          ))) dq.pop_front();

        if(!dq.empty() && fabsl(hp.dir.cross(dq.back().dir))<EPS){
            if(hp.dir.dot(dq.back().dir)<0) 
				return {};
            
			if(hp.outside(dq.back().p)) dq.pop_back();
            else continue;
        }
        dq.push_back(hp);
    }

    while(dq.size()>2 && dq[0].outside(intersect(dq.back(),dq[dq.size()-2]))) dq.pop_back();
    while(dq.size()>2 && dq.back().outside(intersect(dq[0],dq[1]))) dq.pop_front();
    if(dq.size()<3) return {};

    vector<Point> poly(dq.size());
    for(int i=0;i+1<(int)dq.size();i++) poly[i]=intersect(dq[i],dq[i+1]);
    poly.back()=intersect(dq.back(),dq[0]);
    return poly;
}
// EndCodeSnip

// BeginCodeSnip{Check function for Binary Seach}
bool ok(ld d){
    vector<HalfPlane> h;
    for(int i=0;i<n;i++){
        Point a=poly[i], b=poly[(i+1)%n];
        Point nrm=(b-a).rot90();
        nrm=nrm*(d/nrm.norm());
        h.emplace_back(a+nrm,b+nrm);
    }
    return !halfPlaneIntersection(h).empty();
}
// EndCodeSnip

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>n;
    poly.resize(n);
    for(auto& p:poly) cin>>p.x>>p.y;

    ld lo=0, hi=1e5;
    for(int i=0;i<300;i++){
        ld mid=(lo+hi)/2;
        if(ok(mid)) lo=mid;
        else hi=mid;
    }

    cout << fixed << setprecision(12) << lo << '\n';
}

```

</CPPSection>
</LanguageSection>
