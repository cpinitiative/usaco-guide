---
id: spoj-got
source: SPOJ
title: Gao on a tree
author: Nigar Hajiyeva
---
## Explanation
This solution builds a persistent segment tree for each node in the tree that keeps track of how many times each value appears on the path from the root to that node. We start by building the persistent segment tree for the root node with all frequencies set to zero. Then, for each child node, we create a new version of its parent’s segment tree and update it by increasing the count of the child’s value. This way, we avoid rebuilding the whole tree every time and only update the parts that need to change.

To answer a query asking if a value $c$ appears on the path between nodes $a$ and $b$, we first find their lowest common ancestor (LCA). Since each node’s persistent segment tree counts the frequencies of values from the root down to that node, the number of times $c$ appears on the path from $a$ to $b$ can be found by adding the frequency of the value c from $a$ and $b$, subtracting twice the frequencies from the LCA (to avoid double counting), and then checking if the LCA itself has value $c$. If the total frequency of the value $c$ is greater than zero, the value exists on the path; otherwise, it does not.

This approach uses persistent segment trees and LCA together to quickly answer path queries in large trees without rebuilding data structures from scratch.

## Implementation

**Time Complexity:** $\mathcal{O}((N+M) \cdot \log{N})$

<LanguageSection>
<CPPSection>

```cpp
#include "bits/stdc++.h"
using namespace std;

// Maximum number of vertices in the tree
const int MAX_NODES_GRAPH = 1e5;

struct PersistentSegmentTree {
    int node_counter = 0;

    // Maximum number of nodes in the persistent segment tree
    static const int MAX_NODES_PERSISTENT_TREE = 2e6;

    // Arrays representing the structure of the segment tree
    int left_chLild[MAX_NODES_PERSISTENT_TREE + 1];
    int right_child[MAX_NODES_PERSISTENT_TREE + 1];

    // Frequency of values at positions
    int frequency[MAX_NODES_PERSISTENT_TREE + 1];   

    // Resets the segment tree for a new test case
    void reset() {
        node_counter = 0;
        memset(frequency, 0, sizeof(frequency));  
    }

    // Builds the initial empty segment tree  
    int build(int v, int l, int r) {
        int new_node = ++node_counter;
        if (l == r) return new_node;
        int m = (l + r) / 2;
        left_chLild[new_node] = build(new_node, l, m);
        right_child[new_node] = build(new_node, m + 1, r);
        return new_node;
    }

    // Creates a new version of the tree with the new value inserted
    int update(int node, int left, int right, int index) {
        int new_node = ++node_counter;
        if (left == right) {
            frequency[new_node] = frequency[node] + 1;
            return new_node; 
        }
        left_chLild[new_node] = left_chLild[node];
        right_child[new_node] = right_child[node];

        int middle = (left + right) / 2;
        if (index <= middle) left_chLild[new_node] = update(left_chLild[node], left, middle, index);
        else right_child[new_node] = update(right_child[node], middle + 1, right, index);
        return new_node;
    }

    // Returns the frequency of value `k` on the path from a to b  
    int query(int a, int b, int anc, int left, int right, int k) {
        if (left == right) {
            int cnt = frequency[a] + frequency[b] - 2 * frequency[anc];
            return cnt;
        }
        int middle = (left + right) / 2;
        if (k <= middle) return query(left_chLild[a], left_chLild[b], left_chLild[anc], left, middle, k);
        else return query(right_child[a], right_child[b], right_child[anc], middle + 1, right, k);
    }
};

PersistentSegmentTree pst;

struct Tree {
    int LOG, timer = 0;

    // LCA and DFS helpers
    int roots[MAX_NODES_GRAPH + 1];
    int tin[MAX_NODES_GRAPH + 1], tout[MAX_NODES_GRAPH + 1];

     // Compressed values assigned to each node
    int value[MAX_NODES_GRAPH + 1];

    // Binary lifting ancestors
    vector<vector<int>> up;         
    vector<int> graph[MAX_NODES_GRAPH + 1];

    Tree(int n) {
        timer = 0;
        LOG = ceil(log2(n));
        up.assign(n + 1, vector<int>(LOG + 1, 0));
    }

    // DFS to set up binary lifting + persistent segment tree roots
    void dfs(int from, int parent) {
        int root = roots[parent]; // Copy parent’s tree version
        root = pst.update(root, 1, MAX_NODES_GRAPH, value[from]); // Insert current node value
        roots[from] = root;

        tin[from] = ++timer;
        up[from][0] = (from == 1 ? from : parent); // Binary lifting base case
        for (int i = 1; i < LOG; i++) {
            up[from][i] = up[up[from][i - 1]][i - 1];
        }

        for (int to : graph[from]) {
            if (to != parent) dfs(to, from);
        }
        tout[from] = timer;
    }

    // Check if u is an ancestor of v using tin/tout
    bool is_ancestor(int u, int v) {
        return tin[u] <= tin[v] && tout[u] >= tout[v];
    }

    // Lowest Common Ancestor using binary lifting
    int lca(int u, int v) {
        if (is_ancestor(u, v)) return u;
        if (is_ancestor(v, u)) return v;
        for (int i = LOG - 1; i >= 0; i--) {
            if (!is_ancestor(up[u][i], v)) u = up[u][i];
        }
        return up[u][0];
    }
};

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int n, m;

    // Handle multiple test cases until EOF
    while (cin >> n >> m) {
        pst.reset();  // Clear the segment tree for new test case
        Tree tree(n);

        vector<int> compressed_values;
        compressed_values.push_back(-INT_MAX);  

        // Read values for each node and prepare for compression
        for (int i = 1; i <= n; i++) {
            cin >> tree.value[i];
            tree.graph[i].clear();
            compressed_values.push_back(tree.value[i]);
        }

        // Coordinate compression
        sort(compressed_values.begin(), compressed_values.end());
        compressed_values.resize(unique(compressed_values.begin(), compressed_values.end()) - compressed_values.begin());

        for (int i = 1; i <= n; i++) {
            tree.value[i] = lower_bound(compressed_values.begin(), compressed_values.end(), tree.value[i]) - compressed_values.begin();  
        }

        // Read tree edges
        for (int i = 1; i < n; i++) {
            int a, b;
            cin >> a >> b;
            tree.graph[a].push_back(b);
            tree.graph[b].push_back(a);
        }

        // Build initial tree (empty version 0)
        tree.roots[0] = pst.build(pst.node_counter, 1, MAX_NODES_GRAPH);

        // DFS from root to build all PST versions and LCA structure
        tree.dfs(1, 0);

        // Handle all queries
        for (int i = 0; i < m; i++) {
            int a, b, k;
            cin >> a >> b >> k;

            // Check if the value exists in compressed list
            auto location = lower_bound(compressed_values.begin(), compressed_values.end(), k);
            if (location == compressed_values.end() || (*location) != k) {
                cout << "NotFind\n";
                continue;
            }

            // Map the value to its compressed position
            k = location - compressed_values.begin();

            int common = tree.lca(a, b);

            // If LCA is equal to the value k, answer is yes
            if (tree.value[common] == k) {
                cout << "Find\n";
                continue;
            }

            // Otherwise, query frequency of value `k` on path from a to b
            if (pst.query(tree.roots[a], tree.roots[b], tree.roots[common], 1, MAX_NODES_GRAPH, k)) {
                cout << "Find\n";
            } else {
                cout << "NotFind\n";
            }
        }
    }
}
 
```

</CPPSection>
</LanguageSection>
