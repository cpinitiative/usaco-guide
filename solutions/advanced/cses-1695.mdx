---
id: cses-1695
source: CSES
title: Police Chase
author: Dong Liu, Ayush Shukla
---

**Time Complexity**: $\mathcal O(N^3)$

First, we run a max flow algorithm on the graph. Then, we run another BFS from
node $1$. If node $a$ is reachable but node $b$ is not and there was an edge
$a\rightarrow b$, then we know that edge must be removed.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using vi = vector<int>;
#define f first
#define s second
#define pb push_back
#define all(x) begin(x), end(x)

#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FOR(i, a, b) for (int i = (a); i <= (b); i++)
#define R0F(i, a) for (int i = (a) - 1; i >= 0; i--)
#define ROF(i, a, b) for (int i = (b); i >= a; i--)
#define trav(a, x) for (auto &a : x)

int n, m;
ll adj[501][501], oadj[501][501];

ll flow[501];
bool V[501];
int pa[501];
using pii = pair<int, int>;
vector<pii> ans;

bool reachable() {
	memset(V, false, sizeof(V));
	queue<int> Q;
	Q.push(1);
	V[1] = 1;
	while (!Q.empty()) {
		int i = Q.front();
		Q.pop();
		FOR(j, 1, n) if (adj[i][j] && !V[j]) V[j] = 1, pa[j] = i, Q.push(j);
	}
	return V[n];
}

int main() {
	cin >> n >> m;
	FOR(i, 1, n) FOR(j, 1, n) adj[i][j] = oadj[i][j] = 0;
	F0R(i, m) {
		ll a, b;
		cin >> a >> b;
		adj[a][b]++, adj[b][a]++;
		oadj[a][b]++, oadj[b][a]++;
	}
	int v, u;
	while (reachable()) {
		ll flow = 1e18;
		for (v = n; v != 1; v = pa[v]) {
			u = pa[v];
			flow = min(flow, adj[u][v]);
		}
		for (v = n; v != 1; v = pa[v]) {
			u = pa[v];
			adj[u][v] -= flow;
			adj[v][u] += flow;
		}
	}
	reachable();
	FOR(i, 1, n) FOR(j, 1, n) if (V[i] && !V[j] && oadj[i][j]) ans.pb({i, j});
	cout << ans.size() << '\n';
	trav(a, ans) cout << a.f << " " << a.s << '\n';
}
```

</CPPSection>

<JavaSection>
```java
import java.util.*;

public class PoliceChase {
    static final int N = 500;
    static int n, m;
    static int[] lev = new int[N];
    static int[][] c = new int[N][N];
    static int[] seen = new int[N];
    static Queue<Integer> q = new LinkedList<>();

    // BFS to find level of each node
    static boolean bfs() {
        Arrays.fill(lev, 0, n, -1);  // Reset levels
        lev[0] = 0;
        q.add(0);
        while (!q.isEmpty()) {
            int u = q.poll();
            for (int v = 0; v < n; ++v) {
                if (lev[v] == -1 && c[u][v] > 0) {
                    lev[v] = lev[u] + 1;
                    q.add(v);
                }
            }
        }
        return lev[n - 1] != -1;
    }

    // DFS to find augmenting paths
    static boolean dfs(int u) {
        if (u == n - 1) return true;
        for (; seen[u] < n; ++seen[u]) {
            int v = seen[u];
            if (lev[v] == lev[u] + 1 && c[u][v] > 0 && dfs(v)) {
                c[u][v]--;
                c[v][u]++;
                return true;
            }
        }
        return false;
    }

    // DFS to mark reachable nodes
    static void dfs2(int u) {
        lev[u] = 1;
        for (int v = 0; v < n; ++v) {
            if (lev[v] == 0 && c[u][v] > 0) {
                dfs2(v);
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();

        for (int i = 0; i < m; ++i) {
            int u = sc.nextInt() - 1;
            int v = sc.nextInt() - 1;
            c[u][v]++;
            c[v][u]++;
        }

        while (bfs()) {
            Arrays.fill(seen, 0, n, 0);
            while (dfs(0));
        }

        Arrays.fill(lev, 0, n, 0);
        dfs2(0);

        List<int[]> rem = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (lev[i] == 1 && lev[j] == 0 && c[j][i] > 0) {
                    rem.add(new int[]{i, j});
                }
            }
        }

        System.out.println(rem.size());
		for (int[] p : rem) {
			System.out.println((p[0] + 1) + " " + (p[1] + 1));
		}
		sc.close();
    }
}
```
</JavaSection>

<PySection>
```py
from collections import deque

N = 500

# Initialize variables
n, m = 0, 0
lev = [-1] * N
c = [[0] * N for _ in range(N)]
seen = [0] * N
q = deque()

def bfs():
    # Reset levels
    for i in range(n):
        lev[i] = -1
    lev[0] = 0
    q.append(0)
    while q:
        u = q.popleft()
        for v in range(n):
            if lev[v] == -1 and c[u][v] > 0:
                lev[v] = lev[u] + 1
                q.append(v)
    return lev[n-1] != -1

def dfs(u):
    if u == n-1:
        return True
    for v in range(seen[u], n):
        seen[u] = v
        if lev[v] == lev[u] + 1 and c[u][v] > 0 and dfs(v):
            c[u][v] -= 1
            c[v][u] += 1
            return True
    return False

def dfs2(u):
    lev[u] = 1
    for v in range(n):
        if lev[v] == 0 and c[u][v] > 0:
            dfs2(v)

# Read input
import sys
input = sys.stdin.read
data = input().split()
n = int(data[0])
m = int(data[1])

index = 2
for _ in range(m):
    u = int(data[index]) - 1
    v = int(data[index + 1]) - 1
    index += 2
    c[u][v] += 1
    c[v][u] += 1

while bfs():
    for i in range(n):
        seen[i] = 0
    while dfs(0):
        pass

for i in range(n):
    lev[i] = 0
dfs2(0)

rem = []
for i in range(n):
    for j in range(n):
        if lev[i] == 1 and lev[j] == 0 and c[j][i] > 0:
            rem.append((i, j))

print(len(rem))
for u, v in rem:
    print(u + 1, v + 1)  # Adjust back to 1-indexed for output

```

</PySection>

</LanguageSection>
