---
id: cses-2187
source: CSES
title: Bracket Sequences II
author: Rameez Parwez
---

## Explanation

First, we check whether the prefix itself is valid or not. If, at any point in the prefix, the number of closing
brackets exceeds the number of opening brackets, then the prefix is invalid. Additionally, we already know
that if $n$ is odd, the result will be zero.

Once we calculated the number of opening and closing brackets in the prefix, we can determine our answer by subtracting the number of invalid arrangements from the total number of ways to arrange the remaining substring. An invalid arrangement occurs when the number of opening brackets is strictly greater than the number of closing brackets.
$$
\binom{n - k}{c} - \binom{n - k}{c + 1}
$$

## Implementation

**Time Complexity:** $\mathcal{O} (N)$

<LanguageSection>

<CPPSection>
```cpp
#include <iostream>

using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 1e6;

long long fac[MAXN + 1];
long long inv[MAXN + 1];

// BeginCodeSnip{Combinatorics Functions (from the module)}
/** @return x^n modulo m in O(log p) time. */
long long exp(long long x, long long n, long long m) {
	x %= m;  // note: m * m must be less than 2^63 to avoid ll overflow
	long long res = 1;
	while (n > 0) {
		if (n % 2 == 1) { res = res * x % m; }
		x = x * x % m;
		n /= 2;
	}
	return res;
}

/** Precomputes n! from 0 to MAXN. */
void factorial(long long p) {
	fac[0] = 1;
	for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % p; }
}

/**
 * Precomputes all modular inverse factorials
 * from 0 to MAXN in O(n + log p) time
 */
void inverses(long long p) {
	inv[MAXN] = exp(fac[MAXN], p - 2, p);
	for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % p; }
}

/** @return nCr mod p */
long long choose(long long n, long long r, long long p = MOD) {
	return fac[n] * inv[r] % p * inv[n - r] % p;
}
// EndCodeSnip

int main() {
	long long n;
	string st;
	cin >> n >> st;
	int open = 0, close = 0;
	for (int i = 0; i < (int)st.size(); i++) {
		if (st[i] == '(') {
			open++;
		} else {
			close++;
		}
		if (close > open) {
			cout << 0 << '\n';
			return 0;
		}
	}

	if (n & 1 || open > n / 2) {
		cout << 0 << '\n';
	} else {
		factorial(MOD);
		inverses(MOD);
		long long total = choose(n - open - close, n / 2 - open);
		long long invalid = choose(n - open - close, n / 2 - open - 1);
		long long res = ((total - invalid) % MOD + MOD) % MOD;
		cout << res << '\n';
	}
}
```

</CPPSection>

</LanguageSection>
