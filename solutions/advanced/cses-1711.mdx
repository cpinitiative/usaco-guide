Use this code to solve it. Ford Fulkerson!
---
<LanguageSection>
<CPPSection>

```cpp

#include <bits/stdc++.h>
using namespace std;
 
int n, m, vis[505], cap[505][505], og[505][505];
vector<int> adj[505];
 
// Standard DFS to find path
bool dfs(int u) {
    vis[u] = 1;
    if (u == n) return true;
    for (int v : adj[u]) {
        if (cap[u][v] && !vis[v]) { // If capacity exists and not visited
            if (dfs(v)) {
                cap[u][v]--; // Reduce forward capacity
                cap[v][u]++; // Increase backward capacity
                return true;
            }
        }
    }
    return false;
}
 
int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int u, v; cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // Add reverse edge for flow algorithm
        cap[u][v] = og[u][v] = 1; // Mark capacity and original edge
    }
 
    int k = 0;
    while (true) {
        memset(vis, 0, sizeof(vis));
        if (!dfs(1)) break;
        k++;
    }
 
    cout << k << "\n";
    while (k--) {
        vector<int> path;
        int curr = 1;
        while (true) {
            path.push_back(curr);
            if (curr == n) break;
            for (int v : adj[curr]) {
                // If edge existed originally AND is currently used (capacity 0)
                if (og[curr][v] && cap[curr][v] == 0) {
                    og[curr][v] = 0; // Mark as printed so we don't reuse
                    curr = v;
                    break;
                }
            }
        }
        cout << path.size() << "\n";
        for (int p : path) cout << p << " ";
        cout << "\n";
    }
}
```

</CPPSection>
</LanguageSection>
