---
id: usaco-836
source: USACO Silver 2018 US Open
title: Multiplayer Moo
author: Jesse Choe
---

[Official Analysis](http://www.usaco.org/current/data/sol_multimoo_silver_open18.html)
[Video Analysis(Java)](https://www.youtube.com/watch?v=dCY5EOKyboM)

This problem is an example of a "floodfill", which can be divided into two subproblems.

The first subproblem is to find the maximum number of adjacent cells comprising of the same ID number. To calculate the maximum number of adjacent cells, we can iterate over each cell in the grid and count the maximum number of "connected" cells via a recursive floodfill approach. To avoid recomputation, we can store a boolean array of the cells we "visited" and only run the floodfill on this cell if and only if that cell hasn't been visited.

The second subproblem is to find the maximum number of adjacent cells comprising of exactly two distinct ID numbers (note: if two different ID numbers are adjacent to each other, then they are considered "connected"). To calculate the maximum number of "connected" cells, we can iterate over each cell in the grid and compute this by choosing any two adjacent cells as the ID's. From here, we can run a floodfill and find the maximum number of "connected" cells over all possible cells. As used in the previous subproblem, we can use a boolean array to prevent recomputation.

**Time Complexity:** $\mathcal{O}(N^2)$

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using vl = vector<ll>;
using vb = vector<bool>;
using pl = pair<ll, ll>;
using vpl = vector<pl>;
using vc = vector<char>;
using vs = vector<string>;
using str = string;

#define FastIO ios_base::sync_with_stdio(0); cin.tie(0)
#define pb push_back
#define mp make_pair
#define all(x) begin(x), end(x)
#define sor(x) sort(all(x))
#define ins insert
#define f first
#define s second
#define sz(x) (ll)(x).size()
#define len(x) (ll)(x).length()
#define FOR(i, a, b) for(ll i=a; i<b; ++i)
#define ROF(i, b, a) for(ll i=(b)-1; i>=a; --i)
#define EACH(a, x) for(auto& a: x)
#define lb(a, x) lower_bound(all(a), x) - begin(a)
#define ub(a, x) upper_bound(all(a), x) - begin(a)

void setIO(string fileName = ""){
	FastIO;
	if(len(fileName)){
		freopen((fileName+".in").c_str(), "r", stdin);
		freopen((fileName+".out").c_str(), "w", stdout);
	}
}

ll n, board[250][250], cnt1, cnt2;
bool visited[250][250], visited2[250][250];

void FF(ll i, ll j, ll c){
    if(!visited[i][j]){
        visited[i][j] = true;
        cnt1++;
        if(i > 0 && board[i-1][j] == c){
            FF(i-1, j, c);
        }
        if(j > 0 && board[i][j-1] == c){
            FF(i, j-1, c);
        }
        if(i < n-1 && board[i+1][j] == c){
            FF(i+1, j, c);
        }
        if(j < n-1 && board[i][j+1] == c){
            FF(i, j+1, c);
        }
    }
}

void FF2(ll i, ll j, ll c1, ll c2){
    if(!visited2[i][j] && (board[i][j] == c1 || board[i][j] == c2)){
        visited2[i][j] = true;
        cnt2++;
        if(i > 0){
            FF2(i-1, j, c1, c2);
        }
        if(j > 0){
            FF2(i, j-1, c1, c2);
        }
        if(i < n-1){
            FF2(i+1, j, c1, c2);
        }
        if(j < n-1){
            FF2(i, j+1, c1, c2);
        }
    }
}

int main(){
    setIO("multimoo");
    cin >> n;
    FOR(i, 0, n){
        FOR(j, 0, n){
            cin >> board[i][j];
        }
    }
    ll ans1 = 0, ans2 = 0;
    FOR(i, 0, n){
        FOR(j, 0, n){
            if(visited[i][j]) continue;
            cnt1 = 0;
            FF(i, j, board[i][j]);
            ans1 = max(cnt1, ans1);
        }
    }
    cout << ans1 << endl;
    FOR(i, 1, n){
        FOR(j, 1, n){
            cnt2 = 0;
            if(ans2 == n*n) break;
            if(j > 0 && board[i][j] != board[i][j-1]){
                FF2(i, j, board[i][j], board[i][j-1]);
                ans2 = max(ans2, cnt2);
                cnt2 = 0;
                memset(visited2, false, sizeof(visited2));
            }
        }
    }
    cout << ans2 << endl;
}
```
