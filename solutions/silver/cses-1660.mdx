---
id: cses-1660
source: CSES
title: Subarray Sums I
author: Rameez Parwez
---

## Explanation

This problem can be solved with two pointers.
We increment the left pointer when the sum is too large, and increment the right one when it's too small.
When we have a valid subarray during an iteration, we add one to our answer.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>

int main() {
	int n, x;
	std::cin >> n >> x;
	std::vector<int> arr(n);
	for (int i = 0; i < n; i++) { std::cin >> arr[i]; }

	int i = 0, j = 0;
	int res = 0;
	long long sum = 0;
	while (j < n) {
		sum += arr[j];
		while (sum > x) {
			sum -= arr[i];
			i++;
		}
		res += (sum == x);
		j++;
	}

	std::cout << res << std::endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class SubarraySumsI {
	public static void main(String[] args) {
		Kattio io = new Kattio();
		int n = io.nextInt();
		int x = io.nextInt();

		int[] arr = new int[n];
		for (int i = 0; i < n; i++) { arr[i] = io.nextInt(); }

		int i = 0;
		int j = 0;
		int res = 0;
		long sum = 0;
		while (j < n) {
			sum += arr[j];
			while (sum > x) {
				sum -= arr[i];
				i++;
			}
			res += (sum == x ? 1 : 0);
			j++;
		}

		io.println(res);
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
n, x = map(int, input().split())
arr = list(map(int, input().split()))

i = 0
j = 0
sum, res = 0, 0
while j < n:
	sum += arr[j]
	while sum > x:
		sum -= arr[i]
		i = i + 1

	res += sum == x
	j = j + 1

print(res)
```

</PySection>
</LanguageSection>
