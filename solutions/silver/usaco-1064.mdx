---
id: usaco-1064
source: USACO Silver 2020 December
title: Stuck in a Rut
author: Qi Wang, Melody Yu (Video), Brad Ma, David Guo, David Zhou
---

[Official Analysis (Java)](http://usaco.org/current/data/sol_prob3_silver_dec20.html)

## Video Solution

Note: The video solution might not be the same as other solutions. Code in C++.
<YouTube id="7ZA0MQ9uFr4" />

## Explanation

Suppose we have a cow travelling horizontally at $(x, y)$ and another cow travelling vertically at $(u,v)$. They will intersect at $(u,y)$ given that $x\lt u$ and $v\lt y$. If a cow reaches this point first, then the later cow will be stopped.

However, cows can be stopped before reaching possible intersections with other cows. Thus, we need to sort our cows to process them in a way that avoids this issue. We sort our horizontal-bound cows by increasing vertical values, and we sort our vertical-bound cows by increasing horizontal values. We can then check each pair of cows.
1. If either cow has already been stopped, we can skip this pair.
2. If their paths do not intersect, we can skip this pair.
3. If neither has been stopped and they do intersect, we stop the cow that is further from the intersection.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;

	vector<int> x_coordinates(n);
	vector<int> y_coordinates(n);
	vector<int> east_cows;
	vector<int> north_cows;

	for (int i = 0; i < n; i++) {
		char direction;
		cin >> direction >> x_coordinates[i] >> y_coordinates[i];
		if (direction == 'E') {
			east_cows.push_back(i);
		} else {
			north_cows.push_back(i);
		}
	}

	// sort the east cows by y-coordinate
	sort(east_cows.begin(), east_cows.end(),
	     [&](int a, int b) { return y_coordinates[a] < y_coordinates[b]; });
	// sort the north cows by x-coordinate
	sort(north_cows.begin(), north_cows.end(),
	     [&](int a, int b) { return x_coordinates[a] < x_coordinates[b]; });

	vector<bool> stopped(n);
	vector<int> amount_stopped(n);
	for (int j : east_cows) {  // loop through all pairs of cows
		for (int k : north_cows) {
			/*
			 * make sure that both the east and north cows
			 * are not stopped a collision is only possible
			 * if the x of the north cow is greater
			 * than the x of east cow and the y of the east
			 * cow is greater than the y of the north cow
			 */
			if ((!stopped[j]) && (!stopped[k]) &&
			    (x_coordinates[k] > x_coordinates[j]) &&
			    (y_coordinates[j] > y_coordinates[k])) {
				if ((x_coordinates[k] - x_coordinates[j]) >
				    (y_coordinates[j] - y_coordinates[k])) {
					// the north cow stops the east cow
					// mark the east cow as stopped
					stopped[j] = true;

					// add number of cows that the east cow stops + 1
					amount_stopped[k] += (1 + amount_stopped[j]);
				} else if ((x_coordinates[k] - x_coordinates[j]) <
				           (y_coordinates[j] - y_coordinates[k])) {
					// the east cow stops the north cow
					// mark the north cow as stopped
					stopped[k] = true;

					// add number of cows that the north cow stops + 1
					amount_stopped[j] += (1 + amount_stopped[k]);
				}
				// if difference in x and difference in y is equal,
				// let the cows continue as stated in the problem
			}
		}
	}

	for (int i = 0; i < n; i++) { cout << amount_stopped[i] << '\n'; }
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class StuckInARut {
	static int[] xCoordinates;
	static int[] yCoordinates;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());

		List<Integer> eastCows = new ArrayList<>();
		List<Integer> northCows = new ArrayList<>();
		xCoordinates = new int[n];
		yCoordinates = new int[n];

		for (int i = 0; i < n; i++) {
			StringTokenizer line = new StringTokenizer(br.readLine());
			String direction = line.nextToken();
			if (direction.equals("E")) {
				eastCows.add(i);
			} else {
				northCows.add(i);
			}
			xCoordinates[i] = Integer.parseInt(line.nextToken());
			yCoordinates[i] = Integer.parseInt(line.nextToken());
		}

		// sort the east cows by y-coordinate
		eastCows.sort(Comparator.comparingInt(j -> yCoordinates[j]));
		// sort the north cows by x-coordinate
		northCows.sort(Comparator.comparingInt(j -> xCoordinates[j]));

		boolean[] stopped = new boolean[n];
		int[] amountStopped = new int[n];
		for (int j : eastCows) {  // loop through all pairs of cows
			for (int k : northCows) {
				/*
				 * make sure that both the east and north cows
				 * are not stopped a collision is only possible
				 * if the x of the north cow is greater
				 * than the x of east cow and the y of the east
				 * cow is greater than the y of the north cow
				 */
				if ((!stopped[j]) && (!stopped[k]) &&
				    (xCoordinates[k] > xCoordinates[j]) &&
				    (yCoordinates[j] > yCoordinates[k])) {
					if ((xCoordinates[k] - xCoordinates[j]) >
					    (yCoordinates[j] - yCoordinates[k])) {
						// the north cow stops the east cow
						// mark the east cow as stopped
						stopped[j] = true;

						// add number of cows that the east cow stops + 1
						amountStopped[k] += (1 + amountStopped[j]);
					} else if ((xCoordinates[k] - xCoordinates[j]) <
					           (yCoordinates[j] - yCoordinates[k])) {
						// the east cow stops the north cow
						// mark the north cow as stopped
						stopped[k] = true;

						// add number of cows that the north cow stops + 1
						amountStopped[j] += (1 + amountStopped[k]);
					}
					// if difference in x and difference in y is equal,
					// let the cows continue as stated in the problem
				}
			}
		}

		for (int i = 0; i < n; i++) { System.out.println(amountStopped[i]); }
	}
}
```

</JavaSection>

</LanguageSection>
