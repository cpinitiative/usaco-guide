---
id: usaco-1520
source: USACO Silver 2025 US Open
title: Ski Slope
author: Sachet Abeysinghe
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_prob3_silver_open25.html)

## Explanation

The waypoints and ski runs form a tree rooted at node $1$, since every waypoint has exactly one parent (except the root). Thus, every path from a node to the root is unique. Each edge is assigned a difficulty and enjoyment value, and we must answer $M$ queries to find the maximum total enjoyment for a path from a node to the root, such that at most $c$ edges have difficulty greater than $s$.

We process the tree in increasing node order. We start with node $1$ having difficulties list $[0]$ and total enjoyment $0$. Then, for node $i$, its path to the root is just the parent $p_i$'s path plus the edge $(p_i, i)$. Since $p_i < i$, we can incrementally build the information for node $i$ using what we already computed for its parent.

The key observation is that the condition that at most $c$ edges have difficulty greater than $s$ is equivalent to saying that the $c + 1$th highest difficulty on the path $\le s$. Due to the special constraint $c \le 10$, we only ever need to keep track of the eleven highest difficulties along each path. Any smaller difficulties are irrelevant to whether the constraint is satisfied. For each node, we maintain these top difficulties along with the total enjoyment of the path. For each $c$, we store pairs of the ($c + 1$th largest difficulty, enjoyment) for all nodes and sort them by difficulty. To answer a query $(s, c)$, we binary search the difficulty on the corresponding $c$th list to find the maximum index where the difficulty is at most $s$. The answer is then the maximum enjoyment of the prefix up to that index, which can be found efficiently by precomputing prefix maximums.

## Implementation

**Time Complexity:** $\mathcal{O}(NC\log N+M\log N)$

<LanguageSection>
<PySection>

```py
import bisect
import itertools

n = int(input())
waypoints = [[[0], 0] for i in range(n)]
for waypoint in range(1, n):
	parent, difficulty, enjoyment = map(int, input().split())
	waypoints[waypoint][0] = sorted(waypoints[parent - 1][0][:] + [difficulty])[-11:]
	waypoints[waypoint][1] = waypoints[parent - 1][1] + enjoyment

top_11_difficulties = [[] for i in range(11)]
pref_max = []
for courage in range(11):
	for waypoint in range(1, n):
		if len(waypoints[waypoint][0]) > courage:
			top_11_difficulties[courage].append(
				[waypoints[waypoint][0][-courage - 1], waypoints[waypoint][1]]
			)
	top_11_difficulties[courage].sort()
	pref_max.append(
		list(itertools.accumulate([x[1] for x in top_11_difficulties[courage]], max))
	)

m = int(input())
for friend in range(m):
	skill, courage = map(int, input().split())
	max_enjoyment = 0
	max_index = bisect.bisect(top_11_difficulties[courage], [skill, float("inf")]) - 1
	if max_index >= 0:
		max_enjoyment = pref_max[courage][max_index]
	print(max_enjoyment)
```

</PySection>
</LanguageSection>
