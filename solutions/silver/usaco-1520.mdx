---
id: usaco-1520
source: USACO Silver 2025 US Open
title: Ski Slope
author: Sachet Abeysinghe
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_prob3_silver_open25.html)

## Explanation

We are given a tree of waypoints rooted at waypoint $1$, with each edge assigned with a difficulty and enjoyment value. We must answer $M$ queries to find the maximum total enjoyment from a path to a starting waypoint to the root, such that at most $c$ edges have difficulty greater than $s$.

For each starting waypoint, let's store the difficulties of the path and the total accumulated enjoyment. We start with waypoint $1$ having difficulties list $[0]$ and enjoyment $0$. Then, for the $i$th starting waypoint, the difficulties consist of the difficulties of the $p_i$th starting waypoint plus the difficulty of the $i$th run. The enjoyment is the enjoyment of the $p_i$th starting waypoint plus the enjoyment of the $i$th run. This works because $p_i < i$ for all $i$, so we can use the information we have from the parent $p_i$ (difficulty and enjoyment) to incrementally find the difficulties and enjoyment for each starting waypoint.

For a skill level $s$ and courage $c$, the condition that at most $c$ edges have difficulty greater than $s$ is equivalent to saying that the $c + 1$th highest difficulty $\le s$. Due to the special constraint $c \le 10$, we only need to keep track of the eleven highest difficulties of each starting waypoint. We'll have a list for each $c$, containing the $c + 1$th highest difficulty and enjoyment of each starting waypoint, and sort each list by difficulty. For each query, we binary search the difficulty on the corresponding $c$th list to find the maximum index where the difficulty is at most $s$. The answer is then the maximum enjoyment of the prefix up to that index, which can be found efficiently by precomputing prefix maximums.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log N+M\log N)$

<LanguageSection>

<PySection>

```py
import bisect
import itertools
n = int(input())
waypoints = [[[0], 0] for i in range(n)]
for waypoint in range(1, n):
    parent, difficulty, enjoyment = map(int, input().split())
    waypoints[waypoint][0] = sorted(waypoints[parent - 1][0][:] + [difficulty])[-11:]
    waypoints[waypoint][1] = waypoints[parent - 1][1] + enjoyment

top_11_difficulties = [[] for i in range(11)]
pref_max = []
for courage in range(11):
    for waypoint in range(1, n):
        if len(waypoints[waypoint][0]) > courage:
            top_11_difficulties[courage].append([waypoints[waypoint][0][-courage - 1], waypoints[waypoint][1]])
    top_11_difficulties[courage].sort()
    pref_max.append(list(itertools.accumulate([x[1] for x in top_11_difficulties[courage]], max)))

m = int(input())
for friend in range(m):
    skill, courage = map(int, input().split())
    max_enjoyment = 0
    max_index = bisect.bisect(top_11_difficulties[courage], [skill, float("inf")]) - 1
    if max_index >= 0:
        max_enjoyment = pref_max[courage][max_index]
    print(max_enjoyment)
```

</PySection>

</LanguageSection>
