---
id: usaco-1232
source: USACO Silver 2022 US Open
title: COW Operations
author: Arnav Gokhale
---

## Explanation

Firstly notice the sequence $OW$ or $WO$ can be transformed into a $C$. Also, you can rearrange any two adjacent characters, like $CO$ to $CO$. (To prove this, tranform $CO$ to $OWWC$ and then simplify to $OC$.)

So, for a query containing characters from $l$ to $r$, the order of the characters is not relevant but the amount of each character is.

Define $C$, $W$, and $O$ as the amount of their respective characters in the query. To comptute these values, we can use prefix sums.

Notice that if $C + W$ is odd or $C + O$ is odd, the answer must be false, because we can't simplify the substring into a single $C$ without $O$ or $W$ characters remaining.

To prove that the substring is valid when $C + W$ is odd and $C + O$ is odd, we can first notice that when these two conditions hold, $W + O$ is even.

Next, we can simplify $W$ and $O$ by removing all duplicate pairs. One possibility is that we will be left with $W = 0$ and $O = 0$ meaning that $C$ was odd and it can easily simplified into one $C$ character. 

Otherwise we will be left with $W = 1$ and $O = 1$ meaning that $C$ was even and by combining the $WC$ pair, we will be left with a odd amount of $C$, which can be simplified into one $C$ character.

So, to prove a query was successful, we simply need to check if $C + W$ and $C + O$ are both odd.


## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	string s; cin >> s;
    //Calculate prefix array for each character
    vector<array<int,3>> a(s.size() + 1);

    for (int i = 1; i <= s.size(); i++) {
        a[i][0] = a[i-1][0] + (s[i-1] == 'C');
        a[i][1] = a[i-1][1] + (s[i-1] == 'O');
        a[i][2] = a[i-1][2] + (s[i-1] == 'W');
    }

    int q; cin >> q;
    //Test each query
    while (q--) {
        int n1, n2;
        cin >> n1 >> n2;
        int c = a[n2][0] - a[n1 - 1][0], o = a[n2][1] - a[n1 - 1][1], w = a[n2][2] - a[n1 - 1][2];
        if ((c + w) % 2 == 1 and (c + o) % 2 == 1) cout << 'Y';
        else cout << 'N';
    }
}

```

</CPPSection>

<PySection>

```py
s = input()
n = len(s)

# Calculate prefix array for each character
a = [[0, 0, 0] for _ in range(n + 1)]

for i, ch in enumerate(s, 1):
    a[i][0] = a[i-1][0] + (ch == 'C')
    a[i][1] = a[i-1][1] + (ch == 'O')
    a[i][2] = a[i-1][2] + (ch == 'W')

q = int(input())

# Test each query
for _ in range(q):
    n1, n2 = map(int, input().split())
    c = a[n2][0] - a[n1 - 1][0]
    o = a[n2][1] - a[n1 - 1][1]
    w = a[n2][2] - a[n1 - 1][2]
    if (c + w) % 2 == 1 and (c + o) % 2 == 1:
        print('Y', end = "")
    else:
        print('N', end = "")

```

</PySection>

<JavaSection>

```java
import java.io.*;
import java.util.StringTokenizer;

public class COWOperations {
	public static void main(String[] args) throws IOException {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
        String s = r.readLine();

        //Calculate the prefix array for each character
        int[][] a = new int[s.length() + 1][3];
        for (int i = 1; i <= s.length(); i++) {
            a[i][0] = a[i-1][0] + ((s.charAt(i-1) == 'C') ? 1 : 0);
            a[i][1] = a[i-1][1] + ((s.charAt(i-1) == 'O') ? 1 : 0);
            a[i][2] = a[i-1][2] + ((s.charAt(i-1) == 'W') ? 1 : 0);
        }

        //Test each query
        int q = Integer.parseInt(r.readLine());
        while (q > 0) {
            StringTokenizer st = new StringTokenizer(r.readLine());
            int n1 = Integer.parseInt(st.nextToken());
            int n2 = Integer.parseInt(st.nextToken());
            
            int c = a[n2][0] - a[n1 - 1][0], o = a[n2][1] - a[n1 - 1][1], w = a[n2][2] - a[n1 - 1][2];

            if ((c + w) % 2 == 1 && (c + o) % 2 == 1) pw.print('Y');
            else pw.print('N');

            q--;
        }


		pw.close();
	}
}
```

</JavaSection>

</LanguageSection>
