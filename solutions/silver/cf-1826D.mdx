---
id: cf-1826D
source: CF
title: Running Miles
author: Chongtian Ma, Rameez Parwez, Ruben Jing
---

[Official Analysis](https://codeforces.com/blog/entry/115892)

## Explanation

The given equation demonstrates how as the distance between the left and right boundaries 
increase, the value of the equation decreases. Thus, in order to maximize the value, it is
best to set two of the most beautiful sights at the boundaries. Then, the distance between 
the boundaries is decreased, meaning the value of the equation is increased. Knowing this, 
we can create a new equation reflecting that two of the sights are at the boundaries.
$$
b_{i_1} + b_{l} + b_{r} + (l - r) = b_{i_1} + (b_{l} + l) + (b_{r} - r).
$$
This simplifies the problem into finding a middle sight and adding it to the maximum $b_l + l$
from the left and the maximum $b_r + r$ from the right.

In order to do so, we can compute a prefix array that stores the maximum value of $\texttt{beauty}[i] + i$
for sights to the left of each point, and a suffix array that stores the maximum value of $\texttt{beauty}[i] - i$
for sights to the right of each point.

For each possible middle sight, we combine the best contributions from its left and right with its own beauty to maximize the result.

## Implementation

**Time Complexity:** $\mathcal{O}(n)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int n;
		cin >> n;
		vector<int> beauty(n);
		for (int i = 0; i < n; i++) { cin >> beauty[i]; }

		vector<int> pref_max(n);
		vector<int> suff_max(n);
		for (int i = 0; i < n; i++) {
			pref_max[i] = beauty[i] + i;
			suff_max[i] = beauty[i] - i;
		}

		for (int i = 1; i < n; i++) { pref_max[i] = max(pref_max[i], pref_max[i - 1]); }
		for (int i = n - 2; i >= 0; i--) {
			suff_max[i] = max(suff_max[i], suff_max[i + 1]);
		}

		int ans = 0;
		for (int i = 1; i < n - 1; i++) {
			ans = max(ans, pref_max[i - 1] + beauty[i] + suff_max[i + 1]);
		}

		cout << ans << '\n';
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class RunningMiles {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		int testNum = io.nextInt();
		for (int t = 0; t < testNum; t++) {
			int n = io.nextInt();
			int[] beauty = new int[n];
			for (int i = 0; i < n; i++) { beauty[i] = io.nextInt(); }

			int[] pref_max = new int[n];
			int[] suff_max = new int[n];

			for (int i = 0; i < n; i++) {
				pref_max[i] = beauty[i] + i;
				suff_max[i] = beauty[i] - i;
			}

			for (int i = 1; i < n; i++) {
				pref_max[i] = Math.max(pref_max[i], pref_max[i - 1]);
			}
			for (int i = n - 2; i >= 0; i--) {
				suff_max[i] = Math.max(suff_max[i], suff_max[i + 1]);
			}

			int ans = 0;
			for (int i = 1; i < n - 1; i++) {
				ans = Math.max(ans, pref_max[i - 1] + beauty[i] + suff_max[i + 1]);
			}
			io.println(ans);
		}
		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
for _ in range(int(input())):
	n = int(input())
	beauty = list(map(int, input().split()))
	pref = [0] * n
	suff = [0] * n

	for i in range(n):
		pref[i] = beauty[i] + i
		suff[i] = beauty[i] - i

	for i in range(1, n):
		pref[i] = max(pref[i], pref[i - 1])
	for i in range(n - 2, -1, -1):
		suff[i] = max(suff[i], suff[i + 1])

	ans = 0
	for i in range(1, n - 1):
		ans = max(ans, pref[i - 1] + suff[i + 1] + beauty[i])

	print(ans)
```

</PySection>
</LanguageSection>
