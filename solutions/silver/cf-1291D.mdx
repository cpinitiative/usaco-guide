---
id: cf-1291D
source: CF
title: Irreducible Anagrams
author: Ruben Jing
---

[Official Editorial (C++)](https://codeforces.com/blog/entry/73563)

## Explanation

First, we can consider the case where $l = r$, meaning the substring has length $1$. A reducible anagram
requires the substring to be split into $k \geq 2$ segments, which is impossible for length $1$.
Thus, a substring of length $1$ has an irreducible anagram.

In the following cases, $l \neq r$.

We consider the case where $s[l] \neq s[r]$. We can create an anagram where all occurrences of $s[r]$
are in the front, and the rest of the string follows. This is an irreducible anagram. We can make sure
that the last segment contains no occurrences of $s[r]$. This is possible as all the occurrences are in the front.

To illustrate this, consider the scenario where our string is $\text{abbbb}$. We can create the
anagram $\text{bbbba}$. The segments can be from $[0, 3]$ and $[4, 4]$, Because the last segments
are $\text{b}$ and $\text{a}$, $\text{abbbb}$ is an irreducible anagram.

Next, we consider the case where $s[l] = s[r]$. Whether or not the substring has an irreducible anagram
varies from case to case.

Start by considering the case where the substring only contains one distinct character. This does not have an irreducible
anagram because its only anagram is itself. Because its only anagram is itself, any segments that we choose
will always be anagrams of each other, meaning it only has a reducible anagram.

From the previous examples, it can be seen that having $t[l]=s[l]$ and/or $t[r]=s[r]$ does not help with
creating an irreducible anagram. If this happens, we can split the string into two segments, one of
length one at either $l$ or $r$, and another of everything else. For example, $s=\text{abcca}$,
$\text{aabcc}$ is not an irreducible anagram because we can have a segment $[0, 1]$ and another $[2, 4]$.
Thus it is optimal to have $t[l]\neq s[l]$ AND $t[r]\neq s[r]$.

However, notice in the case of two distinct characters, an irreducible anagram cannot be formed. Even with the ends of
$t$ and $s$ not matching, it is always possible to reduce the strings. Consider a string with characters $\text{a}$ and
$\text{b}$. If we find one range starting/ending on either end where the number of $\text{a}$s and $\text{b}$s are
equal in both substrings of $s$ and $t$, the other two substrings will have the same amount of $\text{a}$s and $\text{b}$s as
each other.

For example, lets say we have the string $s=\text{aabbbbaa}$. An anagram can be $t=\text{bbbaaaab}$. We can make a substring from
$[0, 4]$. The number of $\text{a}$s in $s[0:4]$ is equal to that in $t[0:4]$. Additionally, the number of $\text{b}$s in $s[0:4]$
is equal to that in $t[0:4]$. This is necessary because they are anagrams of each other. The remaining substrings, $s=\text{baa}$
and $t=\text{aab}$, has the same condition, because the amount of $\text{a}$s in $s$ and $t$ and $\text{b}$s in $s$ and $t$ are equal.
In essence, it's just saying $\text{some number} - \text{another number} = \text{some number} - \text{another number}$.

The case where three distinct characters exist is a bit more complicated. In order to assure that the first character of $s$ and
an anagram are different, we can insert all occurrences of the last distinct character to appear to the front. Next, to assure that
the last character of $s$ and an anagram are different, we can insert all occurrences of the last character after the last distinct
character, if they are different (if they are the same, we don't need to do anything). Now, we can insert the rest of the string
in any order. This anagram is irreducible. The last character in $s$ will be one of the first characters in $t$, forcing us to
use the entire string if we wish to create an anagram.

We can generalize these observations: a string has at least one irreducible
anagram if any of these three conditions hold:

1. The string has three or more different characters
2. The first and last character are different
3. The string is of length 1

The last two conditions are easy to check. However, to check the first condition, we
must use prefix sums. For each of the 26 letters of the alphabet, we can hold a prefix
sum counting how many times the letter has been seen. If on an interval, three letters
have been seen at least once, then the string is an irreducible anagram.

## Implementation

**Time Complexity:** $\mathcal{O}(|s| + q)$ where $|s|$ is the length of string $s$ and $q$ is the number of queries

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

const int LETTERS = 26;

int main() {
	string s;

	cin >> s;

	vector<vector<int>> pref(LETTERS, vector<int>(s.length() + 1));

	for (int i = 1; i < s.length() + 1; i++) {
		char let = s[i - 1];

		for (int letter = 0; letter < LETTERS; letter++) {
			pref[letter][i] = pref[letter][i - 1];
		}

		pref[let - 'a'][i] = pref[let - 'a'][i - 1] + 1;
	}

	int t;

	cin >> t;

	while (t--) {
		int a, b;
		cin >> a >> b;

		int num_diff = 0;

		for (int i = 0; i < LETTERS; i++) {
			if (pref[i][b] - pref[i][a - 1] > 0) num_diff++;
		}

		string ans = "";

		if (b == a) {
			ans = "Yes";
		} else if (num_diff >= 3) {
			ans = "Yes";
		} else if (s[a - 1] != s[b - 1]) {
			ans = "Yes";
		} else {
			ans = "No";
		}

		cout << ans << "\n";
	}
}
```

</CPPSection>

</LanguageSection>
