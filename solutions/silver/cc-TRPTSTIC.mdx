---
id: cc-TRPTSTIC
source: CC
title: TripTastic
author: Daniel Ge
---

# Implementation

**Time Complexity:** $\mathcal{O}(N \cdot M)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll N, M, K;
// Since N, M <= 1e6, we cannot just use an array
vector<vector<ll>> grid, pref;

/**
 * @return the sum from (row1, column1) to (row2, column2)
 * Assumes row1 < row2 and column1 < column2
 */
ll rangesum(ll row1, ll column1, ll row2, ll column2) {
	// Sometimes, the range the mentor can reach goes outside the grid
	if (row1 < 0) { row1 = 0; }
	if (row2 >= N) { row2 = N - 1; }
	if (column1 < 0) { column1 = 0; }
	if (column2 >= M) { column2 = M - 1; }

	ll answer = 0;
	answer += pref[row2][column2];
	if (row1 > 0) { answer -= pref[row1 - 1][column2]; }
	if (column1 > 0) { answer -= pref[row2][column1 - 1]; }
	if (row1 > 0 && column1 > 0) { answer += pref[row1 - 1][column1 - 1]; }

	return answer;
}

/** @return whether the given distance will work */
bool test(ll distance) {
	// Try centering the mentor at every room
	for (ll i = 0; i < N; i++) {
		for (ll j = 0; j < M; j++) {
			if (grid[i][j] == 0) {
				// The mentor has to at least be able to stay in this room
				continue;
			}
			if (rangesum(i - distance, j - distance, i + distance,
			             j + distance) >= (K + 1)) {
				return true;
			}
		}
	}
	return false;
}

/** Binary search, adapted from the code in its module. */
ll first_true(ll lo, ll hi) {
	hi++;
	while (lo < hi) {
		ll mid = lo + (hi - lo) / 2;
		if (test(mid)) {
			hi = mid;
		} else {
			lo = mid + 1;
		}
	}
	return lo;
}

void solve() {
	cin >> N >> M >> K;

	// Filling in the grid
	ll tot = 0;
	grid.clear();
	for (ll i = 0; i < N; i++) {
		vector<ll> row;
		for (ll j = 0; j < M; j++) {
			ll a;
			cin >> a;
			tot += a;
			row.push_back(a);
		}
		grid.push_back(row);
	}
	if (tot < (K + 1)) {
		cout << -1 << endl;
		return;
	}

	// Setting up the size of the prefix sum array
	pref.clear();
	for (ll i = 0; i < N; i++) {
		pref.push_back(vector<ll>(M));
	}

	// Filling in the prefix sum array
	for (ll i = 0; i < N; i++) {
		for (ll j = 0; j < M; j++) {
			pref[i][j] = grid[i][j];
			if (i > 0) { pref[i][j] += pref[i - 1][j]; }
			if (j > 0) { pref[i][j] += pref[i][j - 1]; }
			if (i > 0 && j > 0) { pref[i][j] -= pref[i - 1][j - 1]; }
		}
	}

	cout << first_true(0, max(N, M)) << endl;
}

int main() {
	ll T;
	cin >> T;
	for (int t = 0; t < T; t++) { solve(); }
}
```

</CPPSection>
</LanguageSection>
