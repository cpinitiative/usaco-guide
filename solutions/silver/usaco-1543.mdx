---
id: usaco-1543
source: USACO Silver 2026 First Contest
title: Mooclear Reactor
author: John Zhou
---

[Official Analysis](https://usaco.org/current/data/sol_prob2_silver_season26contest1.html)

# Solution

## Explanation

First, notice that the constraints $(x, y, z)$ form an undirected, weighted graph, where the constraints
are the edges and the generators are the vertices.  Each connected component can be optimized independently.

Let us first consider the cases when the graph has no cycles. In this case, consider a single connected
component; note that we may choose an arbitary vertex, $v$, and let $x=a_v$.

Since there are no cycles, we may start from vertex $v$ and traverse all vertices in the connected component
without visiting any previously visited vertices (other than the vertices we came from, due to the
representation of an undirected graph as a directed one). In the traversal, since each edge is a constraint,
it is possible to represent the required value for the current node in terms of the node we came from during
the traversal. For example, if the traversal leads us from node $1$ to node $2$ with the constraint $a_1+a_2=3$,
then we may write $a_2=3-a_1$.

Note that since we start from $v$ and we can build representations based on the previous arriving node each
time, we can actually build a representation of all other nodes in the current connected component in terms of
$x$, the initial value of the node we started from, by a simple substitution with the previous node's
expression each time we propagate the expressions.

From there, we can also set the expression to the minimum and maximum values for a generator to function
and solve for $x$ to find out what ranges of $x$ is required for this specific generator to function.  After
this, since we have multiple ranges of $x$, and we must find a value of $x$ that covers the maximum amount
of ranges (which implies the maximum number of generators may function), we can track each range as
"enter range" and "exit range" events, sort the events by their $x$ values, and then execute those events
one by one, finding the maximum amount of generators we may entertain for that connected component as we
sweep across the number line.  Adding the values for each component will then yield our answer.

Now, what happens if we have cycles?  In our traversal for each component, cycles break the assumption that
we're not going to visit a previously visited node. In mathematical terms, this means that we will come
up with *two* different representations of power for a generator. We may connect those two representations
when we revisit a node by equating them and solving the equation; after that, only one $x$ value is
permissible for the connected component, so instead of the "events" handling described previously, we
only use that value of $x$, and check it against the minimum and maximum $x$ values required by each
node to see if it will generate power.

## Implementation

**Time Complexity**: $\mathcal O(N+M)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;
#define int long long
int l[200005], r[200005], lab[200005], m[200005], b[200005], ff[200005], minn[200005], maxn[200005];
vector<int> g[200005];
vector<int> w[200005];
map<int, int> segments;
vector<int> points[200005];
pair<int, int> propag(int x, int y, int z) {
    int m = -::m[x];
    int b = z - ::b[x];
    return make_pair(m, b);
}
// Returns:
// 1. First bool: If the configuration is possible.
// 2. Second element, first bool: If any action is needed.
// 3. Second element, second bool: What number to make fixed,
// if neccessary.
pair<bool, pair<bool, int> > loopback(int m1, int b1, int m2, int b2) {
    if (m1 == m2 && b1 != b2) {
        return make_pair(false, make_pair(false, 0));
    } else if (m1 == m2 && b1 == b2) {
        return make_pair(true, make_pair(false, 0));
    } else {
        if ((b2 - b1) % (m1 - m2) == 0) {
            return make_pair(true, make_pair(true, (b2 - b1) / (m1 - m2)));
        }
        return make_pair(false, make_pair(false, 0));
    }
}
bool okay = true;
void dfs(int label, int fa, int x) {
    // cout << "000---" << label << ' ' << fa << ' ' << x << endl;
    lab[x] = label;
    points[label].push_back(x);
    minn[x] = min((l[x] - b[x]) / m[x], (r[x] - b[x]) / m[x]);
    maxn[x] = max((l[x] - b[x]) / m[x], (r[x] - b[x]) / m[x]);
    for (int i = 0; i < g[x].size(); i++) {
        int y = g[x][i];
        int z = w[x][i];
        // cout << "-----" << x << ' ' << y << ' ' << z << endl;
        if (y == fa) continue;
        // cout << "=====" << x << ' ' << y << ' ' << z << endl;
        int m; int b;
        m = propag(x, y, z).first;
        b = propag(x, y, z).second;
        if (::m[y] == 0) {
            ::m[y] = m; ::b[y] = b;
            dfs(label, x, y);
        } else {
            int m2 = ::m[y], b2 = ::b[y];
            auto result = loopback(m, b, m2, b2);
            if (!result.first) {
                // cout << "-1" << endl;
                okay = false;
                // exit(0);
            }
            if (result.second.first) {
                if (ff[label] == 2e9) {
                    ff[label] = result.second.second;
                } else {
                    if (ff[label] != result.second.second) {
                        // cout << "-1" << endl;
                        okay = false;
                        // exit(0);
                    }
                }
            }
        }
    }
}
signed main()
{
    int t;
    cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        for (int i = 1; i <= n; i++) {
            g[i].clear();
            w[i].clear();
            ::m[i] = 0;
            ::b[i] = 0;
            points[i].clear();
        }
        okay = true;
        for (int i = 1; i <= n; i++) cin >> l[i];
        for (int i = 1; i <= n; i++) cin >> r[i];
        for (int i = 1; i <= n; i++) ff[i] = 2e9;
        for (int i = 1; i <= m; i++) {
            int x, y, z;
            cin >> x >> y >> z;
            g[x].push_back(y);
            w[x].push_back(z);
            g[y].push_back(x);
            w[y].push_back(z);
        }
        bool putokay = false;
        for (int i = 1; i <= n; i++) {
            if (!::m[i]) {
                ::m[i] = 1;
                dfs(i, -1, i);
            }
            if (!okay && !putokay) {
                cout << "-1" << endl;
                putokay = true;
                // break;
            }
            // cout << lab[i] << ' ' << minn[i] << ' ' << ff[i] << ' ' << maxn[i] << endl;
        }
        if (!okay) continue;

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (ff[i] == 2e9) {
                segments.clear();
                for (auto pt: points[i]) {
                    if (minn[pt] <= maxn[pt]) {
                        segments[minn[pt]]++;
                        segments[maxn[pt] + 1]--;
                    }
                }
                int total = 0;
                int mmax = -1;
                for (auto sgmt: segments) {
                    total += sgmt.second;
                    mmax = max(mmax, total);
                }
                mmax = max(mmax, total);
                ans += mmax;
                // cout << "+++" << mmax << endl;
            } else {
                for (auto pt: points[i]) {
                    if (minn[pt] <= ff[i] && ff[i] <= maxn[pt]) {
                        ans++;
                        // cout << "---" << i << ' ' << pt << endl;
                    }
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```

</CPPSection>

</LanguageSection>
