---
id: usaco-1543
source: USACO Silver 2026 First Contest
title: Mooclear Reactor
author: John Zhou
---

[Official Analysis](https://usaco.org/current/data/sol_prob2_silver_season26contest1.html)

# Solution

## Explanation

First, notice that the constraints $(x, y, z)$ form an undirected weighted graph, where the constraints
are the edges and the generators are the vertices.  Each connected component can be optimized independently,
and below we shall consider one connected component.

Let us first consider the cases when the component has no cycles. In this case, we choose an arbitary vertex,
$v$, and let the variable $x$ represent $a_v$.

Since there are no cycles, we may start from vertex $v$ and traverse all vertices in the connected component
without visiting any already visited vertices. In the traversal, since each edge is a constraint,
we can write the value for the node we go to in terms of the node we came from. For example, if the
traversal leads us from node $1$ to node $2$ with the constraint $a_1+a_2=3$, then we may write $a_2=3-a_1$.

We can stack up and subtitute those representations at each traversal, and build a representation of all
other nodes in the current connected component in terms of $x$, and using the previous paragraph to build
new representations from the representation of our source node for the current step.

From there, we can also set the expression to the minimum and maximum values for a generator to function
and solve for $x$ to find out what ranges of $x$ is required for this specific generator to function.  After
this, since we have multiple ranges of $x$, and we must find a value of $x$ that covers the maximum amount
of ranges (which implies the maximum number of generators may function), we can track each range as
"enter range" and "exit range" events, sort the events by their $x$ values, and then execute those events
one by one, finding the maximum amount of generators we may entertain for that connected component as we
sweep across the number line.  Adding the values for each component will then yield our answer.

Now, what happens if we have cycles?  In our traversal for each component, cycles break the assumption that
we're not going to visit a previously visited node. In mathematical terms, this means that we will come
up with *two* different representations of power for a generator. We may connect those two representations
when we revisit a node by equating them and solving the equation; after that, only one $x$ value is
permissible for the connected component, so instead of the "events" handling described previously, we
only use that value of $x$, and check it against the minimum and maximum $x$ values required by each
node to see if it will generate power. If the equation is unsolvable, then we cannot satisfy all
constraints; if the equation has infinitely many solutions, we can treat it as doing nothing.  These
actions will essentially connect our two equivalence chains of representations, which means that
we only need to do it once to the node we're about to revisit, not to every previously done node
down the lane.

## Implementation

**Time Complexity**: $\mathcal O(N+M)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;
#define int long long
int l[200005], r[200005], lab[200005], m[200005], b[200005], ff[200005], minn[200005],
    maxn[200005];
vector<int> g[200005];
vector<int> w[200005];
map<int, int> segments;
vector<int> points[200005];
pair<int, int> propag(int x, int y, int z) {
	int m = -::m[x];
	int b = z - ::b[x];
	return make_pair(m, b);
}
// Returns:
// 1. First bool: If the configuration is possible.
// 2. Second element, first bool: If any action is needed.
// 3. Second element, second bool: What number to make fixed,
// if neccessary.
pair<bool, pair<bool, int>> loopback(int m1, int b1, int m2, int b2) {
	if (m1 == m2 && b1 != b2) {
		return make_pair(false, make_pair(false, 0));
	} else if (m1 == m2 && b1 == b2) {
		return make_pair(true, make_pair(false, 0));
	} else {
		if ((b2 - b1) % (m1 - m2) == 0) {
			return make_pair(true, make_pair(true, (b2 - b1) / (m1 - m2)));
		}
		return make_pair(false, make_pair(false, 0));
	}
}
bool okay = true;
void dfs(int label, int fa, int x) {
	lab[x] = label;
	points[label].push_back(x);
	minn[x] = min((l[x] - b[x]) / m[x], (r[x] - b[x]) / m[x]);
	maxn[x] = max((l[x] - b[x]) / m[x], (r[x] - b[x]) / m[x]);
	for (int i = 0; i < g[x].size(); i++) {
		int y = g[x][i];
		int z = w[x][i];
		if (y == fa) continue;
		int m;
		int b;
		m = propag(x, y, z).first;
		b = propag(x, y, z).second;
		if (::m[y] == 0) {
			::m[y] = m;
			::b[y] = b;
			dfs(label, x, y);
		} else {
			int m2 = ::m[y], b2 = ::b[y];
			auto result = loopback(m, b, m2, b2);
			if (!result.first) { okay = false; }
			if (result.second.first) {
				if (ff[label] == 2e9) {
					ff[label] = result.second.second;
				} else {
					if (ff[label] != result.second.second) { okay = false; }
				}
			}
		}
	}
}
signed main() {
	int t;
	cin >> t;
	while (t--) {
		int n, m;
		cin >> n >> m;
		for (int i = 1; i <= n; i++) {
			g[i].clear();
			w[i].clear();
			::m[i] = 0;
			::b[i] = 0;
			points[i].clear();
		}
		okay = true;
		for (int i = 1; i <= n; i++) cin >> l[i];
		for (int i = 1; i <= n; i++) cin >> r[i];
		for (int i = 1; i <= n; i++) ff[i] = 2e9;
		for (int i = 1; i <= m; i++) {
			int x, y, z;
			cin >> x >> y >> z;
			g[x].push_back(y);
			w[x].push_back(z);
			g[y].push_back(x);
			w[y].push_back(z);
		}
		bool putokay = false;
		for (int i = 1; i <= n; i++) {
			if (!::m[i]) {
				::m[i] = 1;
				dfs(i, -1, i);
			}
			if (!okay && !putokay) {
				cout << "-1" << endl;
				putokay = true;
				// break;
			}
		}
		if (!okay) continue;

		int ans = 0;
		for (int i = 1; i <= n; i++) {
			if (ff[i] == 2e9) {
				segments.clear();
				for (auto pt : points[i]) {
					if (minn[pt] <= maxn[pt]) {
						segments[minn[pt]]++;
						segments[maxn[pt] + 1]--;
					}
				}
				int total = 0;
				int mmax = -1;
				for (auto sgmt : segments) {
					total += sgmt.second;
					mmax = max(mmax, total);
				}
				mmax = max(mmax, total);
				ans += mmax;
			} else {
				for (auto pt : points[i]) {
					if (minn[pt] <= ff[i] && ff[i] <= maxn[pt]) { ans++; }
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

</CPPSection>

</LanguageSection>
