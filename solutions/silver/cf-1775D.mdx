---
id: cf-1775D
source: CF
title: Friendly Spiders
author: Kevin Sheng, John Zhou
---

[Official Analysis (C++)](https://codeforces.com/blog/entry/111286)

# Solution 1

## Explanation

The first observation we need to make is that all spiders which share a common
factor form a complete graph where all pairs of spiders in this group are friends with each other.

Thus, we can enumerate the prime factors of all spiders and keep track
for each factor the spiders which divide it to store the edges in an efficient manner.
Two spiders are friends iff they're both in some prime factor's list together.

However, doing a naive BFS from the starting node will take too long.
To optimize this, we have to make another optimization, which is that
it's always optimal to "use" a prime at most once in our path.

For example, take the path where the number of legs are $15$, $3$, and $9$
where we've used the common divisor $3$ two times.
Here, we can cut out $3$ and move directly from $15$ to $9$.

This allows us to do an optimized BFS from the starting spider
by keeping a global list of visited prime factors.
For each spider, we iterate through its prime factors and see
which ones haven't been used.
If a factor hasn't been used, then it's standard BFS with backtracking.

## Implementation

**Time Complexity:** $\mathcal{O}\left(n \left(\sqrt{A} + \log n\right)\right)$, where $A$ is the largest number of legs among the spiders.

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <cmath>
#include <iostream>
#include <map>
#include <set>
#include <vector>

using namespace std;

/** @return n's prime factors */
set<int> primes(int n) {
	set<int> ret;
	while (n % 2 == 0) {
		n /= 2;
		ret.insert(2);
	}

	for (int i = 3; i * i <= n; i += 2) {
		while (n % i == 0) {
			n /= i;
			ret.insert(i);
		}
	}

	if (n > 2) { ret.insert(n); }
	return ret;
}

int main() {
	int spider_num;
	cin >> spider_num;
	map<int, vector<int>> trains;
	vector<set<int>> prime_factors(spider_num);
	for (int s = 0; s < spider_num; s++) {
		int spider;
		cin >> spider;
		prime_factors[s] = primes(spider);
		for (int f : prime_factors[s]) { trains[f].push_back(s); }
	}

	int start, end;
	cin >> start >> end;
	start--;
	end--;

	vector<int> frontier{start};
	set<int> taken;
	// Stores each spider's predecessor for path reconstruction
	vector<int> come_from(spider_num, -1);
	come_from[start] = start;
	while (!frontier.empty()) {
		vector<int> next_up;
		for (int s : frontier) {
			for (int f : prime_factors[s]) {
				if (taken.count(f)) {
					// Already used this factor before, so we can skip it
					continue;
				}
				for (int ns : trains[f]) {
					if (come_from[ns] == -1) {
						come_from[ns] = s;
						next_up.push_back(ns);
					}
				}
				taken.insert(f);
			}
		}
		frontier = next_up;
	}

	if (come_from[end] == -1) {
		cout << -1 << endl;
		return 0;
	}

	// Reconstruct the path by backtracking from the end to the start
	vector<int> path{end};
	while (path.back() != start) { path.push_back(come_from[path.back()]); }
	reverse(path.begin(), path.end());

	cout << path.size() << '\n';
	for (int i = 0; i < path.size(); i++) {
		cout << path[i] + 1 << " \n"[i == path.size() - 1];
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class FriendlySpiders {
	public static void main(String[] args) throws IOException {
		BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
		int spiderNum = Integer.parseInt(read.readLine());

		Map<Integer, List<Integer>> trains = new HashMap<>();
		Set<Integer>[] primeFactors = new HashSet[spiderNum];
		StringTokenizer spiderST = new StringTokenizer(read.readLine());
		for (int s = 0; s < spiderNum; s++) {
			int spider = Integer.parseInt(spiderST.nextToken());
			primeFactors[s] = primes(spider);
			for (int f : primeFactors[s]) {
				if (!trains.containsKey(f)) { trains.put(f, new ArrayList<>()); }
				trains.get(f).add(s);
			}
		}

		StringTokenizer query = new StringTokenizer(read.readLine());
		int start = Integer.parseInt(query.nextToken()) - 1;
		int end = Integer.parseInt(query.nextToken()) - 1;

		List<Integer> frontier = new ArrayList<>(Arrays.asList(start));
		Set<Integer> taken = new HashSet<>();
		// Stores each spider's predecessor for path reconstruction
		int[] comeFrom = new int[spiderNum];
		Arrays.fill(comeFrom, -1);
		comeFrom[start] = start;
		while (!frontier.isEmpty()) {
			List<Integer> next_up = new ArrayList<>();
			for (int s : frontier) {
				for (int f : primeFactors[s]) {
					if (taken.contains(f)) {
						// Already used this factor before, so we can skip it
						continue;
					}
					for (int ns : trains.get(f)) {
						if (comeFrom[ns] == -1) {
							comeFrom[ns] = s;
							next_up.add(ns);
						}
					}
					taken.add(f);
				}
			}
			frontier = next_up;
		}

		if (comeFrom[end] == -1) {
			System.out.println(-1);
			return;
		}

		List<Integer> path = new ArrayList<>(Arrays.asList(end));
		while (path.get(path.size() - 1) != start) {
			path.add(comeFrom[path.get(path.size() - 1)]);
		}
		Collections.reverse(path);

		System.out.println(path.size());
		for (int i = 0; i < path.size(); i++) {
			System.out.print(path.get(i) + 1 + (i == path.size() - 1 ? "\n" : " "));
		}
	}

	private static Set<Integer> primes(int n) {
		Set<Integer> ret = new HashSet<>();
		while (n % 2 == 0) {
			n /= 2;
			ret.add(2);
		}

		for (int i = 3; i * i <= n; i += 2) {
			while (n % i == 0) {
				n /= i;
				ret.add(i);
			}
		}

		if (n > 2) { ret.add(n); }
		return ret;
	}
}
```

</JavaSection>
</LanguageSection>

# Solution 2

## Explanation

First, notice that two spiders are friends, they must share a common prime factor.
But we can't maintain all the possible edges between any two spiders, as that's
too slow.

Since the complete graphs for the spiders are grouped by prime factors, we
build a graph that groups spiders by prime factors. We do this
by creating nodes representing prime factors, and connecting them
to the spiders divisible by that prime factor. Two spiders communicating
will be the sender communicating to the prime factor node, and the prime
factor node communicating to the receiver.

We can now notice that the length of the path in the original
problem is the length of the shortest path over our newly reformulated graph,
divided by 2 plus 1, accounting for the starting node.

The number of vertices is the amount of prime factors plus the amount of nodes;
the amount of prime factors must be less than $a_\mathrm{max} < 3\times10^5$,
as factors must be less than the numbers themselves, and not every number is
prime. So the amount of vertices cannot exceed $6\times10^5$.
For the number of edges, for any number less than $3\times10^5$ there are at
most $7$ prime factors for it; the maximum amount of prime factors can be
obtained by a construction not repeating any prime factors, and using the
smallest prime factors (i.e.
$2\times3\times5\times7\times\cdots\times17>3\times10^5$).

## Implementation

This implementation uses a sieve for a little bit of speedup, which is not strictly
required for this problem. It is obvious that the scale of the solution will not
time out from the calculations above; but to be exact, the time complexity of this
implementation is $\mathcal O(n\frac{\log n}{\log\log n}+\frac A{\log A}+n\log\log A)$
with $A=\max(a_i)$ by elementary number theory.

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <map>
#include <queue>
#include <utility>
#include <vector>

using namespace std;

// There's less than 1e5 primes under 3e5
const int MAXPRIMES = 100000;
const int MAXN = 300000;
const int MAXNODES = MAXN + MAXPRIMES;
const int MAXNUM = 300000;
// Adjacency list for nodes in the graph described above.
vector<int> g[MAXNODES + 1];
// Whether each node is visited; used by the BFS in main.
bool vis[MAXNODES + 1];
// This represents a mapping from the prime factor itself
// to the node number in the graph; i.e. primes[prime] ==
// node number for prime factor
int primes[MAXNUM + 1];
// Used by sieve and efficient factorization; smallest prime
// factor maintained for each number.
int spf[MAXNUM + 1];
// Used to reconstruct the path after the BFS in main, by
// storing the node (the value) from which a node (the index)
// is visited.
int parent[MAXNODES + 1];

int total;

// Register the fact that the i-th number has prime factor p.
// This will create a new prime factor node if necessary, and
// make the correct connections to the node.
void addprime(int p, int i) {
	if (!primes[p]) primes[p] = ++total;
	g[primes[p]].push_back(i);
	g[i].push_back(primes[p]);
}

// A pre-processing step for efficient factorization; uses
// Eratosthenes' sieve to pre-determine the smallest prime
// factor for each number.
void sieve() {
	for (int i = 2; i <= MAXNUM; i++) spf[i] = i;
	for (int i = 2; i * i <= MAXNUM; i++) {
		if (spf[i] == i) {
			for (int j = i * i; j <= MAXNUM; j += i) {
				if (spf[j] == j) spf[j] = i;
			}
		}
	}
}

// Factorize a number; the index of the node is also passed
// in to facilitate making connections in the process.
void factorize(int a, int i) {
	while (a > 1) {
		int p = spf[a];
		if (a > 1 && a % p == 0) addprime(p, i);
		while (a > 1 && a % p == 0) a /= p;
	}
}

int main() {
	sieve();
	int n;
	cin >> n;
	total = n;
    // Process each input, and make the necessary node
	// connections.
	for (int i = 1; i <= n; i++) {
		int a;
		cin >> a;
		factorize(a, i);
	}
	int start, end;
	cin >> start >> end;

	// Standard BFS algorithm.
	// q tracks the location and path length for
	// each visit.
	queue<pair<int, int>> q;
	vis[start] = true;
	q.push(make_pair(start, 0));
	while (!q.empty()) {
		auto front = q.front();
		q.pop();
		int loc = front.first, len = front.second;

		// Since BFS is breadth-first, the first to reach the
		// end shall terminate all other searching.
		if (loc == end) {
			cout << len / 2 + 1 << endl;
			vector<int> points(1, loc);

			// Trace the parents (last nodes) visited recursively
			// until we get to the start.  Then, reverse the constructed
			// path and output it (but only odd-numbered, aka. original nodes).
			int current = loc;
			while (current != start) {
				current = parent[current];
				points.push_back(current);
			}
			reverse(points.begin(), points.end());
			int cnt = 0;
			for (auto a : points) {
				if (++cnt % 2) cout << a << ' ';
			}
			cout << endl;
			return 0;
		}

		for (int next : g[loc]) {
			if (!vis[next]) {
				vis[next] = true;
				parent[next] = loc;
				q.push(make_pair(next, len + 1));
			}
		}
	}

	// If no path is found, print -1.
	cout << -1 << endl;
}
```

</CPPSection>
</LanguageSection>
