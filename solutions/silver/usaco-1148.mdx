
---
id: usaco-1134
source: USACO Silver 2024 December
title: 2D Conveyor Belt
author: Ruben Jing
---

[Official Analysis (C++/Python)](https://usaco.org/current/data/sol_prob3_silver_dec24.html)

## Explanation

We make two key observations. 
1. An empty cell on the border is always good, as if FJ places cells optimally,
   the cell will point outward
2. A cell pointing into another good cell is also good. If FJ places conveyors 
   onto empty cells optimally,  this means that the empty cell should always 
   point into a good cell. 

With these observations, the general idea is to floodfill from every point
and see how many good cells it can reach. The amount of unusable cells
is the total squares minus good cells. 

To satisfy the query restriction, we can start with the latest query 
and work our way back. The amount of good cells will only increase: the 
more empty cells there are, the more flexibility there is to place a 
good conveyor. 

Whenever we "undo" a query, we DFS from the new empty cell. If it is good, then we check if any cells around it 
become good. Otherwise, we leave it as is.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2 + Q)$

<LanguageSection>

<CPPSection>
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, q;
int goodAmt = 0;

bool isValid(int r, int c) { return (r > -1 && c > -1 && r < n && c < n); }
bool isBorder(int r, int c) { return (r == 0 || c == 0 || r == n - 1 || c == n - 1); }

bool checkGood (vector<vector<char>>& grid, vector<vector<bool>>& good, int r, int c) {
    if (grid[r][c] == '?' && isBorder(r, c)) { return true; }

    if ((grid[r][c] == '?' || grid[r][c] == 'D') && 
        ((isValid(r + 1, c) && good[r + 1][c]) || (!isValid(r + 1, c)))) {
        return true;
    }

    if ((grid[r][c] == '?' || grid[r][c] == 'U') && 
         ((isValid(r - 1, c) && good[r - 1][c]) || (!isValid(r - 1, c)))) {
        return true;
    }

    if ((grid[r][c] == '?' || grid[r][c] == 'L') && 
         ((isValid(r, c - 1) && good[r][c - 1]) || (!isValid(r, c - 1)))) {
        return true;
    }

    if ((grid[r][c] == '?' || grid[r][c] == 'R') && 
         ((isValid(r, c + 1) && good[r][c + 1]) || (!isValid(r, c + 1)))) {
        return true;
    }

    return false;
}

void dfs(vector<vector<char>>& grid, vector<vector<bool>>& good, int r, int c) {
    if (!isValid(r, c) || !checkGood(grid, good, r, c) || good[r][c]) {
        return;
    }

    good[r][c] = true;  
    goodAmt++;

    dfs(grid, good, r + 1, c);
    dfs(grid, good, r - 1, c);
    dfs(grid, good, r, c + 1);
    dfs(grid, good, r, c - 1);
}

int main () {
    cin >> n >> q;

    vector<vector<char>> grid(n, vector<char>(n, '?'));
    vector<vector<bool>> good(n, vector<bool>(n, false));
    vector<tuple<int, int, char>> queries(q);

    for (auto& [r, c, t] : queries) {
        cin >> r >> c >> t;

        r--; c--;

        grid[r][c] = t;
    }
    
    reverse(queries.begin(), queries.end());

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dfs(grid, good, i, j); 
        }
    }

    vector<int> res;
    for (auto [r, c, t]: queries) {
        res.push_back(n * n - goodAmt);

        grid[r][c] = '?';
        dfs(grid, good, r, c);
    }

    for (int i = res.size() - 1; i > -1; i--) { cout << res[i] << "\n"; }
}
```
</CPPSection
</LanguageSection>