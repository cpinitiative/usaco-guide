---
id: cf-104536F
source: CF
title: Minimize the Diameter
author: KJ Karaisz, David Guo
---

## Explanation

Let's consider the longest possible path the added edge could create. One way to find this path would be to use the two farthest nodes on each tree from the nodes the added edge connects.
Therefore, on each tree, the optimal node to connect the edge to is the node that has the shortest possible path to the farthest node.

It turns out that this node is always the middle of the tree's diameter. To help understand this, we can visualize the tree with its diameter as a horizontal line, and the other nodes
'hanging' off of it:

![Tree graph with its diameter on a horizontal line, and other nodes hanging off the bottom](<cf-104536F/graph.png>)

Note how moving the node to anything but 3 extends the longest path by the edge that was just used.

Now it remains to calculate this resulting length. When the diameter's length is even, the longest path will use the longer of the 2 halves of the diameter,
so we need to divide the diameters by 2, round up, and add 1 for the added edge itself (If you don't know how to find the diameter of a tree, see [CPH 14.2](/CPH.pdf#page=145)).

This is, however, not necessarily the longest path. It's possible for the initial diameter of either of the two trees to be longer. So we need to compare the above value to these as well.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

/** @return the farthest node and its distance from the given node. */
pair<int, int> dfs(const vector<vector<int>> &tree, int node = 1, int previous = 0,
                   int length = 0) {
	pair<int, int> max_path = {node, length};
	for (const int &i : tree[node]) {
		if (i == previous) { continue; }
		pair<int, int> other = dfs(tree, i, node, length + 1);
		if (other.second > max_path.second) { max_path = other; }
	}
	return max_path;
}

int main() {
	int n;
	cin >> n;
	vector<vector<int>> tree1(n + 1);
	for (int i = 0; i < n - 1; i++) {
		int u, v;
		cin >> u >> v;
		tree1[u].push_back(v);
		tree1[v].push_back(u);
	}
	int m;
	cin >> m;
	vector<vector<int>> tree2(m + 1);
	for (int i = 0; i < m - 1; i++) {
		int u, v;
		cin >> u >> v;
		tree2[u].push_back(v);
		tree2[v].push_back(u);
	}

	int tree1_start = dfs(tree1).first;
	int tree2_start = dfs(tree2).first;
	int tree1_diameter = dfs(tree1, tree1_start).second;
	int tree2_diameter = dfs(tree2, tree2_start).second;
	// (x + 1) / 2 divides by 2 and rounds up
	int added_edge_diameter = (tree1_diameter + 1) / 2 + (tree2_diameter + 1) / 2 + 1;

	cout << max({tree1_diameter, tree2_diameter, added_edge_diameter}) << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class MinimizeDiameter {
	private static class Pair {
		public int first;
		public int second;
		public Pair(int first, int second) {
			this.first = first;
			this.second = second;
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		List<List<Integer>> tree1 = new ArrayList<>(n + 1);
		for (int i = 0; i <= n; i++) { tree1.add(new ArrayList<>()); }

		for (int i = 0; i < n - 1; i++) {
			st = new StringTokenizer(br.readLine());
			int u = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
			tree1.get(u).add(v);
			tree1.get(v).add(u);
		}

		st = new StringTokenizer(br.readLine());
		int m = Integer.parseInt(st.nextToken());
		List<List<Integer>> tree2 = new ArrayList<>(m + 1);
		for (int i = 0; i <= m; i++) { tree2.add(new ArrayList<>()); }

		for (int i = 0; i < m - 1; i++) {
			st = new StringTokenizer(br.readLine());
			int u = Integer.parseInt(st.nextToken());
			int v = Integer.parseInt(st.nextToken());
			tree2.get(u).add(v);
			tree2.get(v).add(u);
		}

		int tree1Start = dfs(tree1).first;
		int tree2Start = dfs(tree2).first;
		int tree1Diameter = dfs(tree1, tree1Start, 0, 0).second;
		int tree2Diameter = dfs(tree2, tree2Start, 0, 0).second;
		// (x + 1) / 2 divides by 2 and rounds up
		int addedEdgeDiameter = (tree1Diameter + 1) / 2 + (tree2Diameter + 1) / 2 + 1;

		int bestDiameter =
		    Math.max(Math.max(tree1Diameter, tree2Diameter), addedEdgeDiameter);
		System.out.println(bestDiameter);
	}

	private static Pair dfs(List<List<Integer>> tree) { return dfs(tree, 1, 0, 0); }

	/** @return the farthest node and its distance from the given node. */
	private static Pair dfs(List<List<Integer>> tree, int node, int previous,
	                        int length) {
		Pair maxPath = new Pair(node, length);
		for (int i : tree.get(node)) {
			if (i == previous) { continue; }
			Pair other = dfs(tree, i, node, length + 1);
			if (other.second > maxPath.second) { maxPath = other; }
		}
		return maxPath;
	}
}
```

</JavaSection>
</LanguageSection>
