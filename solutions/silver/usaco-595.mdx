---
id: usaco-595
source: USACO Silver 2016 January
title: Subsequences Summing to Sevens
author: Kevin Sheng, thetazero, Melody Yu, Ruben Jing, Rameez Parwez
---

[Official Analysis (Java)](http://www.usaco.org/current/data/sol_div7_silver_jan16.html)

# Solution

## Explanation

We can calculate the prefix sum array of our IDs to quickly compute
whether or not a range of cows has IDs summing to a multiple of $7$.

Given a prefix sum array $p$, the sum over the range $[l, r]$ is $p[r] - p[l-1]$.
We must also make sure this sum is a multiple of $7$ to be a valid group.
These two conditions give us the following:
$$
(p[r] - p[l - 1]) \equiv 0 \pmod{7} \Longleftrightarrow p[r] \equiv p[l - 1] \pmod{7}
$$
Thus, we can simplify the solution to finding the largest difference between two indices
where their prefix sums are equivalent mod $7$.

Additionally, because the prefix sum at $i$ is defined by
$$
p[i]\%7 = \left(a[i]+p[i-1]\right)\%7,
$$
we can find the prefix mod $7$ when precomputing to avoid large numbers.

In order to find the largest consecutive group, we try to find the largest distance
between two equal prefixes. We can have a list that stores the first occurrence
of each remainder. Everytime we see a remainder again, we calculate the distance
between the current index and the first occurrence of the remainder.

## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

const int MOD = 7;

int main() {
	freopen("div7.in", "r", stdin);
	freopen("div7.out", "w", stdout);
	int cow_num;
	cin >> cow_num;

	int longest_photo = 0;
	// first[i] stores the index of the first time a prefix sum % 7 == i
	vector<int> first(MOD, -1);
	first[0] = 0;

	int curr_remainder = 0;
	for (int i = 1; i <= cow_num; i++) {
		int cow;
		cin >> cow;

		curr_remainder = (curr_remainder + cow) % MOD;
		if (first[curr_remainder] == -1) {
			first[curr_remainder] = i;
		} else {
			longest_photo = max(longest_photo, i - first[curr_remainder]);
		}
	}
	cout << longest_photo << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public final class Div7 {
	private static final int MOD = 7;
	public static void main(String[] args) throws IOException {
		long start = System.currentTimeMillis();
		BufferedReader read = new BufferedReader(new FileReader("div7.in"));
		int cowNum = Integer.parseInt(read.readLine());

		int maxLen = 0;
		// first[i] stores the index of the first time a prefix sum % 7 == i
		int[] first = new int[MOD];
		Arrays.fill(first, -1);
		first[0] = 0;

		int runningMod = 0;
		for (int c = 1; c <= cowNum; c++) {
			int cow = Integer.parseInt(read.readLine());
			runningMod = (runningMod + cow) % MOD;
			if (first[runningMod] == -1) {
				first[runningMod] = c;
			} else {
				maxLen = Math.max(maxLen, c - first[runningMod]);
			}
		}

		PrintWriter written = new PrintWriter("div7.out");
		written.println(maxLen);
		written.close();
	}
}
```

</JavaSection>
<PySection>

```py
MOD = 7

with open("div7.in") as read:
	cows = [int(read.readline()) for _ in range(int(read.readline()))]

best_photo = 0
# first_occ[i] stores the index of the first time a prefix sum % 7 == i
first_occ = [-1 for _ in range(MOD)]
first_occ[0] = 0

running_mod = 0
for v, c in enumerate(cows):
	running_mod = (running_mod + c) % MOD

	if first_occ[running_mod] == -1:
		first_occ[running_mod] = v + 1
	else:
		best_photo = max(best_photo, v + 1 - first_occ[running_mod])

print(best_photo)
print(best_photo, file=open("div7.out", "w"))
```

</PySection>
</LanguageSection>

# Video Solution

By Project Starcoder

<YouTube id="wXNhLjiuTgw" />

## Video Solution Code

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ifstream cin("div7.in");
	ofstream cout("div7.out");

	int N;
	cin >> N;

	vector<int> cows(N);
	vector<int> prefix(N + 1);

	for (int i = 0; i < N; i++) {
		cin >> cows[i];
		prefix[i + 1] = (prefix[i] + cows[i]) % 7;
	}

	vector<int> last_found(7);
	for (int i = 0; i < 7; i++) { last_found[i] = -1; }
	int maximum = 0;

	for (int i = 0; i < N + 1; i++) {
		if (last_found[prefix[i]] == -1) {
			last_found[prefix[i]] = i;
		} else {
			maximum = max(i - last_found[prefix[i]], maximum);
		}
	}

	cout << maximum;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Div7 {
	public static void main(String[] args) throws Exception {
		Kattio io = new Kattio("div7");
		int n = io.nextInt();
		int[] cows = new int[n];
		int[] prefix = new int[n + 1];
		
		for (int i = 0; i < n; i++) {
			cows[i] = io.nextInt();
			prefix[i + 1] = (prefix[i] + cows[i]) % 7;
		}

		int[] lastFound = new int[7];
		for (int i = 0; i < 7; i++) {
			lastFound[i] = -1;
		}

		int maximum = 0;
		for (int i = 0; i < n + 1; i++) {
			if (lastFound[prefix[i]] == -1) {
				lastFound[prefix[i]] = i;
			} else {
				maximum = Math.max(i - lastFound[prefix[i]], maximum);
			}
		}
		io.print(maximum);
        io.close();
	}

	//BeginCodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
with open("div7.in", "r") as read:
	n = int(read.readline())
	prefix = [0] * (n + 1)
	for i in range(n):
		cow = int(read.readline())
		prefix[i + 1] = (prefix[i] + cow) % 7


last_found = [-1] * 7
maximum = 0

for i in range(n + 1):
	if last_found[prefix[i]] == -1:
		last_found[prefix[i]] = i
	else:
		maximum = max(i - last_found[prefix[i]], maximum)

print(maximum, file=open("div7.out", "w"))
```

</PySection>
</LanguageSection>
