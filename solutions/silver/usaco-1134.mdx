---
id: usaco-1134
source: USACO Silver 2021 Open
title: Maze Tac Toe
author: Ruben Jing
---

[Official Analysis (C++)](https://usaco.org/current/data/sol_prob1_silver_open21.html)

## Explanation

To simulate Bessie's traveling through the maze, we can use DFS. During DFS, we also
keep track of the state of the game board.

If during DFS, we find a move, which is represented by 'M' or 'O' followed by
two numbers representing the coordinate on the moo-tac-toe game board, we
update our board as long as the square is empty.

For example, if our board looks like

```
. M .
. O .
. . .
```
and we get `M22`, no update is made. However, if we get `O32`, our board will be updated to

```
. M .
. O .
. O .
```

After we update our board, we check if Bessie has won. We can hard code every winning possibility
considering theres so little cases to check.

During DFS, if we have already visited a square with our current board state, we stop iterating. However,
if we have visited a square but with a different board state, we can continue iteration.

In order to keep track of which positions we have visited with which board, we can use a three dimensional
array. The first two dimensions represent position and the last dimension represents state.

Notice how each square in the board only has three possibilities: blank, O, or M. We can assign
blank to 0, O to 1, and M to 2.

Due to there being only three possibilities, we can make the board into a ternary number, e.g.

```
0 2 0
0 1 0
0 0 0
```
becomes

`020010000`

We convert the ternary number into a decimal to assure uniqueness. We only have 9 characters in the board,
so the general formula to convert from ternary to decimal is:
$$
\text{board[row][column]} \times 3^{3 \times \text{row} + \text{column}}
$$
for every cell in the board. The biggest number will be $19682$.

We can keep the board as a string to make our implementation more clear and intuitive. This approach will suffice for
C++ and Java.

Unfortunately, due to Python's slow nature, this solution must be sped up. We do not keep the board as a string but rather
keep it in its ternary form.

To extract a character at index $i$ from the board, we divide by $3^i$ to remove the first $i$ digits and then $%3$.

To add a new character $c$ at index $i$ with board $b$, we have the following operation:
$$
b = (b \% 3^i) + c \times 3^i + (b - b \% 3^{i + 1})
$$
which effectively adds the character before index $i$, the new character, and the characters after index $i$.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

struct Point {
	char id;
	int x;
	int y;
};

vector<vector<Point>> grid(25, vector<Point>(25));
bool visited[25][25][19683];
set<string> res;
int powThree[9];

bool isWin(string &gameStr) {
	// case 1: diagonal
	if (gameStr[0] == 'M' && gameStr[4] == 'O' && gameStr[8] == 'O') return true;
	if (gameStr[2] == 'M' && gameStr[4] == 'O' && gameStr[6] == 'O') return true;

	if (gameStr[0] == 'O' && gameStr[4] == 'O' && gameStr[8] == 'M') return true;
	if (gameStr[2] == 'O' && gameStr[4] == 'O' && gameStr[6] == 'M') return true;

	// case 2: rows 1, 2, 3
	for (int i = 0; i < 9; i += 3) {
		if (gameStr[i] == 'M' && gameStr[i + 1] == 'O' && gameStr[i + 2] == 'O')
			return true;
		if (gameStr[i] == 'O' && gameStr[i + 1] == 'O' && gameStr[i + 2] == 'M')
			return true;
	}

	// case 3: columns 1, 2, 3
	if (gameStr[2] == 'M' && gameStr[5] == 'O' && gameStr[8] == 'O') return true;
	for (int i = 0; i < 3; i++) {
		if (gameStr[i] == 'M' && gameStr[i + 3] == 'O' && gameStr[i + 6] == 'O')
			return true;
		if (gameStr[i] == 'O' && gameStr[i + 3] == 'O' && gameStr[i + 6] == 'M')
			return true;
	}

	return false;
}

int encodeString(string str) {
	int state = 0;

	for (int i = 0; i < 9; i++) {
		int num = 0;

		if (str[i] == 'O') {
			num = 1;
		} else if (str[i] == 'M') {
			num = 2;
		}

		state += (num * powThree[i]);
	}

	return state;
}

void dfs(int i, int j, string gameStr) {
	int state = encodeString(gameStr);

	if (visited[i][j][state]) return;

	visited[i][j][state] = true;

	Point p = grid[i][j];

	if (p.id != 'B' && p.id != '#' && p.id != '.') {
		if (gameStr[(p.y - 1) * 3 + (p.x - 1)] == ' ') {
			gameStr[(p.y - 1) * 3 + (p.x - 1)] = p.id;
		}
	}

	if (isWin(gameStr)) {
		res.insert(gameStr);
		return;
	}

	if (grid[i - 1][j].id != '#') dfs(i - 1, j, gameStr);
	if (grid[i][j - 1].id != '#') dfs(i, j - 1, gameStr);
	if (grid[i + 1][j].id != '#') dfs(i + 1, j, gameStr);
	if (grid[i][j + 1].id != '#') dfs(i, j + 1, gameStr);
};

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	int n;
	cin >> n;
	pair<int, int> bessie;

	for (int i = 0; i < n; i++) {
		for (int co = 0, j = 0; co < n * 3; co += 3, j++) {
			Point &p = grid[i][j];

			char a, b, c;
			cin >> a >> b >> c;

			p.id = a;
			p.x = -1;
			p.y = -1;

			if (a == 'M' || a == 'O') {
				p.x = b - '0';
				p.y = c - '0';
			} else if (a == 'B') {
				bessie = make_pair(i, j);
			}
		}
	}

	powThree[0] = 1;
	for (int i = 1; i < 9; i++) { powThree[i] = powThree[i - 1] * 3; }

	dfs(bessie.first, bessie.second, "         ");

	cout << res.size() << "\n";
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class MazeTacToe {
	static int[] powThree = new int[9];
	static boolean[][][] visited = new boolean[25][25][19683];
	static Set<String> results = new HashSet<>();
	static Point[][] grid;

	static boolean isWin(String gameStr) {
		// case 1: diagonal
		if (gameStr.charAt(0) == 'M' && gameStr.charAt(4) == 'O' &&
		    gameStr.charAt(8) == 'O')
			return true;
		if (gameStr.charAt(2) == 'M' && gameStr.charAt(4) == 'O' &&
		    gameStr.charAt(6) == 'O')
			return true;

		if (gameStr.charAt(0) == 'O' && gameStr.charAt(4) == 'O' &&
		    gameStr.charAt(8) == 'M')
			return true;
		if (gameStr.charAt(2) == 'O' && gameStr.charAt(4) == 'O' &&
		    gameStr.charAt(6) == 'M')
			return true;

		// case 2: rows 1, 2, 3
		for (int i = 0; i < 9; i += 3) {
			if (gameStr.charAt(i) == 'M' && gameStr.charAt(i + 1) == 'O' &&
			    gameStr.charAt(i + 2) == 'O')
				return true;
			if (gameStr.charAt(i) == 'O' && gameStr.charAt(i + 1) == 'O' &&
			    gameStr.charAt(i + 2) == 'M')
				return true;
		}

		// case 3: columns 1, 2, 3
		for (int i = 0; i < 3; i++) {
			if (gameStr.charAt(i) == 'M' && gameStr.charAt(i + 3) == 'O' &&
			    gameStr.charAt(i + 6) == 'O')
				return true;
			if (gameStr.charAt(i) == 'O' && gameStr.charAt(i + 3) == 'O' &&
			    gameStr.charAt(i + 6) == 'M')
				return true;
		}

		return false;
	}

	static int encodeString(String str) {
		int state = 0;

		for (int i = 0; i < 9; i++) {
			int num = 0;

			char c = str.charAt(i);
			if (c == 'O') {
				num = 1;
			} else if (c == 'M') {
				num = 2;
			}

			state += (num * powThree[i]);
		}

		return state;
	}

	static void dfs(int i, int j, String gameStr) {
		int state = encodeString(gameStr);

		if (visited[i][j][state]) return;

		visited[i][j][state] = true;

		Point p = grid[i][j];

		if (p.id != 'B' && p.id != '#' && p.id != '.') {
			int idx = (p.y - 1) * 3 + (p.x - 1);

			if (gameStr.charAt(idx) == ' ') {
				StringBuilder sb = new StringBuilder(gameStr);

				sb.setCharAt(idx, p.id);
				gameStr = sb.toString();
			}
		}

		if (isWin(gameStr)) {
			results.add(gameStr);
			return;
		}

		if (grid[i - 1][j].id != '#') dfs(i - 1, j, gameStr);
		if (grid[i][j - 1].id != '#') dfs(i, j - 1, gameStr);
		if (grid[i + 1][j].id != '#') dfs(i + 1, j, gameStr);
		if (grid[i][j + 1].id != '#') dfs(i, j + 1, gameStr);
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

		int n = Integer.parseInt(br.readLine().trim());
		grid = new Point[n][n];

		int bessieX = -1, bessieY = -1;

		for (int i = 0; i < n; i++) {
			String line = br.readLine();
			for (int co = 0, j = 0; co < n * 3; co += 3, j++) {
				char a = line.charAt(co);
				char b = line.charAt(co + 1);
				char c = line.charAt(co + 2);

				Point p = new Point();

				p.id = a;

				if (a == 'M' || a == 'O') {
					p.x = b - '0';
					p.y = c - '0';
				} else if (a == 'B') {
					bessieY = i;
					bessieX = j;
				}

				grid[i][j] = p;
			}
		}

		powThree[0] = 1;
		for (int i = 1; i < 9; i++) { powThree[i] = powThree[i - 1] * 3; }

		dfs(bessieY, bessieX, "         ");

		out.println(results.size());
		out.flush();
	}

	private static class Point {
		char id;
		int x, y;

		Point() {
			this.id = ' ';
			this.x = -1;
			this.y = -1;
		}
	}
}
```

</JavaSection>
<PySection>

```py
import sys

sys.setrecursionlimit(1000000)
input = sys.stdin.readline


def test_win(state):
	cells = [[0] * 3 for _ in range(3)]
	b = state
	for i in range(3):
		for j in range(3):
			cells[i][j] = b % 3
			b //= 3

	for r in range(3):
		if cells[r][0] == 2 and cells[r][1] == 1 and cells[r][2] == 1:
			return True
		if cells[r][0] == 1 and cells[r][1] == 1 and cells[r][2] == 2:
			return True

	for c in range(3):
		if cells[0][c] == 2 and cells[1][c] == 1 and cells[2][c] == 1:
			return True
		if cells[0][c] == 1 and cells[1][c] == 1 and cells[2][c] == 2:
			return True

	if cells[0][0] == 2 and cells[1][1] == 1 and cells[2][2] == 1:
		return True
	if cells[0][0] == 1 and cells[1][1] == 1 and cells[2][2] == 2:
		return True
	if cells[2][0] == 2 and cells[1][1] == 1 and cells[0][2] == 1:
		return True
	if cells[2][0] == 1 and cells[1][1] == 1 and cells[0][2] == 2:
		return True

	return False


def dfs(i, j, b):
	if visited[i][j][b]:
		return

	visited[i][j][b] = True

	a, x, y = grid[i][j]

	if a == "M" or a == "O":
		r, c = y - 1, x - 1

		idx = r * 3 + c
		current_char = (b // pow3[idx]) % 3

		if current_char == 0:
			new_char = 1 if a == "O" else 2

			b = (b % pow3[idx]) + new_char * pow3[idx] + (b - b % pow3[idx + 1])

			if not visited[i][j][b] and test_win(b):
				answers.add(b)
				return

			visited[i][j][b] = True

	if grid[i - 1][j][0] != "#":
		dfs(i - 1, j, b)
	if grid[i + 1][j][0] != "#":
		dfs(i + 1, j, b)
	if grid[i][j - 1][0] != "#":
		dfs(i, j - 1, b)
	if grid[i][j + 1][0] != "#":
		dfs(i, j + 1, b)


n = int(input())
grid = [[None] * n for _ in range(n)]
bessie = None

for i in range(n):
	line = input().strip()
	for j in range(n):
		a, b, c = line[j * 3], line[j * 3 + 1], line[j * 3 + 2]
		if a == "M" or a == "O":
			grid[i][j] = (a, int(b), int(c))
		else:
			grid[i][j] = (a, -1, -1)
			if a == "B":
				bessie = (i, j)

pow3 = [1] * 10
for i in range(1, 10):
	pow3[i] = pow3[i - 1] * 3

visited = [[[False] * 19683 for _ in range(n)] for _ in range(n)]
answers = set()

dfs(bessie[0], bessie[1], 0)

print(len(answers))
```

</PySection>
</LanguageSection>
