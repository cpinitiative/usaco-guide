---
id: cf-1216C
source: CF 1216C
title: D3C - White Sheet
author: David Zhang
---

[Official Analysis (C++)](https://codeforces.com/blog/entry/69954)

## Explanation

There are many ways to solve the problem, but the easiest way is to imagine cutting the white sheet. 

Everytime the white sheet is covered by a black sheet, we can imagine cutting the intersection between the black and white sheets. Then, if the area of the final white sheet after being cut by the two rectangles is greater than zero, there is a portion of the white sheet that is visible.

However, when considering cutting the sheet, the portion that is being cut must cut from entirely x1->x2 or y1->y2 or else there will be a portion of the white sheet still shown. We only cut when a black sheet completely covers the entire width or length of the white sheet, otherwise there will still be bits and pieces shown.


There are 4 instances of which a white sheet can cover a black sheet.

$\textbf{Top: }$ From the top, if the white sheet is completely covered from x1 to x2 and intersects some part of a black sheet, then change the y2 (top of the rectangle) to the bottom of the black rectangle.

$\textbf{Bottom: }$ From the bottom, if the white sheet is completely covered from x1 to x2 and intersects some part of a black sheet, then change the y1 (bottom of the rectangle) to the top of the black rectangle.

$\textbf{Left: }$ From the left, if the white sheet is completely covered from y1 to y2 and intersects some part of a black sheet, then change the x1 (left edge of the rectangle) to the right edge of the black rectangle.

$\textbf{Right: }$ From the right, if the white sheet is completely covered from y1 to y2 and intersects some part of a black sheet, then change the x2 (right edge of the rectangle) to the left edge of the black rectangle.

Also, keep in mind to make sure that x1 is always < x2 and the same with y1 and y2.

## Implementation

**Time Complexity:** $\mathcal{O}(1)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Rect{
	int x1, y1, x2, y2;
	int area()
	{
		return (x2 - x1) * (y2 - y1);
	}
};
Rect cut(Rect a, Rect b) {
	//if B intersects entirely in the 
	//x or y direction, cut it
	if(a.x1 >= b.x1 && b.x2 >= a.x1 && b.y1 <= a.y1 && b.y2 >= a.y2)
	{
		//if B cuts A from the left side
		a.x1 = b.x2;
		a.x2 = max(a.x2, b.x2); // if b covers A entirely
	}
	if(a.x2 >= b.x1 && b.x2 >= a.x2 && b.y1 <= a.y1 && b.y2 >= a.y2)
	{
		//if B cuts A from the right side
		a.x2 = b.x1;
		a.x1 = min(a.x1, b.x1); // if b covers A entirely
	}
	if(a.y1 >= b.y1 && b.y2 >= a.y1 && b.x1 <= a.x1 && b.x2 >= a.x2)
	{
		//if B cuts A from the bottom side
		a.y1 = b.y2;
		a.y2 = max(a.y2, b.y2); // if b covers A entirely
	}
	if(a.y2 >= b.y1 && b.y2 >= a.y2 && b.x1 <= a.x1 && b.x2 >= a.x2)
	{
		//if B cuts A from the top side
		a.y2 = b.y1;
		a.y1 = min(a.y1, b.y1); // if b covers A entirely
	}
	return a;
}
int main(){
	Rect a,b,c;
	cin >> a.x1 >> a.y1 >> a.x2 >> a.y2;
	cin >> b.x1 >> b.y1 >> b.x2 >> b.y2;
	cin >> c.x1 >> c.y1 >> c.x2 >> c.y2;
	
	a = cut(a, b);
	a = cut(a, c);
	if(a.x2 - a.x1 == 0 || a.y2 - a.y1 == 0) //area!=0
		cout << "YES" << endl;
	else
		cout << "NO" <<endl;
}
```

</CPPSection>

<PySection>
```python
class Rect: 
 	x1, y1, x2, y2 = 0, 0, 0, 0
	def __init__(self, a, b, c, d):
		self.x1, self.y1, self.x2, self.y2 = a, b, c, d
	def area(self):
		return (self.x2 - self.x1)*(self.y2 - self.y1)

def cut(a, b):
 	if(a.x1 >= b.x1 and b.x2 >= a.x1 and b.y1 <= a.y1 and b.y2 >= a.y2):
		#if B cuts A from the left side
		a.x1 = b.x2
		a.x2 = max(a.x2, b.x2) # if b covers A entirely
  	if(a.x2 >= b.x1 and b.x2 >= a.x2 and b.y1 <= a.y1 and b.y2 >= a.y2):
		#if B cuts A from the right side
		a.x2 = b.x1;
		a.x1 = min(a.x1, b.x1) # if b covers A entirely
  	if(a.y1 >= b.y1 and b.y2 >= a.y1 and b.x1 <= a.x1 and b.x2 >= a.x2):
		#if B cuts A from the bottom side
		a.y1 = b.y2;
		a.y2 = max(a.y2, b.y2) # if b covers A entirely
  	if(a.y2 >= b.y1 and b.y2 >= a.y2 and b.x1 <= a.x1 and b.x2 >= a.x2):
		#if B cuts A from the top side
		a.y2 = b.y1;
		a.y1 = min(a.y1, b.y1) #if b covers A entirely
	
	return a
x = input().split()
y = input().split()
z = input().split()

a = Rect(int(x[0]), int(x[1]), int(x[2]), int(x[3]))
b = Rect(int(y[0]), int(y[1]), int(y[2]), int(y[3]))
c = Rect(int(z[0]), int(z[1]), int(z[2]), int(z[3]))

a = cut(a, b);
a = cut(a, c);
if(a.x2 - a.x1 == 0 || a.y2 - a.y1 == 0): #area!=0
 	print("YES")
else:
 	print("NO")
```
</PySection>

<JavaSection>
```java
import java.util.*;
import java.lang.*;
import java.io.*;
public class Main {
  
 	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		Rect a = new Rect(io.nextInt(), io.nextInt(), io.nextInt(), io.nextInt());
		Rect b = new Rect(io.nextInt(), io.nextInt(), io.nextInt(), io.nextInt());
		Rect c = new Rect(io.nextInt(), io.nextInt(), io.nextInt(), io.nextInt());
		a = cut(a, b);
		a = cut(a, c);
		if(a.x2 - a.x1 == 0 || a.y2 - a.y1 ==0) //area!=0
			System.out.println("NO");
		else
			System.out.println("YES");
 		io.close();
  	}
	static class Kattio extends PrintWriter {
		private BufferedReader r;
		private StringTokenizer st;
		// standard input
		public Kattio() { this(System.in, System.out); }
		public Kattio(InputStream i, OutputStream o) {
			super(o);
			r = new BufferedReader(new InputStreamReader(i));
		}
		// USACO-style file input
		public Kattio(String problemName) throws IOException {
			super(problemName + ".out");
			r = new BufferedReader(new FileReader(problemName + ".in"));
		}
		// returns null if no more input
		public String next() {
			try {
				while (st == null || !st.hasMoreTokens())
					st = new StringTokenizer(r.readLine());
				return st.nextToken();
			} catch (Exception e) { }
			return null;
		}
		public int nextInt() { return Integer.parseInt(next()); }
		public double nextDouble() { return Double.parseDouble(next()); }
		public long nextLong() { return Long.parseLong(next()); }
	}
	static class Rect{
		int x1, y1, x2, y2;
		public Rect(int a, int b, int c, int d){
			x1 = a;
			y1 = b;
			x2 = c;
			y2 = d;
		}
		int area()
		{
			return (x2 - x1) * (y2 - y1);
		}
	}
	static Rect cut(Rect a, Rect b) {
		//if B intersects entirely in the 
		//x or y direction, cut it
		if(a.x1 >= b.x1 && b.x2 >= a.x1 && b.y1 <= a.y1 && b.y2 >= a.y2)
		{
			//if B cuts A from the left side
			a.x1 = b.x2;
			a.x2 = Math.max(a.x2, b.x2); // if b covers A entirely
		}
		if(a.x2 >= b.x1 && b.x2 >= a.x2 && b.y1 <= a.y1 && b.y2 >= a.y2)
		{
			//if B cuts A from the right side
			a.x2 = b.x1;
			a.x1 = Math.min(a.x1, b.x1); // if b covers A entirely
		}
		if(a.y1 >= b.y1 && b.y2 >= a.y1 && b.x1 <= a.x1 && b.x2 >= a.x2)
		{
			//if B cuts A from the bottom side
			a.y1 = b.y2;
			a.y2 = Math.max(a.y2, b.y2); // if b covers A entirely
		}
		if(a.y2 >= b.y1 && b.y2 >= a.y2 && b.x1 <= a.x1 && b.x2 >= a.x2)
		{
			//if B cuts A from the top side
			a.y2 = b.y1;
			a.y1 = Math.min(a.y1, b.y1); // if b covers A entirely
		}
		return a;
	}
}
```

</JavaSection>

</LanguageSection>

## Extra Advice
Especially with rectangle geometry, make a good habit of drawing patterns and observations on a scratch sheet of paper or whiteboard. It helps a lot - David Zhang.

Also if you don't understand the explanation, draw each possibility (Top, Bottom, Left and Right) on a sheet of paper and try to see the connections.
