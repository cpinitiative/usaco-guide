---
id: usaco-944
source: USACO Silver 2019 US Open
title: Fence Planning
author: Brad Ma
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_fenceplan_silver_open19.html)

## Implementation
**Time Complexity:** $\mathcal{O}(N + M)$

<LanguageSection>
  
<JavaSection>

```java
import java.util.*;
import java.io.*;

public class FencePlan {
	static Cow[] cows;
	static List<Integer>[] graph;
	static boolean[] visited;
	static int lowX = Integer.MAX_VALUE;
	static int highX = Integer.MIN_VALUE;
	static int lowY = Integer.MAX_VALUE;
	static int highY = Integer.MIN_VALUE;

	static class Cow {  // class to keep track of the x and y
		int x;
		int y;
	}

	static void floodfill (int currentCow) {  // dfs flood fill
		visited[currentCow] = true;  // mark as visited
		Cow cow = cows[currentCow];

		lowX = Integer.min(lowX, cow.x);  // take minimum and maximums
		highX = Integer.max(highX, cow.x);
		lowY = Integer.min(lowY, cow.y);
		highY = Integer.max(highY, cow.y);

		for (int connectedCow : graph[currentCow]) {  // for each connected cow
			if (!visited[connectedCow]) {
				floodfill(connectedCow);
			}
		}
	}

	public static void main (String[] args) throws IOException {
		Kattio io = new Kattio("fenceplan");

		int n = io.nextInt();
		int m = io.nextInt();
		visited = new boolean[n + 1];  // one-indexed
		cows = new Cow[n + 1];

		for (int x = 1; x <= n; x++) {  // read cow coordinates
			Cow cow = new Cow();
			cow.x = io.nextInt();
			cow.y = io.nextInt();
			cows[x] = cow;
		}

		graph = new ArrayList[n + 1];  // one indexed
		for (int x = 0; x < graph.length; x++) {  // initialize
			graph[x] = new ArrayList<>();
		}

		for (int x = 0; x < m; x++) {  // read connections
			int a = io.nextInt();
			int b = io.nextInt();
			graph[a].add(b);  // add to the bi-directional unweighted graph
			graph[b].add(a);
		}

		int lowestPerimeter = Integer.MAX_VALUE;
		for (int cow = 1; cow <= n; cow++) {  // go through each connected component
			if (!visited[cow]) {
				floodfill(cow);

				// calculate the perimeter
				int perimeter = ((highX - lowX) + (highY - lowY)) * 2; 
				lowestPerimeter = Math.min(lowestPerimeter, perimeter);  // track lowest

				lowX = Integer.MAX_VALUE;  // reset values
				highX = Integer.MIN_VALUE;
				lowY = Integer.MAX_VALUE;
				highY = Integer.MIN_VALUE;
			}
		}
		io.println(lowestPerimeter);
		io.close();
	}
	//CodeSnip{Kattio}
}
```
  
</JavaSection>
  
</LanguageSection>
	
## Implementation in C++
	
<JavaSection>
	

```cpp
	
	#include <bits/stdc++.h>
	#define ll long long int
	#define f(i,n) for(long long int i=0;i<n;i++)
	#define f1(i,n) for(long long int i=1;i<n;i++)
	#define vll vector<ll>
	#define pb push_back
	#define mp make_pair
	#define ff first
	#define ss second
	#define rev(v) reverse(v.begin(),v.end())
	#define srt(v) sort(v.begin(),v.end())
	#define grtsrt(v) sort(v.begin(),v.end(),greater<ll>())
	#define grtsrt2(v) sort(v.rbegin(),v.rend())
	#define mnv(v) *min_element(v.begin(),v.end())
	#define mxv(v) *max_element(v.begin(),v.end())
	#define M1 1000000007
	#define mod 1000000007
	#define N 1000001

	using namespace std;
	
	void dfs(int vertex, vector<int> &temp){
	    vis[vertex] = true;
	    temp.pb(vertex);
	    for(int child : g[vertex]){
		if(vis[child])  continue;
		dfs(child,temp);
	    }
	}

	void solve() {
	    freopen("fenceplan.in", "r", stdin);
		freopen("fenceplan.out", "w", stdout);
		int n,m,a,b;
	    cin>>n>>m;
	    vector<pair<int,int>> pos(n);
	    f(i,n){
		cin>>pos[i].first>>pos[i].second;
	    }
	    f(i,m){
		cin>>a>>b;
		g[a].pb(b);
		g[b].pb(a);
	    }
	    vector<int> temp;
	    f1(i,n+1){
		if(vis[i])  continue;
		temp.clear();
		dfs(i,temp);
		comps.pb(temp);
	    }

	    int ans = INT_MAX,peri,minx=INT_MAX,maxx=INT_MIN,miny=INT_MAX,maxy=INT_MIN;
	    f(i,comps.size()){
		minx=INT_MAX,maxx=INT_MIN,miny=INT_MAX,maxy=INT_MIN;
		f(j,comps[i].size()){
		    minx = min(minx,pos[comps[i][j]-1].first);
		    miny = min(miny,pos[comps[i][j]-1].second);
		    maxx = max(maxx,pos[comps[i][j]-1].first);
		    maxy = max(maxy,pos[comps[i][j]-1].second);
		}
		if(comps[i].size())
		peri = ((maxx-minx) + (maxy-miny))*2;
		else
		peri = 0;
		ans = min(ans,peri);
	    }
	    cout<<ans<<endl;
	}


	int main(){
		ios::sync_with_stdio(0);
		cin.tie(0);
	    f(i,N){
		vis[i]=false;
	    }
			solve();
		return 0;
	}
	
	//CODE BY VEDANT SHAH
```
</JavaSection>
