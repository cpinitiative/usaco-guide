---
id: cf-104048K
source: CF
title: Fullmetal Alchemist II
author: Ashok Narayan
---

## Explanation

We are given \(N\) strings and want to find the **shortest possible string** that contains **all of them as substrings**.

This is a variant of the **Shortest Common Superstring** problem. Since \(N\) is small, we can afford to try all orderings after some preprocessing.

---

## Step 1: Remove Redundant Strings

If a string \(A\) is a substring of another string \(B\), then we never need to explicitly include \(A\).  
Any superstring containing \(B\) will automatically contain \(A\).

Thus, we can safely **remove all strings that are substrings of other strings**.

### Efficient Substring Checking

We use **rolling hashes**:

- Precompute prefix hashes for each string.
- For every pair \((A, B)\) with \(|A| \le |B|\), compare the hash of \(A\) against all substrings of \(B\) with length \(|A|\).
- Each comparison runs in \(O(1)\) after preprocessing.

---

## Step 2: Compute Overlaps

When appending string \(B\) after string \(A\), we may overlap them if a suffix of \(A\) matches a prefix of \(B\).

### Definition

\[
\text{overlap}(A, B)
\]
is the length of the longest suffix of \(A\) that matches a prefix of \(B\).

The additional length needed is:
\[
|B| - \text{overlap}(A, B)
\]

---

## Step 3: Try All Permutations

For a permutation
\[
S_{p_1}, S_{p_2}, \dots, S_{p_k}
\]
the total length is:
\[
|S_{p_1}| + \sum_{i=2}^{k} (|S_{p_i}| - \text{overlap}(S_{p_{i-1}}, S_{p_i}))
\]

Since \(N \le 10\), we can brute force all permutations.

---

## Time Complexity

Let \(L\) be the maximum string length.

- Hash preprocessing: \(O(NL)\)
- Substring filtering: \(O(N^2 L)\)
- Overlap computation: \(O(N^2 L)\)
- Permutations: \(O(N! \cdot N)\)

Overall:
\[
O(N^2 L + N! \cdot N)
\]

---

## Implementation

<LanguageSection>
<CPPSection>

<pre><code className="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

class HashedString {
private:
    static const long long M = 1e9 + 9;
    static const long long B = 9973;
    static vector&lt;long long&gt; pow;
    vector&lt;long long&gt; p_hash;

public:
    int size;

    HashedString(const string &s) : p_hash(s.size() + 1) {
        while (pow.size() &lt;= s.size())
            pow.push_back((pow.back() * B) % M);

        size = s.size();
        p_hash[0] = 0;
        for (int i = 0; i &lt; size; i++)
            p_hash[i + 1] = (p_hash[i] * B + s[i]) % M;
    }

    long long get_hash(int l, int r) {
        long long res =
            p_hash[r + 1] - (p_hash[l] * pow[r - l + 1]) % M;
        return (res + M) % M;
    }
};

vector&lt;long long&gt; HashedString::pow = {1};

bool isSubstr(HashedString &a, HashedString &b) {
    for (int i = 0; i + a.size &lt;= b.size; i++) {
        if (a.get_hash(0, a.size - 1) ==
            b.get_hash(i, i + a.size - 1))
            return true;
    }
    return false;
}

int getMergeLength(HashedString &a, HashedString &b) {
    int max_overlap = 0;
    for (int len = 1; len &lt;= min(a.size, b.size); len++) {
        if (a.get_hash(a.size - len, a.size - 1) ==
            b.get_hash(0, len - 1)) {
            max_overlap = len;
        }
    }
    return b.size - max_overlap;
}

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;HashedString&gt; v;
    for (int i = 0; i &lt; n; i++) {
        string s;
        cin &gt;&gt; s;
        v.emplace_back(s);
    }

    sort(v.begin(), v.end(),
         [](auto &a, auto &b) { return a.size &lt; b.size; });

    vector&lt;HashedString&gt; filtered;
    for (int i = 0; i &lt; v.size(); i++) {
        bool keep = true;
        for (int j = i + 1; j &lt; v.size(); j++) {
            if (isSubstr(v[i], v[j])) {
                keep = false;
                break;
            }
        }
        if (keep) filtered.push_back(v[i]);
    }

    v = filtered;
    n = v.size();

    vector&lt;vector&lt;int&gt;&gt; merge_length(n, vector&lt;int&gt;(n));
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; n; j++)
            if (i != j)
                merge_length[i][j] = getMergeLength(v[i], v[j]);

    vector&lt;int&gt; perm(n);
    iota(perm.begin(), perm.end(), 0);

    int ans = INT_MAX;
    do {
        int cur = v[perm[0]].size;
        for (int i = 1; i &lt; n; i++)
            cur += merge_length[perm[i - 1]][perm[i]];
        ans = min(ans, cur);
    } while (next_permutation(perm.begin(), perm.end()));

    cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>

</CPPSection>
</LanguageSection>
