---
id: cf-104048K
source: CF
title: Fullmetal Alchemist II
author: Ashok Narayan
---

## Explanation

The problem asks us to find the length of the shortest string that contains a given set of $N$ strings as substrings. This is a variation of the Shortest Common Superstring problem. Since $N$ is small, we can use a brute-force approach with permutations combined with efficient string hashing.

### Step 1: Filtering Redundant Strings

First, observe that if a string $A$ is a substring of another string $B$, we never need to explicitly worry about "covering" $A$. If our result string contains $B$, it automatically contains $A$. Therefore, we can remove all strings that are substrings of other strings in the input set.

To check if string $A$ is a substring of $B$ efficiently, we can use **Rolling Hashes**. We compute the hash of $A$ and compare it against the hashes of all substrings of $B$ with length $|A|$.

### Step 2: Calculating Overlaps

Once we have a filtered set of unique strings, we need to arrange them in a specific order. When we concatenate string $A$ followed by string $B$, we can merge them if a suffix of $A$ matches a prefix of $B$. To minimize the total length, we want to maximize this overlap.

Let $\texttt{overlap}(A, B)$ be the length of the longest suffix of $A$ that is equal to a prefix of $B$. The cost (additional characters needed) to append $B$ after $A$ is $|B| - \texttt{overlap}(A, B)$.

We can precompute these overlap costs for every pair of strings $(i, j)$. Using rolling hashes, we can check equality of suffixes and prefixes in $\mathcal{O}(1)$ after $\mathcal{O}(L)$ preprocessing.

### Step 3: Finding the Best Permutation

After preprocessing the overlaps, the problem reduces to finding an ordering (permutation) of the strings $S_{p_1}, S_{p_2}, \dots, S_{p_k}$ such that the total length is minimized.

The total length for a specific permutation is:

$$
\text{len}(s_{p_1}) + \sum_{i=2}^{k} \bigl(\text{len}(s_{p_i}) - \text{overlap}(s_{p_{i-1}}, s_{p_i})\bigr)
$$



Since $N$ is small (implied by the problem type to be around 10 or fewer), we can iterate through all $N!$ permutations using `next_permutation` and calculate the total length for each, keeping the minimum.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2 L + N! \cdot N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

// BeginCodeSnip{HashedString}
class HashedString {
  private:
	// Change M and B if needed for collision avoidance
	static const long long M = 1e9 + 9;
	static const long long B = 9973;

	// pow[i] contains B^i % M
	static vector<long long> pow;

	// p_hash[i] is the hash of the first i characters of the given string
	vector<long long> p_hash;

  public:
	int size;
	HashedString(const string &s) : p_hash(s.size() + 1) {
		while (pow.size() <= s.size()) { pow.push_back((pow.back() * B) % M); }
		this->size = s.size();
		p_hash[0] = 0;
		for (int i = 0; i < s.size(); i++) {
			p_hash[i + 1] = ((p_hash[i] * B) % M + s[i]) % M;
		}
	}

	long long get_hash(int start, int end) const {
		long long raw_val = (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));
		return (raw_val % M + M) % M;
	}
};
vector<long long> HashedString::pow = {1};
// EndCodeSnip

// Checks if A is a substring of B
bool isSubstr(const HashedString &a, const HashedString &b) {
	int l = 0, r = a.size - 1;
	while (r < b.size) {
		if (a.get_hash(0, a.size - 1) == b.get_hash(l, r)) { return true; }
		l++;
		r++;
	}
	return false;
}

// Calculates the length added by appending b to a (Size of b - (longest suffix of a
// matching a prefix of b))
int getMergeLength(const HashedString &a, const HashedString &b) {
	int r = a.size - 1;
	int mx = 0;
	// Check overlaps of length k
	for (int k = 0; k < b.size; ++k) {
		if (r < 0) { break; }
		// Compare the hash of the suffix of a and the prefix of b with length k+1
		if (a.get_hash(r, a.size - 1) == b.get_hash(0, k)) { mx = k + 1; }
		r--;
	}
	// We only need to add the non-overlapping part of b
	return b.size - mx;
}

int main() {
	int n;
	cin >> n;
	vector<HashedString> v;
	vector<HashedString> tmp;
	vector<int> idx;

	// Read input
	for (int i = 0; i < n; ++i) {
		string s;
		cin >> s;
		v.push_back(HashedString(s));
	}

	// Step 1: Remove unneeded strings (those that are substrings of others)
	sort(v.begin(), v.end(),
	     [](const HashedString &a, const HashedString &b) { return a.size < b.size; });
	for (int i = 0; i < v.size(); ++i) {
		bool f = true;
		for (int j = i + 1; j < v.size(); ++j) {
			// If v[i] is smaller and is a substring of v[j], we don't need v[i]
			if (i == j || v[i].size > v[j].size) { continue; }
			if (isSubstr(v[i], v[j])) {
				f = false;
				break;
			}
		}
		if (f) { tmp.push_back(v[i]); }
	}
	v = tmp;
	n = v.size();

	// Step 2: Precompute merge costs
	// merge_length[i][j] stores the cost to append v[j] after v[i]
	vector<vector<int>> merge_length(n, vector<int>(n));
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (i == j) { continue; }
			merge_length[i][j] = getMergeLength(v[i], v[j]);
		}
	}

	// Initialize permutation indices
	for (int i = 0; i < n; ++i) { idx.push_back(i); }

	// Step 3: Try all permutations to find the minimal total length
	int ans = INT32_MAX;
	do {
		// Start with the full length of the first string
		int current_len = v[idx[0]].size;
		for (int i = 1; i < n; ++i) {
			// Add the cost of appending the next string in the sequence
			current_len += merge_length[idx[i - 1]][idx[i]];
		}
		ans = min(ans, current_len);
	} while (next_permutation(idx.begin(), idx.end()));

	cout << ans << '\n';
}
```
</CPPSection>
</LanguageSection>
