---
id: usaco-1138
source: USACO Gold 2021 Open
title: Portals
author: Maggie Liu, David Guo
---

## Solution 1 - Kruskal's

[Official Analysis (Java)](http://www.usaco.org/current/data/sol_prob2_gold_open21.html)

## Explanation

We first notice that movement is defined in terms of portals, so we mainly care about how the portals are connected.

Let's consider the undirected multigraph $G$ with $2N$ nodes such that:

- Every portal in the original graph corresponds to a node in $G$
- Every node $v$ in the original graph corresponds to edges $p_{v,0} \leftrightarrow p_{v,1}$ and $p_{v,2} \leftrightarrow p_{v,3}$ in $G$

We observe that each node in $G$ has degree exactly two, so $G$ is a union of disjoint cycles. Thus, our goal is to join all nodes in $G$ into a single cycle.

Let's suppose that portals $p_{v,0}$ and $p_{v,1}$ are not contained within the same cycle as $p_{v,2}$ and $p_{v,3}$ in $G$.

Then, by permuting the portals adjacent to node $v$ such that the adjacency list becomes $p_{v,0}, p_{v,2}, p_{v,1}, p_{v,3}$, we can combine all of $p_{v,0}, p_{v,1}, p_{v,2}, p_{v,3}$ into a single cycle. Essentially, each node can unite two cycles.

Notice that by replacing "cycles" with "connected components" above, we are encouraged to find a [Minimum Spanning Tree (MST)](/gold/mst). In other words, we wish to unite all disjoint connected components such that $G$ becomes connected.

Now, let's consider the graph $G'$ with the same nodes as $G$ and the following costs:

- For each node $v$, edges $p_{v,0} \leftrightarrow p_{v,1}$ and $p_{v,2} \leftrightarrow p_{v,3}$ have cost $0$
- For each node $v$, edge $p_{v,0} \leftrightarrow p_{v,2}$ has cost $c_v$ moonies

Specifically, the answer is the cost of the MST of $G'$, which can be found using Kruskal's algorithm or Prim's algorithm.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

struct Edge {
	int from, to, cost;
};
const int MAX_N = 100000;
int parent[MAX_N * 2];
int comp_size[MAX_N * 2];

// BeginCodeSnip{Standard DSU operations}
void init(int n) {
	for (int i = 0; i < n; i++) {
		parent[i] = i;
		comp_size[i] = 1;
	}
}

int find(int a) {
	if (a == parent[a]) { return a; }
	return parent[a] = find(parent[a]);
}

bool unite(int a, int b) {
	int root_a = find(a), root_b = find(b);
	if (root_a == root_b) { return false; }
	if (comp_size[root_a] > comp_size[root_b]) { swap(root_a, root_b); }
	parent[root_a] = root_b;
	comp_size[root_b] += comp_size[root_a];
	return true;
}
// EndCodeSnip

int main() {
	int n;
	cin >> n;
	init(n * 2);
	int cost, p1, p2, p3, p4;
	vector<Edge> edges;
	for (int i = 0; i < n; i++) {
		cin >> cost >> p1 >> p2 >> p3 >> p4;
		// an edge from p1 to p2 or from p3 to p4 has 0 cost
		edges.push_back({p1 - 1, p2 - 1, 0});
		edges.push_back({p3 - 1, p4 - 1, 0});
		// to get an edge from p1 to p3, we need to pay to permute the portals
		edges.push_back({p1 - 1, p3 - 1, cost});
	}

	// sort edges in increasing order of cost
	sort(edges.begin(), edges.end(), [](Edge a, Edge b) { return a.cost < b.cost; });

	int min_cost = 0;
	for (Edge edge : edges) {
		if (unite(edge.from, edge.to)) { min_cost += edge.cost; }
	}
	cout << min_cost << endl;
}
```

</CPPSection>

</LanguageSection>

## Solution 2 - Prim's

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

const int MAX_N = 100000;
struct Node {
	int vertex, cost;
	bool operator>(Node other) const { return cost > other.cost; }
};
int main() {
	int n;
	cin >> n;
	priority_queue<Node, vector<Node>, greater<Node>> pq;
	vector<Node> adj[2 * MAX_N];
	for (int i = 0; i < n; i++) {
		int cost, p1, p2, p3, p4;
		cin >> cost >> p1 >> p2 >> p3 >> p4;
		p1--;
		p2--;
		p3--;
		p4--;
		// an edge connecting p1 and p2 or connecting p3 and p4 has cost 0
		adj[p1].push_back({p2, 0});
		adj[p2].push_back({p1, 0});
		adj[p3].push_back({p4, 0});
		adj[p4].push_back({p3, 0});
		// to get an edge from p1 to p3, we need to pay to permute the portals
		adj[p1].push_back({p3, cost});
		adj[p3].push_back({p1, cost});
	}
	pq.push({0, 0});
	bool visited[2 * MAX_N]{};
	int min_cost = 0;
	// use Prim's to find the MST
	while (!pq.empty()) {
		int curr = pq.top().vertex, cost = pq.top().cost;
		pq.pop();
		if (visited[curr]) { continue; }
		visited[curr] = true;
		min_cost += cost;
		// add edges from the current, visited vertex to unvisited vertices
		for (Node next : adj[curr]) {
			if (!visited[next.vertex]) { pq.push(next); }
		}
	}
	cout << min_cost << endl;
}
```

</CPPSection>

</LanguageSection>
