---
id: usaco-1138
source: USACO Gold 2021 Open
title: Portals
author: Maggie Liu
---

## Solution 1 - Kruskal's

[Official Analysis](http://www.usaco.org/current/data/sol_prob2_gold_open21.html)

## Implementation

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

struct Edge {
	int from, to, cost;
};
const int MAX_N = 100000;
int parent[MAX_N * 2];
int comp_size[MAX_N * 2];

// BeginCodeSnip{Standard DSU operations}
void init(int n) {
	for (int i = 0; i < n; i++) {
		parent[i] = i;
		comp_size[i] = 1;
	}
}

int find(int a) {
	if (a == parent[a]) { return a; }
	return parent[a] = find(parent[a]);
}

bool unite(int a, int b) {
	int root_a = find(a), root_b = find(b);
	if (root_a == root_b) { return false; }
	if (comp_size[root_a] > comp_size[root_b]) { swap(root_a, root_b); }
	parent[root_a] = root_b;
	comp_size[root_b] += comp_size[root_a];
	return true;
}
// EndCodeSnip

int main() {
	int n;
	cin >> n;
	init(n * 2);
	int cost, p1, p2, p3, p4;
	vector<Edge> edges;
	for (int i = 0; i < n; i++) {
		cin >> cost >> p1 >> p2 >> p3 >> p4;
		// an edge from p1 to p2 or from p3 to p4 has 0 cost
		edges.push_back({p1 - 1, p2 - 1, 0});
		edges.push_back({p3 - 1, p4 - 1, 0});
		// to get an edge from p1 to p3, we need to pay to permute the portals
		edges.push_back({p1 - 1, p3 - 1, cost});
	}

	// sort edges in increasing order of cost
	sort(edges.begin(), edges.end(),
	     [](Edge a, Edge b) { return a.cost < b.cost; });

	int min_cost = 0;
	for (Edge edge : edges) {
		if (unite(edge.from, edge.to)) { min_cost += edge.cost; }
	}
	cout << min_cost << endl;
}
```

</CPPSection>

</LanguageSection>

## Solution 2 - Prim's

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

const int MAX_N = 100000;
struct Node {
	int vertex, cost;
	bool operator>(Node other) const { return cost > other.cost; }
};
int main() {
	int n;
	cin >> n;
	priority_queue<Node, vector<Node>, greater<Node>> pq;
	vector<Node> adj[2 * MAX_N];
	for (int i = 0; i < n; i++) {
		int cost, p1, p2, p3, p4;
		cin >> cost >> p1 >> p2 >> p3 >> p4;
		p1--;
		p2--;
		p3--;
		p4--;
		// an edge connecting p1 and p2 or connecting p3 and p4 has cost 0
		adj[p1].push_back({p2, 0});
		adj[p2].push_back({p1, 0});
		adj[p3].push_back({p4, 0});
		adj[p4].push_back({p3, 0});
		// to get an edge from p1 to p3, we need to pay to permute the portals
		adj[p1].push_back({p3, cost});
		adj[p3].push_back({p1, cost});
	}
	pq.push({0, 0});
	bool visited[2 * MAX_N]{};
	int min_cost = 0;
	// use Prim's to find the MST
	while (!pq.empty()) {
		int curr = pq.top().vertex, cost = pq.top().cost;
		pq.pop();
		if (visited[curr]) { continue; }
		visited[curr] = true;
		min_cost += cost;
		// add edges from the current, visited vertex to unvisited vertices
		for (Node next : adj[curr]) {
			if (!visited[next.vertex]) { pq.push(next); }
		}
	}
	cout << min_cost << endl;
}
```

</CPPSection>

</LanguageSection>
