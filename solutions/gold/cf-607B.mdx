---
id: cf-607B
source: CF
title: Zuma
author: Kevin Sheng
---

[Official Analysis (C++)](https://codeforces.com/blog/entry/22256)

# Solution

## Explanation

In line with the spirit of range DP, let's define $dp[i][j]$ as the minimum
number of swipes it takes to clear all the gems between indices $i$ and $j$ inclusive.
If $i > j$ then there's no gems in the range and the array will return $0$.

There's two situations we can transition from.

The first is comparatively simpler, and it's where we erase either the
first or first two elements from the array (if they're equal).
In this case, the value we get is $dp[i+1][j]+1$ or $dp[i+2][j]+1$.

The second case is a bit nastier, and it may seem a bit unintuitive at first:

> If $i + 2 \le k \le j$ and the gems at positions $i$ and $k$ are the same color,
> then we can update with the following candidate value:
> $$
> dp[i+1][k-1]+dp[k+1][j]
> $$

You may wonder why there's no extra swipe involved in this transition.
After all, where did we clear gems $i$ and $k$?

The answer is that we can clear them along with the last swipe
that erased what was left in $dp[i+1][k-1]$.
Since the last swipe that cleared these gems was a palindrome, we can take on $i$
and $k$ to the start and end without any problems.

## Implementation

**Time Complexity:** $\mathcal{O}(N^3)$

<LanguageSection>
<JavaSection>

```java
import java.io.*;
import java.util.Arrays;

public class Zuma {
	public static void main(String[] args) throws IOException {
		BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
		int gemNum = Integer.parseInt(read.readLine());
		int[] gems = Arrays.stream(read.readLine().split(" "))
		                 .mapToInt(Integer::parseInt)
		                 .toArray();

		/*
		 * this[i][j] = min swipes to clear literally everything from i to j (inclusive)
		 * the +1 is to just have a buffer for some invalid range accesses
		 * (the array will always return 0 for invalid ranges)
		 */
		int[][] swipes = new int[gemNum + 1][gemNum];
		for (int i = 0; i < gemNum; i++) { swipes[i][i] = 1; }
		for (int len = 2; len <= gemNum; len++) {
			for (int start = 0; start <= gemNum - len; start++) {
				int end = start + len - 1;

				// maybe we just have to erase an end on its own
				swipes[start][end] = 1 + swipes[start + 1][end];

				for (int match = start + 2; match <= end; match++) {
					if (gems[start] == gems[match]) {
						// in this case the final swipe on the left range can also
						// clear the gem at start and match
						swipes[start][end] =
						    Math.min(swipes[start][end], swipes[start + 1][match - 1] +
						                                     swipes[match + 1][end]);
					}
				}

				// edge case for starting a new palindrome
				if (gems[start] == gems[start + 1]) {
					swipes[start][end] =
					    Math.min(swipes[start][end], swipes[start + 2][end] + 1);
				}
			}
		}

		System.out.println(swipes[0][gemNum - 1]);
	}
}
```

</JavaSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;
void solve() {
	int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) { cin >> v[i]; }
	vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
	for (int len = 1; len <= n; len++) {
		for (int i = 0; i + len <= n; i++) {
			int j = i + len - 1;
			dp[i][j] = 1 + dp[i + 1][j];
			if (i + 1 < n && v[i] == v[i + 1]) dp[i][j] = 1 + dp[i + 2][j];
			for (int k = i + 2; k <= j; k++) {
				if (v[i] == v[k]) {
					dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k + 1][j]);
				}
			}
		}
	}
	cout << dp[0][n - 1];
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int t = 1;
	// cin>>t;
	while (t--) { solve(); }
}
```
</CPPSection>
</LanguageSection>
