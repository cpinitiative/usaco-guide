---
id: cses-1747
source: CSES
title: Pyramid Array
author: Ashok Narayan
---

[Question](https://cses.fi/problemset/task/1747)

## Explanation

The problem asks for the minimum number of adjacent swaps required to transform an array into a pyramid (increasing then decreasing). Recall that the minimum number of adjacent swaps to reorder an array is equal to the number of inversions between the initial and final states.

### Greedy Strategy

To minimize inversions, we should greedily place the elements. Consider processing the elements from **largest to smallest**.
* The largest element $N$ must eventually end up at the "peak" of the pyramid. However, relative to the *other* elements, its final position doesn't strictly matter yetâ€”it just splits the array into a left side and a right side.
* For the next largest element, we want to place it as close to the peak as possible.
* In general, when we process the $k$-th largest element, all previously processed elements (which are larger) have already formed a "central block". We must place the current element either to the immediate **left** or immediate **right** of this block.

To minimize cost, we simply choose the side that requires crossing fewer "already placed" elements.

### Connection to Point Update Range Sum

Let's formalize this. We process elements in descending order of value. When we are at the element originally at index $i$:
1.  We need to know how many elements **already processed** (larger than current) are located at original indices $< i$. Let's call this count $L$.
2.  We need to know how many elements **already processed** are located at original indices $> i$. Let's call this $R$.
3.  The cost to add the current element is $\min(L, R)$.
4.  After processing, we mark index $i$ as "active" (containing a processed element).

This is a dynamic counting problem on indices. We can model the state of the array as a binary sequence of $0$s and $1$s, where a $1$ at index $j$ means the element originally at $j$ has been processed.
* **Query:** To find $L$, we need the sum of values in the range $[0, i-1]$. This is a **Range Sum Query**.
* **Update:** To mark index $i$ as processed, we change the value at $i$ from $0$ to $1$. This is a **Point Update**.

Since we need both operations to be efficient, a **Binary Indexed Tree (Fenwick Tree)**. In this questions we can very well proceed with **Segment Tree** too.

### Time Complexity

* **Sorting:** $O(N \log N)$ to sort elements by value.
* **Data Structure:** We perform $N$ queries and $N$ updates. Using a BIT, this takes $O(N \log N)$.
* **Total:** $O(N \log N)$.

## Implementation

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

// BeginCodeSnip{FenwickTree}
struct FenwickTree {
	int size;
	vector<int> tree;

	FenwickTree(int n) : size(n), tree(n + 1, 0) {}

	// Adds delta to the element at index i (1-based)
	void add(int i, int delta) {
		while (i <= size) {
			tree[i] += delta;
			i += i & -i;
		}
	}

	// Returns the sum of elements from 1 to i
	int query(int i) {
		int sum = 0;
		while (i > 0) {
			sum += tree[i];
			i -= i & -i;
		}
		return sum;
	}
};
// EndCodeSnip

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	int n;
	cin >> n;

	// Store elements as {value, original_index}
	vector<pair<int, int>> elements(n);
	for (int i = 0; i < n; i++) {
		cin >> elements[i].first;
		elements[i].second = i + 1; // 1-based indexing 
	}

	// Sort in descending order to process largest elements first
	sort(elements.rbegin(), elements.rend());

	FenwickTree ft(n);
	long long total_swaps = 0;

	for (int i = 0; i < n; i++) {
		int current_pos = elements[i].second;

		// Calculate how many larger elements are already to the left
		int left_cost = ft.query(current_pos - 1);
		
		// Calculate how many larger elements are already to the right
		// 'i' is the total count of elements processed so far
		int right_cost = i - left_cost;

		// Greedily choose the side with fewer swaps
		total_swaps += min(left_cost, right_cost);

		// Mark this position as occupied (Point Update)
		ft.add(current_pos, 1);
	}

	cout << total_swaps << endl;

	return 0;
}
```
</CPPSection>
</LanguageSection>
