---
id: usaco-1085
source: USACO Bronze 2021 January
title: Just Stalling
author: Ananth Kashyap, David Guo
---

[Official Analysis (C++ and Java)](http://www.usaco.org/current/data/sol_prob3_bronze_jan21.html)

## Solution 1

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<int> cows(n);
	vector<int> stalls(n);
	for (int i = 0; i < n; i++) { cin >> cows[i]; }
	for (int i = 0; i < n; i++) { cin >> stalls[i]; }

	sort(cows.begin(), cows.end());
	sort(stalls.begin(), stalls.end());

	vector<long long> possible_places(n);
	// Create a list containing the number of stalls each cow can use
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (cows[i] <= stalls[j]) { possible_places[i]++; }
		}
	}

	long long possibilities = 1;
	/*
	 * For each cow, find out the number of stalls it can use in a valid permutation
	 * Use the formula provided in the explanation
	 * Multiply the cumulative product by this value
	 */
	for (int i = n - 1; i >= 0; i--) {
		possibilities *= possible_places[i] - (n - i - 1);
	}

	cout << possibilities << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class JustStalling {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());

		int[] cows = new int[n];
		int[] stalls = new int[n];

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { cows[i] = Integer.parseInt(st.nextToken()); }

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { stalls[i] = Integer.parseInt(st.nextToken()); }

		Arrays.sort(cows);
		Arrays.sort(stalls);

		long[] possiblePlaces = new long[n];
		// Create a list containing the number of stalls each cow can use
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (cows[i] <= stalls[j]) { possiblePlaces[i]++; }
			}
		}

		long possibilities = 1;
		/*
		 * For each cow, find out the number of stalls it can use in a valid permutation
		 * Use the formula provided in the explanation
		 * Multiply the cumulative product by this value
		 */
		for (int i = n - 1; i >= 0; i--) {
			possibilities *= possiblePlaces[i] - (n - i - 1);
		}

		System.out.println(possibilities);
	}
}
```

</JavaSection>
<PySection>

```py
n = int(input())
cows = sorted(map(int, input().split(" ")))
stalls = sorted(map(int, input().split(" ")))

possible_places = [0] * n
# Create a list containing the number of stalls each cow can use.
for i in range(n):
	for j in range(n):
		if cows[i] <= stalls[j]:
			possible_places[i] += 1

possibilities = 1
"""
For each cow, find out the number of stalls it can use in a valid permutation
Use the formula provided in the explanation
Multiply the cumulative product by this value
"""
for i in range(n - 1, -1, -1):
	possibilities *= possible_places[i] - (n - i - 1)

print(possibilities)
```

</PySection>
</LanguageSection>

## Solution 2

Instead of iterating through $\text{stalls}$ every time, we can use
[two pointers](/silver/two-pointers).

## Implementation

**Time Complexity:** $\mathcal{O}(N \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;

	vector<int> cows(n);
	vector<int> stalls(n);
	for (int &c : cows) { cin >> c; }
	for (int &s : stalls) { cin >> s; }

	sort(cows.begin(), cows.end());
	sort(stalls.begin(), stalls.end());

	long long possibilities = 1;
	int j = n - 1;
	for (int i = n - 1; i >= 1; i--) {
		while (j >= 0 && stalls[j] >= cows[i]) { j--; }
		possibilities *= i - j;
	}

	cout << possibilities << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class JustStalling {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());

		int[] cows = new int[n];
		int[] stalls = new int[n];

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { cows[i] = Integer.parseInt(st.nextToken()); }

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < n; i++) { stalls[i] = Integer.parseInt(st.nextToken()); }

		Arrays.sort(cows);
		Arrays.sort(stalls);

		long possibilities = 1;
		int j = n - 1;
		for (int i = n - 1; i >= 1; i--) {
			while (j >= 0 && stalls[j] >= cows[i]) { j--; }
			possibilities *= (i - j);
		}

		System.out.println(possibilities);
	}
}
```
</JavaSection>
<PySection>

```py
n = int(input())

cows = list(map(int, input().split()))
stalls = list(map(int, input().split()))

cows.sort()
stalls.sort()

possibilities = 1
j = n - 1
for i in range(n - 1, 0, -1):
	while j >= 0 and stalls[j] >= cows[i]:
		j -= 1

	possibilities *= i - j

print(possibilities)
```

</PySection>
</LanguageSection>
