---
id: apio-09-DiggingForOil
source: APIO 2009
title: Digging for Oil
author: Albert Ye, Ahmet Alp Orakci
---

[Official Analysis](https://dmoj.ca/problem/apio09p1/editorial)

## Explanation

We want the three largest disjoint $K \times K$ squares with the largest total
sums. Note that every pair of rectangles must be on opposite sides of some line.
This leaves us with two basic configurations; either there are two parallel
lines dividing the squares or there are two perpendicular lines. The
configurations are illustrated below:

![](<apio-09-DiggingForOil/apio09oil-fig1.png>)

Note that solutions need to account for all possible rotations of these
configurations.

### Configuration 1

In this configuration, we can find the answer for each non-middle subrectangle
using the method in Configuration 2. However, we need to use another recurrence
to find the middle rectangle. WLOG let the subrectangles be arranged in top-down
order, as the left-right order can be found similarly. Let $dp_{i, j}$ be the
answer for the rows in interval $[i,j]$. Obviously $dp_{i,i+l}$ has no answers
if $l < k-1$. We can also manually find $dp_{i, i+k}$ manually as a base case.
Next, note that $dp_{i,j}$ consists of all $K \times K$ squares counted in
$dp_{i+1, j}$ and $dp_{i, j-1}$. Then, there are just the squares counted in row
$i$ and row $j$, which is just $dp_{i, i+k-1}$ and $dp_{j-k+1, j}$ respectively.
Thus, the recurrence is
$$dp_{i,j} = \max(\max(dp_{i+1, j},dp_{i,i+k-1}), \max(dp_{i, j-1}, dp_{j-k+1, j})).$$
Note that intervals must be traversed from smallest to largest.

### Configuration 2

It suffices to use prefix sums. From each corner, find the sum of the values of
all points that can be reached solely by travelling towards that corner from a
point $(i, j)$, and store the value with $(i, j)$. We can use this to find the
total amount of oil for the $K \times K$ squares on each corner of $(i, j)$.
These values help us find the maximum amount of oil in a $K \times K$ square on
each corner of $(i, j)$. We then perform some casework for each reflection to
get the answer.

## Implementation

<LanguageSection>
<CPPSection>

You can rotate the grid for easier implementation.

```cpp
#include <bits/stdc++.h>

using i64 = long long;

template <typename T> bool chmax(T &a, T b) {
	if (a < b) {
		a = b;
		return true;
	}
	return false;
}

constexpr i64 inf = i64(1E18);

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int N, M, K;
	std::cin >> N >> M >> K;

	std::vector<std::vector<i64>> A(N, std::vector<i64>(M));
	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < M; ++j) { std::cin >> A[i][j]; }
	}

	i64 ans = 0;

	// Configuration 1 (parallel lines)
	for (int _ = 0; _ < 2; ++_) {
		std::vector<std::vector<i64>> pre(N, std::vector<i64>(M));
		for (int i = 0; i < N; ++i) {
			for (int j = 0; j < M; ++j) {
				pre[i][j] = A[i][j];
				if (i) pre[i][j] += pre[i - 1][j];
				if (j) pre[i][j] += pre[i][j - 1];
				if (i && j) pre[i][j] -= pre[i - 1][j - 1];
			}
		}

		auto sum = [&](int x1, int y1, int x2, int y2) {
			i64 res = pre[x2][y2];
			if (x1) res -= pre[x1 - 1][y2];
			if (y1) res -= pre[x2][y1 - 1];
			if (x1 && y1) res += pre[x1 - 1][y1 - 1];
			return res;
		};

		std::vector<i64> top1(N + 1, -inf), top2(N + 1, -inf);
		for (int i = 0; i + K - 1 < N; ++i) {
			chmax(top1[i + 1], top1[i]);
			for (int j = 0; j + K - 1 < M; ++j) {
				chmax(top1[i + K], sum(i, j, i + K - 1, j + K - 1));
			}
			chmax(top2[i + 1], top2[i]);
			for (int j = 0; j + K - 1 < M; ++j) {
				chmax(top2[i + K], top1[i] + sum(i, j, i + K - 1, j + K - 1));
			}
			for (int j = 0; j + K - 1 < M; ++j) {
				chmax(ans, top2[i] + sum(i, j, i + K - 1, j + K - 1));
			}
		}

		std::vector<std::vector<i64>> h(M, std::vector<i64>(N));
		for (int i = 0; i < N; ++i) {
			for (int j = 0; j < M; ++j) { h[j][i] = A[i][j]; }
		}
		A = std::move(h);
		std::swap(N, M);
	}

	// Configuration 2 (perpendicular lines)
	for (int _ = 0; _ < 4; ++_) {
		std::vector<std::vector<i64>> pre(N, std::vector<i64>(M));
		for (int i = 0; i < N; ++i) {
			for (int j = 0; j < M; ++j) {
				pre[i][j] = A[i][j];
				if (i) pre[i][j] += pre[i - 1][j];
				if (j) pre[i][j] += pre[i][j - 1];
				if (i && j) pre[i][j] -= pre[i - 1][j - 1];
			}
		}

		auto sum = [&](int x1, int y1, int x2, int y2) {
			i64 res = pre[x2][y2];
			if (x1) res -= pre[x1 - 1][y2];
			if (y1) res -= pre[x2][y1 - 1];
			if (x1 && y1) res += pre[x1 - 1][y1 - 1];
			return res;
		};

		std::vector<i64> top(N, -inf);
		for (int i = 0; i + K - 1 < N; ++i) {
			for (int j = 0; j + K - 1 < M; ++j) {
				chmax(top[i + K - 1], sum(i, j, i + K - 1, j + K - 1));
			}
		}

		for (int i = 1; i < N; ++i) { chmax(top[i], top[i - 1]); }

		std::vector<i64> lef(M, -inf), rig(M, -inf);

		for (int i = N - K; i >= 0; --i) {
			i64 mx = -inf;
			for (int j = 0; j < M; ++j) { chmax(mx, lef[j] + rig[j]); }

			chmax(ans, top[i] + mx);
			for (int j = 0; j + K - 1 < M; ++j) {
				chmax(lef[j + K - 1], sum(i, j, i + K - 1, j + K - 1));
			}
			for (int j = M - 1; j - K >= 0; --j) {
				chmax(rig[j - K], sum(i, j - K + 1, i + K - 1, j));
			}
			for (int j = 1; j < M; ++j) { chmax(lef[j], lef[j - 1]); }
			for (int j = M - 1; j >= 1; --j) { chmax(rig[j - 1], rig[j]); }
		}

		std::vector<std::vector<i64>> h(M, std::vector<i64>(N));
		for (int i = 0; i < N; ++i) {
			for (int j = 0; j < M; ++j) { h[M - j - 1][i] = A[i][j]; }
		}
		A = std::move(h);
		std::swap(N, M);
	}

	std::cout << ans << '\n';

	return 0;
}
```

</CPPSection>
</LanguageSection>
