---
id: spoj-DigitSum
source: SPOJ
title: Digit Sum
author: Chongtian Ma
---

## Explanation

Let's define the function $\mathtt{pref}(x)$ to return the sum of digits among all integers from $0$ to $x$ inclusive.
Then, the answer for each query will be $\mathtt{pref}(r) - \mathtt{pref}(l-1)$.

We can calculate $\mathtt{pref}(x)$ using digit dp. Let $n$ be the number of digits in $x$.
The maximum sum of digits among all numbers with at most $n$ digits is $9n$.
Under the problem constraints, $n$ can be at most $16$.

We can define the following dp state:
$\mathtt{dp[i][j][b]}$ = number of integers having exactly $i$ digits with sum of digits $j$ and a freedom value of $b$ (which is either $0$ or $1$).

- If $b = 0$, then the first $i$ digits of the state is equivalent to the first $i$ digits of $x$.
  In this case, when placing the $i+1$'th digit, it cannot exceed the $i+1$'th digit of $x$.

- If $b = 1$, then there exists some $d$ where $d < i$ and the $d$-th digit that we placed is less than the $d$-th digit of $x$.
  In this case, we already know our integer must be less than $x$, regardless of what digit we place next.

For transitions, we must consider the three cases where $b$ remains $0$,
$b$ remains $1$, and $b$ goes from $0$ to $1$.

Finally, the sum of digits among all integers with exactly $i$ digits and does not exceed $x$ is given by $\sum_{j=0}^{9n} \sum_{b=0}^1 \mathtt{dp[n][j][b]} \cdot j$.
However, we still have to add the sum of digits for all numbers with less than $n$ digits, which can be precalculated.

## Implementation

**Time Complexity:** $\mathcal{O}(n^2)$ for each query.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MAX_LEN = 17;
ll ans_pow10[MAX_LEN];

ll pref(ll upper) {
	string upper_str = to_string(upper);
	int n = upper_str.length();
	const int MAX_SUM = 9 * n + 1;
	// dp[current length][current digit sum][do we have freedom?] = # numbers
	vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(MAX_SUM, vector<ll>(2)));

	// initialize first digit
	int first_digit = upper_str[0] - '0';
	dp[0][first_digit][0] = 1;
	for (int i = 1; i < first_digit; i++) { dp[0][i][1] = 1; }

	int curr_sum = first_digit;
	for (int i = 1; i < n; i++) {
		// case 1: we continue not have freedom
		int next_digit = upper_str[i] - '0';
		dp[i][curr_sum + next_digit][0] = 1;

		// case 2: we previously did not have freedom, but now we do
		for (int j = 0; j < next_digit; j++) { dp[i][curr_sum + j][1]++; }

		// case 3: we always had freedom
		for (int j = 0; j < 10; j++) {
			for (int prev_sum = 0; prev_sum < MAX_SUM - j; prev_sum++) {
				dp[i][prev_sum + j][1] += dp[i - 1][prev_sum][1];
			}
		}
		curr_sum += next_digit;
	}

	ll ans = 0;
	// answer for all current digit numbers
	for (int sum = 0; sum < MAX_SUM; sum++) {
		for (int free = 0; free < 2; free++) { ans += dp[n - 1][sum][free] * sum; }
	}
	// answer for all smaller digit numbers
	ans += ans_pow10[n - 1];

	return ans;
}

int main() {
	// precompute answer for [0, 10^i - 1]
	ll pow10 = 1;
	for (int i = 1; i < MAX_LEN; i++) {
		pow10 *= 10;
		ans_pow10[i] = pref(pow10 - 1);
	}

	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		ll l, r;
		cin >> l >> r;
		if (l == 0) {
			// l - 1 < 0 which breaks things
			cout << pref(r) << '\n';
		} else {
			cout << pref(r) - pref(l - 1) << '\n';
		}
	}
}
```

</CPPSection>
</LanguageSection>

# Alternative solution

## Explanation

Let $\mathtt{pref}(x)$ be the same function as in the solution above.

Let's convert the number into a string and treat it as such.

Define $\mathtt{dp[i][b]}$ to be the sum of digits and the number of different numbers we can make in suffix starting from digit $i$, $b$ is the same freedom value as in the solution above. 

Let's look at our transitions:
- If the suffix is empty, the sum equals to $0$ and the amount equals to $1$.
- Otherwise, assume we try to place digit $d$ in a position $i$. Let $num$ be the amount of different numbers we can create in a suffix that starts at position $i+1$ after placing digit $d$, and let $sum$ be the sum of digits of such numbers. Then contribution of $d$ would be $d \cdot num$, and contributions of all the other positions in suffix would be $sum$.
- Our freedom value $b$ goes from $0$ to $1$ if we place digit $d$ that is less than digit at position $i$. We can't place digit $d$ if $b$ is $0$ and $d$ is greater than digit at position $i$.

The answer is the sum value at $\mathtt{dp[0][0]}$.

## Implementation

**Time Complexity:** $\mathcal{O}(n)$ for each query, where $n$ is the length of the number.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int max_n = 16;

// dp[i][b] = {sum_of_digits, amount}
array<ll, 2> dp[max_n][2];
string digits;
int number_length;

array<ll, 2> calc(int pos, bool is_free) {
	// Base case is we have an empty suffix, so total sum is 0 and total amount is 1
    if(pos == number_length) {
        return {0, 1};
    }
    if(dp[pos][is_free][0] != -1)
        return dp[pos][is_free];
    bool next_is_free;
    array<ll, 2> ans = {0, 0};
    for(int d = 0; d < 10; d++) {
		//This means our number would be too big
        if(is_free == false && d > (digits[pos] - '0'))
            break;
        next_is_free = is_free;
		//Update our freedom value
        if(is_free == false && d < (digits[pos] - '0'))
            next_is_free = true;
        auto next_state = calc(pos + 1, next_is_free);
		//Add amount of numbers to the current dp state
        ans[1] += next_state[1];
		//Add contribution of the current digit and total sum of digits after current digit
        ans[0] += d * next_state[1] + next_state[0];
    }
    return dp[pos][is_free] = ans;
}

//Reset the dp and digits and get the answer
ll pref(ll n) {
    if(n <= 0)
        return 0;
    digits = to_string(n);
    number_length = digits.size();
    for(int i = 0; i < number_length; i++) {
        for(int j = 0; j < 2; j++)
            dp[i][j] = {-1, 0};
    }
    return calc(0, false)[0];
}

void solve()
{
    ll l, r;
    cin >> l >> r;
    cout << pref(r) - pref(l - 1) << "\n";
    return ;
}

int main()
{
    ios_base::sync_with_stdio(0);cin.tie(0);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
```

</CPPSection>
</LanguageSection>
