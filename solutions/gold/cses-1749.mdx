---
id: cses-1749
source: CSES
title: List Removals
author: Benjamin Qi
---

## Solution 1

Use an indexed set.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;

template <class T>
using Tree =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

int main() {
	int n;
	cin >> n;
	Tree<int> ist;
	vector<int> p(n);
	for (int i = 0; i < n; i++) {
		ist.insert(i);
		cin >> p[i];
	}

	for (int i = 0; i < n; i++) {
		int ind;
		cin >> ind;
		ind--;
		int pos = *ist.find_by_order(ind);
		ist.erase(pos);
		cout << p[pos] << (i == n - 1 ? '\n' : ' ');
	}
}
```

</CPPSection>
</LanguageSection>

## Solution 2

Binary search on a BIT.

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int bits(int x) { return x == 0 ? 0 : 31 - __builtin_clz(x); }

/**
 * Description: range sum queries and point updates for $D$ dimensions
 * Source: https://codeforces.com/blog/entry/64914
 * Verification: SPOJ matsum
 * Usage: \texttt{BIT<int,10,10>} gives 2D BIT
 * Time: O((\log N)^D)
 */

template <class T, int... Ns> struct BIT {
	T val = 0;
	void upd(T v) { val += v; }
	T query() { return val; }
};

template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {
	BIT<T, Ns...> bit[N + 1];
	template <typename... Args> void upd(int pos, Args... args) {
		assert(pos > 0);
		for (; pos <= N; pos += pos & -pos) bit[pos].upd(args...);
	}
	template <typename... Args> T sum(int r, Args... args) {
		T res = 0;
		for (; r; r -= r & -r) res += bit[r].query(args...);
		return res;
	}
	template <typename... Args> T query(int l, int r, Args... args) {
		return sum(r, args...) - sum(l - 1, args...);
	}
};

template <class T, int N> int get_kth(const BIT<T, N> &bit, T des) {
	assert(des > 0);
	int ind = 0;
	for (int i = 1 << bits(N); i; i /= 2)
		if (ind + i <= N && bit.bit[ind + i].val < des) des -= bit.bit[ind += i].val;
	assert(ind < N);
	return ind + 1;
}

const int MX = 2e5 + 5;
BIT<int, MX> B;

int N;

int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> N;
	vector<int> x(N);
	for (int i = 0; i < N; i++) cin >> x[i];
	for (int i = 1; i <= N; i++) B.upd(i, 1);
	for (int _ = 0; _ < N; _++) {
		int p;
		cin >> p;
		int ind = get_kth(B, p);
		cout << x[ind - 1] << ' ';
		B.upd(ind, -1);
	}
}
```

</CPPSection>
</LanguageSection>

## Solution 3

Use a segment tree to store the number of elements present in each segment and
[walk down it](/plat/seg-ext#walking-on-a-segment-tree)

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

struct node;

vector<int> information;  // stores the actual array with our data in

vector<int> results;

struct node {
	// left child manages data from left to midpoint
	// right child manages data from midpoint+1 to right
	int left, right, midpoint;
	node *left_child;
	node *right_child;
	node *parent;
	int count;  // stores the number of elements in the subtree
	node(int left, int right, node *parent)
	    : left(left), right(right), midpoint((left + right) / 2), parent(parent) {
		if (left != right) {
			left_child = new node(left, midpoint, this);
			right_child = new node(midpoint + 1, right, this);
			count = left_child->count + right_child->count;
		} else {
			count = 1;
		}
	}

	// this function deletes index'th element in the subtree and also removes
	// one from the count
	void del(int index) {
		// Uncomment the following line to see how it traverses the segment tree
		// cout << "left: " << left << " right: " << right << " count: " <<
		// count << " ind: " << index << endl;
		if (count < index) {
			throw std::runtime_error("Element doesn't exist");
		} else {
			count--;
			if (left == right) {
				results.push_back(information[left]);
			} else if (left_child->count > index) {
				left_child->del(index);
			} else {
				right_child->del(index - left_child->count);
			}
		}
	}
};

int main() {
	int n;
	cin >> n;
	information.resize(n);
	for (auto &i : information) cin >> i;

	node root(0, n - 1, nullptr);
	for (int i = 0; i < n; i++) {
		int index;
		cin >> index;
		index--;  // 1-indexed to 0-indexed
		root.del(index);
	}

	for (int i = 0; i < n; i++) { cout << results[i] << " \n"[i == n - 1]; }
}
```

</CPPSection>
</LanguageSection>
