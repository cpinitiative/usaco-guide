---
id: joi-18-CommuterPass
source: JOI 2018
title: Commuter Pass
author: Andi Qu, Nathan Wang, Justin Ji
---

## Explanation

1. Use Dijkstra's to calculate distances from $s$, $u$, and $v$.
2. Consider a subset of directed edges where each directed edge is part of a
   shortest path from $s$ to $t$. Note that this subset is a DAG, and can be
   found by keeping track of the parents of every node when running Dijkstra's with $s$ as the starting node.
3. An optimal path will either be in the form $u \rightarrow x \rightarrow y \rightarrow 
   v$ or $v \rightarrow x \rightarrow y \rightarrow u$, where
   $x \rightarrow y$ is a path on the DAG. Note that any path on the DAG is a valid commuter pass
   option.
4. Without loss of generality, assume that our path has the form 
   $u \rightarrow x \rightarrow y \rightarrow v$.
5. Define $\text{dp}_1(i)$ as the minimum distance from $u$ to any node $x$ such that 
   $x$ is on a path from $s$ to $i$ in the DAG.
6. Define $\text{dp}_2(i)$ as the minimum distance from $u$ to $v$ if the commuter pass 
   edges used are on a path from $s$ to $i$ in the DAG.
7. For each parent of a node $i$, our transitions are:
   $$
   \begin{aligned}
	\text{dp}_1(i) &= \min\!\left\{ \text{dp}_1(i),\; \text{dist}_u(i),\; \text{dp}_1(\text{par}_i) \right\}, \\
	\text{dp}_2(i) &= \min\!\left\{ \text{dp}_2(i),\; \text{dp}_1(i) + \text{dist}_v(i),\; \text{dp}_2(\text{par}_i) \right\}.
   \end{aligned}
   $$
8. If the source node is $s$, then the answer is $\text{dp}_2(t)$. To handle the case 
   where the optimal path has the form $v \rightarrow x \rightarrow y \rightarrow u$, we repeat the algorithm for the source node $t$. 
9. Alternatively, the answer could be the distance from $u$ to $v$ without using the 
   commuter pass.

## Implementation

**Time Complexity:** $\mathcal{O}(M \log N)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

vector<pair<ll, ll>> graph[100001];
ll du[100001], dv[100001], ds[100001], dp[2][100001], ans;
bool visited[100001];

void dijkstra1(ll start, ll arr[]) {
	fill(visited, visited + 100001, false);

	priority_queue<pair<ll, ll>> pq;
	pq.push({0, start});
	while (!pq.empty()) {
		ll c, node;
		tie(c, node) = pq.top();
		pq.pop();

		if (!visited[node]) {
			arr[node] = -c;
			visited[node] = true;
			for (auto &i : graph[node]) pq.push({c - i.second, i.first});
		}
	}
}

void dijkstra2(ll start, ll end) {
	fill(dp[0], dp[0] + 100001, LLONG_MAX / 2);
	fill(dp[1], dp[1] + 100001, LLONG_MAX / 2);
	fill(visited, visited + 100001, false);

	priority_queue<pair<ll, pair<ll, ll>>> pq;
	pq.push({0, {start, 0}});
	while (!pq.empty()) {
		ll c, node, par;
		pair<ll, ll> p;
		tie(c, p) = pq.top();
		tie(node, par) = p;
		pq.pop();

		if (!visited[node]) {
			visited[node] = true;
			ds[node] = -c;
			dp[0][node] = min(du[node], dp[0][par]);
			dp[1][node] = min(dp[0][node] + dv[node], dp[1][par]);
			for (auto i : graph[node]) pq.push({c - i.second, {i.first, node}});
		} else if (-c == ds[node]) {
			dp[0][node] = min(dp[0][node], dp[0][par]);
			dp[1][node] = min({dp[1][node], dp[0][node] + dv[node], dp[1][par]});
		}
	}

	ans = min(ans, dp[1][end]);
}

int main() {
	iostream::sync_with_stdio(false);
	cin.tie(0);
	ll n, m, s, t, u, v;
	cin >> n >> m >> s >> t >> u >> v;
	for (int i = 0; i < m; i++) {
		ll a, b, c;
		cin >> a >> b >> c;
		graph[a].push_back({b, c});
		graph[b].push_back({a, c});
	}

	dijkstra1(u, du);
	dijkstra1(v, dv);

	ans = du[v];

	dijkstra2(s, t);
	dijkstra2(t, s);

	cout << ans << '\n';
	return 0;
}
```

</CPPSection>
</LanguageSection>

Alternatively,
[Nathan's implementation](https://github.com/thecodingwizard/competitive-programming/blob/master/JOI/JOI%2018-commuterpass.cpp).
Note that the DP definitions in Nathan's implementation are slightly different
than above.
