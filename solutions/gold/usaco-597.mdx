---
id: usaco-597
source: USACO Gold 2016 January
title: Angry Cows
author: Benjamin Qi, Ryan Chou, David Zhou
---

<Spoiler title="Hint 1">

For problems where we're asked to minimize/maximize some value, we can ask ourselves these questions:

- How does the "validity" of the answer change as we increase/decrease it?
- What conditions must be true of an optimal solution?

</Spoiler>

<Spoiler title="Answer to Hint 1">

Note that for the minimum power that we launch a cow with is monotonic, since there is a set point where smaller values of $R$ will stop working.

This implies a binary search on the power $R$.

</Spoiler>

<Spoiler title="Solution">

[Official Analysis (C++ and Java)](http://www.usaco.org/current/data/sol_angry_gold_jan16.html)

<Warning>

The second and third solutions in the analysis fail on the following test case:

```
2
0
1
```

The second one gives the wrong answer, and the third errors.

</Warning>

From the hints, we'll start binary searching on the initial power $R$. Now, we've reduced the problem into checking if a fixed power $R$ works for our set of haybales.

There are many ways to approach this (see the [Official Analysis](http://www.usaco.org/current/data/sol_angry_gold_jan16.html) for more information!), but perhaps the most straightforward way is running a second binary search on the maximum point we can place our cow.

This works because just like our power, there exists a set point where a cow being launched at a coordinate will not knock out all the haybales to the left/right. Since $N \leq 5 \cdot 10^4$, we can simulate these explosions naively.

## Implementation

**Time Complexity**: $\mathcal{O}(N \log^2 N)$

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <climits>
#include <iomanip>
#include <iostream>
#include <vector>
using namespace std;

int n;
vector<int> haybales;

bool valid(int pos, int idx, int power, int dir) {
	// exploded leftmost haybale
	if (idx <= 0 && dir == 0) { return (idx < 0 || pos - power <= haybales[idx]); }

	// exploded rightmost haybale
	if (idx >= n - 1 && dir == 1) { return idx >= n || pos + power >= haybales[idx]; }

	if (dir == 0) {  // left
		if (pos - power <= haybales[0]) { return true; }

		// go as left as possible
		int next_idx = idx;
		while (next_idx >= 0 && pos - power <= haybales[next_idx]) { next_idx--; }

		// more movement is not possible
		if (next_idx == idx) { return false; }

		return valid(haybales[next_idx + 1], next_idx, power - 2, dir);
	} else {  // right
		if (pos + power >= haybales[n - 1]) { return true; }

		// go as right as possible
		int next_idx = idx;
		while (next_idx < n && haybales[next_idx] <= pos + power) { next_idx++; }

		// more movement is not possible
		if (next_idx == idx) { return false; }

		return valid(haybales[next_idx - 1], next_idx, power - 2, dir);
	}

	return false;
}

int main() {
	freopen("angry.in", "r", stdin);
	freopen("angry.out", "w", stdout);

	cin >> n;
	haybales.resize(n);
	for (int i = 0; i < n; i++) {
		cin >> haybales[i];
		haybales[i] *= 2;  // double each position to eliminate decimals
	}
	sort(haybales.begin(), haybales.end());

	int l = 0, r = INT_MAX;
	while (l <= r) {
		int power = (r - l) / 2 + l;

		// find the rightmost haybale that can still reach the left
		int pos_l = 0, pos_r = INT_MAX;
		while (pos_l <= pos_r) {
			int pos = (pos_r - pos_l) / 2 + pos_l;

			// index of candidate haybale
			int idx =
			    lower_bound(haybales.begin(), haybales.end(), pos) - haybales.begin();

			// can we explode all haybales on left?
			if (idx < n && valid(pos, idx, power, 0)) {
				pos_l = pos + 1;
			} else {
				pos_r = pos - 1;
			}
		}

		int idx =
		    upper_bound(haybales.begin(), haybales.end(), pos_l) - haybales.begin();

		// can we explode all haybales on the right?
		if (valid(pos_l, idx, power, 1)) {
			r = power - 1;
		} else {
			l = power + 1;
		}
	}
	cout << fixed << setprecision(1) << (double)l / 2.0 << endl;
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
	static int n;
	static int[] haybales;

	static boolean valid(int pos, int idx, int power, int dir) {
		// exploded leftmost haybale
		if (idx <= 0 && dir == 0) { return (idx < 0 || pos - power <= haybales[idx]); }

		// exploded rightmost haybale
		if (idx >= n - 1 && dir == 1) {
			return idx >= n || pos + power >= haybales[idx];
		}

		if (dir == 0) {  // left
			if (pos - power <= haybales[0]) { return true; }

			// go as left as possible
			int next_idx = idx;
			while (next_idx >= 0 && pos - power <= haybales[next_idx]) { next_idx--; }

			// more movement is not possible
			if (next_idx == idx) { return false; }

			return valid(haybales[next_idx + 1], next_idx, power - 2, dir);
		} else {  // right
			if (pos + power >= haybales[n - 1]) { return true; }

			// go as right as possible
			int next_idx = idx;
			while (next_idx < n && haybales[next_idx] <= pos + power) { next_idx++; }

			// more movement is not possible
			if (next_idx == idx) { return false; }

			return valid(haybales[next_idx - 1], next_idx, power - 2, dir);
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader("angry.in"));
		PrintWriter pw = new PrintWriter(new FileWriter("angry.out"));

		n = Integer.parseInt(br.readLine());
		haybales = new int[n];
		for (int i = 0; i < n; i++) {
			// double each position to eliminate decimals
			haybales[i] = Integer.parseInt(br.readLine()) * 2;
		}
		Arrays.sort(haybales);
		int l = 0, r = Integer.MAX_VALUE;
		while (l <= r) {
			int power = (r - l) / 2 + l;

			// find the rightmost haybale that can still reach the left
			int pos_l = 0, pos_r = Integer.MAX_VALUE;
			while (pos_l <= pos_r) {
				int pos = (pos_r - pos_l) / 2 + pos_l;

				// index of candidate haybale
				int idx = Arrays.binarySearch(haybales, pos);
				if (idx < 0) { idx = -idx - 1; }

				// can we explode all haybales on left?
				if (idx < n && valid(pos, idx, power, 0)) {
					pos_l = pos + 1;
				} else {
					pos_r = pos - 1;
				}
			}

			int idx = Arrays.binarySearch(haybales, pos_l);
			if (idx < 0) {
				idx = -idx - 1;
			} else {
				while (idx < n && haybales[idx] == pos_l) { idx++; }
			}

			// can we explode all haybales on the right?
			if (valid(pos_l, idx, power, 1)) {
				r = power - 1;
			} else {
				l = power + 1;
			}
		}
		pw.printf("%.1f\n", (double)l / 2.0);
		pw.close();
		br.close();
	}
}
```

</JavaSection>
<PySection>

```py
import sys


def valid(mid: int) -> bool:
	# L to R
	# i marks the current haybale we are exploding
	# j marks the furthest haybale we can reach
	i, j = 0, 0

	# maxpos finds the rightmost index that can reach the left
	maxpos = hay[0] + mid
	r = mid % 2
	while j < n and r <= mid:
		if hay[i] + r >= hay[j]:
			j += 1
		else:
			if j - i == 1:
				# consecutive haybales are a special case
				# anchor is the haybale right before it, so we cannot start a new chain
				r = (hay[j] - hay[i]) + (hay[j] - hay[i]) % 2
				if r >= mid:
					# update max possible position if radius is insufficient
					maxpos = min(maxpos, hay[i] + mid)
					break
			else:
				# otherwise, we can explode haybale j-1 and start again with decreased power
				r += 2
				i = j - 1
		if r <= mid:
			maxpos = max(maxpos, hay[i] + mid)

	# R to L
	i, j = n - 1, n - 1

	# minpos finds the leftmost index that can reach the right
	minpos = hay[-1] - mid
	r = mid % 2
	while j >= 0 and r <= mid:
		if hay[i] - r <= hay[j]:
			j -= 1
		else:
			if i - j == 1:
				r = (hay[i] - hay[j]) + (hay[i] - hay[j]) % 2
				if r >= mid:
					minpos = min(minpos, hay[i] - mid)
					break
			else:
				r += 2
				i = j + 1
		if r <= mid:
			minpos = min(minpos, hay[i] - mid)

	# explosion possible if ranges overlap
	return minpos <= maxpos


with open("angry.in", "r") as f:
	n = int(f.readline().strip())
	hay = [
		int(f.readline().strip()) * 2 for _ in range(n)
	]  # double positions to avoid decimals
hay.sort()

# binary search for lowest initial power
l, r = 0, hay[-1]
while l < r:
	mid = (l + r) // 2
	if valid(mid):
		r = mid
	else:
		l = mid + 1

print(f"{l / 2:.1f}", file=open("angry.out", "w"))
```

</PySection>
</LanguageSection>

</Spoiler>
