---
id: cf-10D
source: CF
title: LCIS
author: Aryaveer Shishodia
---

[Official Editorial](https://codeforces.com/blog/entry/298)

Note that during the contest, the problem was modified due ot a bug in the solution. Because the original problem was unsolvable with the given constraints, the problem was modified, but the solution to the modified problem was not posted there.

## Solution: LIS DP

Note that this is my solution, alternate solutions might be available online. I labeled the sequences `a` and `b`.

We can track the length of the LCIS ending at `b[j]` in a list `dp[j]`. We can also create a parent list where `parent[j]` points to the index in `b` of the last number in `dp[j]`, letting us reconstruct the subsequence at the end.

Looping through sequence `a`, we can try to add to each subsequence in `dp`. We can track the longest LCIS ending at elements of `b` that are smaller than `a[i]`, and store its index to extend it if `a[i]` matches a later element.

For each `b[j]`, we check if `a[i]` can extend the LCIS ending at `b[j]`. If `a[i] == b[j]`, then the LCIS can be extended, and `dp[j]` should be updated. If `a[i] > b[j]`, `a[i]` could possibly be added later to the sequence, and we need to update the length of the LCIS. If `a[i] < b[j]`, we don't do anything because `a[i]` cannot extend the subsequence.

After that, we find the length of the LCIS in `dp` and reconstruct the sequence.

## Implementation

**Time Complexity:** $\mathcal{O}(NM)$

<LanguageSection>

<CPPSection>

<Warning title="Tight Constraints">
Note that when printing out queries, make sure to use "\n" instead of endl or you will get a TLE!
</Warning>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	cin.tie(0)->sync_with_stdio(false);

	// read the 2 sequences
	int n, m; cin >> n;
    vector<int> a(n);
    for (int& i : a) cin >> i;
    cin >> m;
    vector<int> b(m);
    for (int& i : b) cin >> i;

	// initialize dp
    vector<int> dp(m, 0), parent(m, -1);

	// loop through a
    for (int i = 0; i < n; i++) {
        int current = 0;
        int last = -1;
        for (int j = 0; j < m; j++) {
            if (a[i] == b[j]) {
                if (current + 1 > dp[j]) {
                    dp[j] = current + 1;
                    parent[j] = last;
                }
            } else if (a[i] > b[j]) {
                if (dp[j] > current) {
                    current = dp[j];
                    last = j;
                }
            }
        }
    }

	// find the sequence length
    int length = 0, pos = -1;
    for (int j = 0; j < m; j++) {
        if (dp[j] > length) {
            length = dp[j];
            pos = j;
        }
    }

	// reconstruct the sequence
    vector<int> lcis;
    while (pos != -1) {
        lcis.push_back(b[pos]);
        pos = parent[pos];
    }
    reverse(lcis.begin(), lcis.end());
    cout << length << endl;
    for (int x : lcis) cout << x << ' ';
}
```

</CPPSection>

</LanguageSection>
