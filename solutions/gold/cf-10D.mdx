---
id: cf-10D
source: CF
title: LCIS
author: Aryaveer Shishodia
---

[Official Editorial](https://codeforces.com/blog/entry/298)

Note that during the contest, the problem was modified due ot a bug in the solution. Because the original problem was unsolvable with the given constraints, the problem was modified, but the solution to the modified problem was not posted there.

## Solution: LIS DP

Note that this is my solution, alternate solutions might be available online. I labeled the sequences `a` and `b`.

We can track the length of the LCIS ending at `b[j]` in a list `dp[j]`. We can also create a parent list where `parent[j]` points to the index in `b` of the last number in `dp[j]`, letting us reconstruct the subsequence at the end.

Looping through sequence `a`, we can try to add to each subsequence in `dp`. We can track the longest LCIS ending at elements of `b` that are smaller than `a[i]`, and store its index to extend it if `a[i]` matches a later element.

For each `b[j]`, we check if `a[i]` can extend the LCIS ending at `b[j]`. If `a[i] == b[j]`, then the LCIS can be extended, and `dp[j]` should be updated. If `a[i] > b[j]`, `a[i]` could possibly be added later to the sequence, and we need to update the length of the LCIS. If `a[i] < b[j]`, we don't do anything because `a[i]` cannot extend the subsequence.

After that, we find the length of the LCIS in `dp` and reconstruct the sequence.

## Implementation

**Time Complexity:** $\mathcal{O}(NM)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	cin.tie(0)->sync_with_stdio(false);

	// read the 2 sequences
	int n, m; cin >> n;
    vector<int> a(n);
    for (int& i : a) cin >> i;
    cin >> m;
    vector<int> b(m);
    for (int& i : b) cin >> i;

	// initialize dp
    vector<int> dp(m, 0), parent(m, -1);

	// loop through a
    for (int i = 0; i < n; i++) {
        int current = 0;
        int last = -1;
        for (int j = 0; j < m; j++) {
            if (a[i] == b[j]) {
                if (current + 1 > dp[j]) {
                    dp[j] = current + 1;
                    parent[j] = last;
                }
            } else if (a[i] > b[j]) {
                if (dp[j] > current) {
                    current = dp[j];
                    last = j;
                }
            }
        }
    }

	// find the sequence length
    int length = 0, pos = -1;
    for (int j = 0; j < m; j++) {
        if (dp[j] > length) {
            length = dp[j];
            pos = j;
        }
    }

	// reconstruct the sequence
    vector<int> lcis;
    while (pos != -1) {
        lcis.push_back(b[pos]);
        pos = parent[pos];
    }
    reverse(lcis.begin(), lcis.end());
    cout << length << endl;
    for (int x : lcis) cout << x << ' ';
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.*;

public class LCIS {
    public static void main(String[] args) throws IOException {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // read n and sequence a
        int n = Integer.parseInt(read.readLine());
        int[] a = new int[n];
        st = new StringTokenizer(read.readLine());
        for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());

        // read m and sequence b
        int m = Integer.parseInt(read.readLine());
        int[] b = new int[m];
        st = new StringTokenizer(read.readLine());
        for (int i = 0; i < m; i++) b[i] = Integer.parseInt(st.nextToken());

        // initialize dp and parent arrays
        int[] dp = new int[m];
        int[] parent = new int[m];
        Arrays.fill(parent, -1);

        // LCIS DP
        for (int i = 0; i < n; i++) {
            int current = 0;
            int last = -1;
            for (int j = 0; j < m; j++) {
                if (a[i] == b[j]) {
                    if (current + 1 > dp[j]) {
                        dp[j] = current + 1;
                        parent[j] = last;
                    }
                } else if (a[i] > b[j]) {
                    if (dp[j] > current) {
                        current = dp[j];
                        last = j;
                    }
                }
            }
        }

        // find length and ending index
        int length = 0, pos = -1;
        for (int j = 0; j < m; j++) {
            if (dp[j] > length) {
                length = dp[j];
                pos = j;
            }
        }

        // reconstruct LCIS
        List<Integer> lcis = new ArrayList<>();
        while (pos != -1) {
            lcis.add(b[pos]);
            pos = parent[pos];
        }
        Collections.reverse(lcis);

        // output using StringBuilder
        StringBuilder out = new StringBuilder();
        out.append(length).append("\n");
        for (int x : lcis) out.append(x).append(" ");
        System.out.println(out);
    }
}
```

</JavaSection>
<PySection>

```py
# read input
n = int(input())
a = list(map(int, input().split()))
m = int(input())
b = list(map(int, input().split()))

# initialize dp and parent arrays
dp = [0] * m
parent = [-1] * m

# LCIS DP
for i in range(n):
    current = 0
    last = -1
    for j in range(m):
        if a[i] == b[j]:
            if current + 1 > dp[j]:
                dp[j] = current + 1
                parent[j] = last
        elif a[i] > b[j]:
            if dp[j] > current:
                current = dp[j]
                last = j

# find length and ending index
length = 0
pos = -1
for j in range(m):
    if dp[j] > length:
        length = dp[j]
        pos = j

# reconstruct LCIS
lcis = []
while pos != -1:
    lcis.append(b[pos])
    pos = parent[pos]

lcis.reverse()

# print output
print(length)
print(*lcis)
```

</PySection>
</LanguageSection>
