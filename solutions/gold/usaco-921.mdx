---
id: usaco-921
source: USACO Gold 2019 February
title: Cow Land
author: Albert Ye, David Zhou
---

[Official Analysis (C++)](https://usaco.org/current/data/sol_cowland_gold_feb19.html)

## Solution 1: Euler Tour + Binary Lifting

This problem requires supporting point updates and XOR path queries on a tree. We can use an [Euler Tour](/gold/tree-euler) combined with a [Fenwick tree](/gold/PURS#binary-indexed-tree) to compute root-to-node XORs efficiently and binary lifting to find the [Lowest Common Ancestor (LCA)](/plat/binary-jump) of any two nodes.

Let $\texttt{in}[x]$ and $\texttt{out}[x]$ denote the entry and exit times of node $x$ during an Euler Tour. By storing each node's value $e_x$ at both positions $\texttt{in}[x]$ and $\texttt{out}[x]$ in the Fenwick tree, the prefix XOR up to $\texttt{in}[v]$ gives the XOR of all values on the path from the root to node $v$.

This works because nodes in the subtree of $x$ have entry times in the range $[\texttt{in}[x], \texttt{out}[x])$, so their root paths all contain $e_x$. We XOR $e_x$ at $\texttt{in}[x]$ to include it for the subtree, and XOR it again at $\texttt{out}[x]$ to cancel it out for nodes outside the subtree. This is possible due to XOR's self-inverse property.

Define $X(x)$ as the XOR of values from the root to node $x$. Then the XOR along the path between nodes $u$ and $v$ is:

$$
X(u)\oplus X(v)\oplus e_{\text{lca}(u,v)}.
$$

$X(u)$ and $X(v)$ each include the path from the root to their LCA, which cancels out when XORed together. We must XOR in $e_{\text{lca}(u,v)}$ once to include the LCA node in the final result.

To update a node $x$ to a new value $e'_x$, we XOR the difference $e_x\oplus e'_x$ into both $\texttt{in}[x]$ and $\texttt{out}[x]$.

## Implementation

**Time Complexity:** $\mathcal{O}((N+Q)\log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>

#define MAXN 100005
#define bitinc(x) (x & -x)

using namespace std;

int n, arr[MAXN], bit[4 * MAXN], in[MAXN], ot[MAXN], par[MAXN][22];
vector<int> adj[MAXN];
int timer = 1;

void dfs(int v = 0, int p = 0) {
	in[v] = timer++;
	par[v][0] = p;
	
	for (int i = 1; i < 22; i++) {
		par[v][i] = par[par[v][i - 1]][i - 1];
	}
	
	for (int x : adj[v]) {
		if (x == p) continue;
		dfs(x, v);
	}
	
	ot[v] = timer++;
}

int XOR(int ind) {
	int xo = 0;
	while (ind > 0) {
		xo ^= bit[ind];
		ind -= bitinc(ind);
	}
	return xo;
}

void upd(int ind, int val) {
	while (ind <= timer) {
		bit[ind] ^= val;
		ind += bitinc(ind);
	}
}

bool anc(int u, int v) {
	return (in[u] <= in[v] && ot[u] >= ot[v]);
}

int lca(int u, int v) {
	if (anc(u, v)) return u;
	
	for (int i = 21; i >= 0; i--) {
		if (par[u][i] >= 0 && !anc(par[u][i], v)) {
			u = par[u][i];
		}
	}
	
	return par[u][0];
}

int main() {
	freopen("cowland.in", "r", stdin);
	freopen("cowland.out", "w", stdout);
	
	int q;
	cin >> n >> q;
	
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		--u; --v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	
	dfs();
	
	for (int i = 0; i < n; i++) {
		upd(in[i], arr[i]);
		upd(ot[i], arr[i]);
	}
	
	for (int que = 0; que < q; que++) {
		int t;
		cin >> t;
		
		if (t == 1) {
			int s, x;
			cin >> s >> x;
			--s;
			
			upd(in[s], arr[s]);
			upd(ot[s], arr[s]);
			arr[s] = x;
			upd(in[s], arr[s]);
			upd(ot[s], arr[s]);
		} else {
			int u, v;
			cin >> u >> v;
			--u; --v;
			
			int w = lca(u, v);
			cout << (XOR(in[u]) ^ XOR(in[v]) ^ arr[w]) << endl;
		}
	}
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Main {
    static final int LOG = 18;

    // BeginCodeSnip{Binary Indexed Tree}
    static class BIT {
        final int n;
        final int[] bit;

        BIT(int n) {
            this.n = n;
            this.bit = new int[n + 1];
        }

        void xorAdd(int idx, int val) {
            for (; idx <= n; idx += idx & -idx) {
                bit[idx] ^= val;
            }
        }

        int xorQuery(int idx) {
            int res = 0;
            for (; idx > 0; idx -= idx & -idx) {
                res ^= bit[idx];
            }
            return res;
        }
    }
    // EndCodeSnip

    static boolean isAncestor(int u, int v, int[] in, int[] out) {
        return in[u] <= in[v] && out[u] >= out[v];
    }

    static int lca(int u, int v, int[][] up, int[] in, int[] out) {
        if (isAncestor(u, v, in, out)) return u;
        if (isAncestor(v, u, in, out)) return v;
        for (int i = LOG - 1; i >= 0; i--) {
            int pu = up[i][u];
            if (!isAncestor(pu, v, in, out)) u = pu;
        }
        return up[0][u];
    }

    static class FastScanner {
        private final InputStream in;
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;

        FastScanner(InputStream in) { this.in = in; }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0) return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
                if (c == -1) return Integer.MIN_VALUE;
            } while (c <= ' ');
            int sign = 1;
            if (c == '-') {
                sign = -1;
                c = readByte();
            }
            int val = 0;
            while (c > ' ') {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return val * sign;
        }
    }

    public static void main(String[] args) throws Exception {
        FastScanner fs = new FastScanner(new FileInputStream("cowland.in"));
        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("cowland.out")));

        int n = fs.nextInt();
        int q = fs.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = fs.nextInt();

        ArrayList<Integer>[] adj = new ArrayList[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        for (int i = 0; i < n - 1; i++) {
            int u = fs.nextInt() - 1;
            int v = fs.nextInt() - 1;
            adj[u].add(v);
            adj[v].add(u);
        }

        int[] in = new int[n];
        int[] outTime = new int[n];
        int[] depth = new int[n];
        int[][] up = new int[LOG][n];

        // iterative DFS to compute in/out times, depth, and immediate parent
        int timer = 1;
        int[] parent = new int[n];
        int[] idx = new int[n];
        int[] stack = new int[n];
        int sp = 0;
        stack[sp++] = 0;
        parent[0] = 0;
        up[0][0] = 0;
        depth[0] = 0;
        in[0] = timer++;

        while (sp > 0) {
            int v = stack[sp - 1];
            if (idx[v] < adj[v].size()) {
                int to = adj[v].get(idx[v]++);
                if (to == parent[v]) continue;
                parent[to] = v;
                up[0][to] = v;
                depth[to] = depth[v] + 1;
                in[to] = timer++;
                stack[sp++] = to;
            } else {
                outTime[v] = timer++;
                sp--;
            }
        }

        for (int i = 1; i < LOG; i++) {
            for (int v = 0; v < n; v++) {
                up[i][v] = up[i - 1][up[i - 1][v]];
            }
        }

        BIT bit = new BIT(timer + 2);
        for (int v = 0; v < n; v++) {
            bit.xorAdd(in[v], a[v]);
            bit.xorAdd(outTime[v], a[v]);
        }

        for (int qi = 0; qi < q; qi++) {
            int t = fs.nextInt();
            if (t == 1) {
                int s = fs.nextInt() - 1;
                int x = fs.nextInt();
                int delta = a[s] ^ x;
                a[s] = x;
                bit.xorAdd(in[s], delta);
                bit.xorAdd(outTime[s], delta);
            } else {
                int u = fs.nextInt() - 1;
                int v = fs.nextInt() - 1;
                int w = lca(u, v, up, in, outTime);
                int ans = bit.xorQuery(in[u]) ^ bit.xorQuery(in[v]) ^ a[w];
                out.println(ans);
            }
        }

        out.close();
    }
}
```

</JavaSection>

</LanguageSection>

## Solution 2: Heavy-Light Decomposition

We can also solve this using [HLD](/plat/hld). After decomposing the tree into heavy paths, we assign each node a position $\texttt{pos[node]}$ in a linearized array and store values at $\texttt{val[pos[node]]}$. Each heavy path is contiguous in this array, with $\texttt{tp[node]}$ storing the top of the heavy chain containing $\texttt{node}$.

For a path query between nodes $u$ and $v$, we repeatedly jump from the deeper node to the parent of its chain top until both nodes are on the same chain. At each step, we need to query the XOR of a contiguous segment of the linearized array. To achieve $\mathcal{O}(\log^2 N)$ complexity, we must use a data structure such as a segment tree (or Fenwick tree) to answer these segment queries in $\mathcal{O}(\log N)$.

## Implementation

**Time Complexity:** $\mathcal{O}((N+Q)\log^2 N)$

<LanguageSection>
<CPPSection>

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <vector>

using namespace std;

const int MAXN = 100005;

int n, q;
int arr[MAXN];
vector<int> adj[MAXN];

int sz[MAXN], parentArr[MAXN], dep[MAXN];
int tp[MAXN], pos[MAXN];
int val[MAXN];
int timer = 0;

// BeginCodeSnip{XOR Segment Tree}
template <class T> struct SegTree {
    const T ID = 0;
    T cmb(T a, T b) { return a ^ b; }
    int n;
    vector<T> seg;
    SegTree(int _n) {
        for (n = 1; n < _n;) n *= 2;
        seg.assign(2 * n, ID);
    }
    void pull(int p) { seg[p] = cmb(seg[2 * p], seg[2 * p + 1]); }
    void upd(int p, T val) {
        seg[p += n] = val;
        for (p /= 2; p; p /= 2) pull(p);
    }
    T query(int l, int r) {
        T ra = ID, rb = ID;
        for (l += n, r += n + 1; l < r; l /= 2, r /= 2) {
            if (l & 1) ra = cmb(ra, seg[l++]);
            if (r & 1) rb = cmb(seg[--r], rb);
        }
        return cmb(ra, rb);
    }
};
// EndCodeSnip

void dfs_sz(int cur, int parent) {
    sz[cur] = 1;
    parentArr[cur] = parent;

    for (int child : adj[cur]) {
        if (child == parent) continue;
        dep[child] = dep[cur] + 1;
        dfs_sz(child, cur);
        sz[cur] += sz[child];
    }
}

void dfs_hld(int cur, int parent, int top) {
    tp[cur] = top;
    pos[cur] = timer++;
    val[pos[cur]] = arr[cur];

    int h_chi = -1, h_sz = -1;
    for (int child : adj[cur]) {
        if (child == parent) continue;
        if (sz[child] > h_sz) {
            h_sz = sz[child];
            h_chi = child;
        }
    }

    if (h_chi == -1) return;

    dfs_hld(h_chi, cur, top);

    for (int child : adj[cur]) {
        if (child == parent || child == h_chi) continue;
        dfs_hld(child, cur, child);
    }
}

SegTree<int> segtree(1);

int query_path(int x, int y) {
    int res = 0;

    while (tp[x] != tp[y]) {
        if (dep[tp[x]] < dep[tp[y]]) swap(x, y);
		res ^= segtree.query(pos[tp[x]], pos[x]);
        x = parentArr[tp[x]];
    }

    if (dep[x] > dep[y]) swap(x, y);

	res ^= segtree.query(pos[x], pos[y]);

    return res;
}

void update(int node, int new_val) { segtree.upd(pos[node], new_val); }

int main() {
    freopen("cowland.in", "r", stdin);
    freopen("cowland.out", "w", stdout);

    cin >> n >> q;

    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        --u;
        --v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    dep[0] = 0;
    dfs_sz(0, 0);
    dfs_hld(0, 0, 0);

    segtree = SegTree<int>(n);
    for (int i = 0; i < n; i++) {
        segtree.upd(i, val[i]);
    }

    for (int que = 0; que < q; que++) {
        int t;
        cin >> t;

        if (t == 1) {
            int s, x;
            cin >> s >> x;
            --s;
            update(s, x);
        } else {
            int u, v;
            cin >> u >> v;
            --u;
            --v;
            cout << query_path(u, v) << endl;
        }
    }
}
```

</CPPSection>
</LanguageSection>
