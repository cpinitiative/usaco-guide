---
id: usaco-811
source: USACO Silver 2018 February
title: Snow Boots
author: Qi Wang, Ryan Chou
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_snowboots_silver_feb18.html)

## Explanation

Due to the low bounds on $N$ and $B$, we can run a [DFS (Depth First Search)](/silver/dfs) on every possible location and boot size Farmer John could be wearing.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2B + NB^2)$
<LanguageSection>

<CPPSection>
	
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int MAX_N = 250;
int n;
int m;
vector<int> depths(MAX_N);
vector<vector<bool>> vis(MAX_N, vector<bool>(MAX_N));
vector<pair<int, int>> shoes(MAX_N);

int ans = INT32_MAX;

void dfs(int depth, int boot)  {
	// already visited this path
	if (vis[depth][boot]) {
		return;
	}
	
	vis[depth][boot] = true;

	// reached the barn, update the answer
	if (depth == n - 1) {
		ans = min(boot, ans);
		return;
	}


	// test all possible steps
	for (int i = depth + 1; i <= depth + shoes[boot].second && i < n; i++) {
		if (depths[i] <= shoes[boot].first) {
			dfs(i, boot);
		}
	}

	// test all possible swaps
	for (int i = boot; i < m; i++) {
		if (depths[depth] <= shoes[i].first) {
			dfs(depth, i);
		}
	}
}

int main() {
	freopen("snowboots.in", "r", stdin);
	freopen("snowboots.out", "w", stdout);

	cin >> n >> m;

	for (int i = 0; i < n; i++) {
		cin >> depths[i];
	}

	for (int i = 0; i < m; i++) {
		cin >> shoes[i].first >> shoes[i].second;
	}

	dfs(0, 0);

	cout << ans << "\n";
}
```
</CPPSection>
<JavaSection>

```java
import java.util.*;
import java.io.*;

public class snowboot {
	static List<Pair<Integer, Integer>> B = new ArrayList<>();
	static int[] D;
	static boolean[][] vist;
	static int N, M, A=10000;
	public static void main(String[] args) throws IOException {
		InputReader in = new InputReader("snowboots.in");
		N = in.nextInt(); M = in.nextInt(); D = new int[N]; vist = new boolean[N+1][M+1];
		for (int i = 0; i < N; i++) {
			D[i] = in.nextInt();
		}
		for (int i = 0; i < M; i++) {
			int a,b; a = in.nextInt(); b = in.nextInt();
			B.add(new Pair<>(a, b));
		}

		dfs(0,0);
		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("snowboots.out")));
		out.println(A);
		out.close();
	}

	private static void dfs(int n, int t){
		//If we have explored that path then return out of it
		if(vist[n][t]) return ;
		vist[n][t] = true;

		//If it reaches the destination we want to take the minimum of what we have and what we got
		if(n == N-1) A = Math.min(A, t);

		//Trying to go the every farm it can with one boot
		for (int i = n+1; i < N && i-n<=B.get(t).last(); i++) {
			if(D[i] <= B.get(t).first) dfs(i, t);
		}

		//Trying all boot switches at the current farm
		for (int i = t+1; i < B.size(); i++) {
			if(D[n] <= B.get(i).first) dfs(n, i);
		}

	}

	private static class InputReader {
		public BufferedReader reader;
		public StringTokenizer tokenizer;

		public InputReader() {
			try {
				reader = new BufferedReader(new InputStreamReader(System.in), 32768);
			} catch (Exception e) {
				throw new NullPointerException("Could not create input stream");
			}
		}

		public InputReader(String fileName) {
			try {
				reader = new BufferedReader(new FileReader(new File(fileName)), 32768);
			} catch (Exception ex) {
				throw new NullPointerException("Input file does not exist! Put it in the project folder.");
			}
			tokenizer = null;
		}

		public String next() {
			while (tokenizer == null || !tokenizer.hasMoreTokens()) {
				try {
					tokenizer = new StringTokenizer(reader.readLine());
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			return tokenizer.nextToken();
		}

		public boolean hasNextInt() throws IOException { return reader.ready(); }

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}

		public char nextChar() {
			return next().charAt(0);
		}

		/**
		 * When you call next(), that entire line will be skipped.
		 * No flushing buffers.
		 * Doesn't work when you want to scan the remaining line.
		 *
		 * @return entire line
		 */

		public String nextLine() {
			String str = "";
			try {
				str = reader.readLine();
				tokenizer = null;
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			return str;
		}
	}

	private static class Pair<F, S> {
		F first;
		S second;

		public Pair(F a, S b) {
			first = a;
			second = b;
		}

		public F one() {
			return first;
		}

		public S last() {
			return second;
		}

		@Override
		public String toString() {
			return "[" + first.toString() + ", " + second.toString() + "]";
		}
	}
}
```

</JavaSection>
</LanguageSection>
