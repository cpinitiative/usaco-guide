---
id: izho-17-LongestBeautifulSequence
source: IZhO 2017
title: 2017 - Longest beautiful sequence
author: Shijie Ren
---

<Spoiler title="Hint">

Let $\texttt{dp}[i]$ be the length of longest beautiful sequence which ends with
$a[i]$.

And you'll get a naive DP solution with time complexity $\mathcal{O}(N^2)$.

$$
\texttt{dp}[i]=\max_{j<i,\text{pop}(a[i]\&a[j])=k[i]}\{\texttt{dp}[j]\}+1
$$

The transition of the current state is determined by the value of the previous
element, that's only $a[j]$. For each $i$ enumerate last element $a[j]$, for the
time complexity of states transition, it's optimized to $\mathcal O(\max a_i)$
from $\mathcal O(n)$.

Here you may find two ways of $\mathcal{O}(N\max{a[i]})$ DP.

One is kind of preprocessing previous answers, traverse all the situations of
the previous number, $\mathcal{O}(\max{a[i]})$ to query current answer in DP
array and $\mathcal{O}(1)$ to update.

The other is kind of predicting next answers, traverse all the possible outcomes
of the next number, $\mathcal{O}(1)$ to query current answer in DP array and
$\mathcal{O}(\max{a[i]})$ to update, but needs a bit more memory.

**For $\mathcal{O}(N\max a[i])$ DP**:

Let $\texttt{dp}[i][j]$ be the length of longest beautiful sequence of the first
$i$ elements that ends with $j$,

$$
\texttt{dp}[i][j] = \begin{cases}
\max \{ \texttt{dp}[i-1][j] , \max\limits_{\text{pop}(l\&a[i])=k[i]}\{\texttt{dp}[i-1][l]\}+1 \}&,j=a[i]
\\
\texttt{dp}[i-1][j] &,j\not=a[i]
\end{cases}
$$

**For another $\mathcal{O}(N\max a[i])$ DP**:

Let $\texttt{dp}[i][j][q]$ be the length of longest beautiful sequence of the
first $i$ elements which satisfies $\text{pop}(\texttt{end}\&j)=q$,

$$
\texttt{dp}[i][j][q] =
\begin{cases}
\max\{\texttt{dp}[i-1][j][q],\texttt{dp}[i-1][a[i]][k[i]]+1\}&,q=\text{pop}(a[i]\&j)
\\
\texttt{dp}[i-1][j][q]&,q\not=\text{pop}(a[i]\&j)
\end{cases}
$$

These algorithms are not efficient enough because time complexity of the update
and the query is unbalanced.

Try to consider both of them and try to "combine" their ideas.

</Spoiler>

<Spoiler title="Explanation">

Imagine two elements $\texttt{pre},\texttt{cur}$, where we wanted to calculate
length of longest beautiful sequence end with element $\texttt{cur}$, transfer
from element $\texttt{pre}$.

Predict the next element or preprocess the previous element are neither
sufficient, so divide an element into two parts, one for predicting and the
other for preprocessing, this is the key to reduce time complexity. Details of
implementation are given below.

For example,

$$
\begin{align}
\nonumber
\texttt{pre} &= (\color{red}{0011110101}\color{black}{0011110101})_2
\\
\nonumber
\texttt{cur} &= (\color{red}{0110110101}\color{black}{1110101101})_2
\end{align}
$$

For convenience, we'll call the red part 0-part and the black part 1-part.

Let $\texttt{dp}[i][j][p][q]$ be the length of longest beautiful sequence that
for first $i$ elements, end with element that 1-part is $j$, satisfying
$\text{pop}(\texttt{0-part of end}\ \&\ p)=q$,

For each state, we preprocess the 1-part and predict the 0-part of next element.

Now for the current state, we certainly know it transfer from
$\texttt{dp}[i-1][j][\texttt{0-part of cur}][q]$.

For last element $\texttt{pre}$, we're sure that its 1-part is $j$, and
$\text{pop}(\texttt{0-part of pre}\ \&\ \texttt{0-part of cur})=q$.

Since it's required that
$\text{pop}(\texttt{0-part of pre}\ \&\ \texttt{0-part of cur}) + \text{pop}(\texttt{1-part of pre}\ \&\ \texttt{1-part of cur}) = k[i]$,
so enumerate $\texttt{1-part of pre}$ and transfer in $O(\sqrt{a[i]})$ is
possible.

For $\texttt{dp}[i][j][p][q]$, enumerate $p$ to predict the next elements.

Use the rolling array technique to eliminate the first dimension, and we'll get
$\mathcal{O}(N\sqrt{{a[i]}})$.

</Spoiler>

<Spoiler title="Implementation">

**Time Complexity:** $\mathcal{O}(N\sqrt{{a[i]}})$

**Memory Complexity:** $\mathcal{O}({a[i]}\log a[i])$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxcount = 10;
const int mask = 1 << maxcount;
const int maxn = 100005;

int pop[mask];  // popcount array

int f[mask][mask][maxcount + 1];
int last[maxn];  // store position of last chosen element

int id[mask][mask][maxcount + 1];
int a[maxn], k[maxn];
int n;
int sol[maxn], len;

int main() {
	cin >> n;
	for (int i = 1; i < mask; i++) {
		pop[i] = pop[i >> 1] + (i & 1);
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> k[i];
	}
	int maxid = 0, maxn = 0;
	for (int i = 1; i <= n; i++) {
		int cur0 = (a[i]) >> maxcount, cur1 = (a[i]) & (mask - 1), ans = 1;
		for (int pre1 = 0; pre1 < mask; pre1++) {
			int q = k[i] - pop[pre1 & cur1];
			if (q >= 0 && q <= maxcount && ans < f[pre1][cur0][q] + 1) {
				ans = f[pre1][cur0][q] + 1;
				last[i] = id[pre1][cur0][q];
			}
		}
		for (int nex0 = 0; nex0 < mask; nex0++) {
			int q = pop[nex0 & cur0];
			if (ans > f[cur1][nex0][q]) {
				f[cur1][nex0][q] = ans;
				id[cur1][nex0][q] = i;
			}
		}
		if (maxn < ans) {
			maxn = ans;
			maxid = i;
		}
	}
	int cur = maxid;
	while (cur) { // generate path
		sol[++len] = cur;
		cur = last[cur];
	}
	cout << len << endl;
	for (int i = len; i >= 1; i--) {
		cout << sol[i] << " \n" [i == 1];
	}
}
```

</CPPSection>
</LanguageSection>

</Spoiler>
