---
id: izho-17-LongestBeautifulSequence
source: IZhO 2017
title: 2017 - Longest beautiful sequence
author: Shijie Ren
---

<Spoiler title="Hint 1">

Both $\mathcal{O}(N^2)$ and $\mathcal{O}(N\max{a[i]})$ algorithm is not hard to
come up with,

but the latter one is more enlightening.

</Spoiler>

<Spoiler title="Hint 2">

You may find two ways of $\mathcal{O}(N\max{a[i]})$ DP.

One is to traverse all the situations of the previous number (kind of
preprocessing previous answers), $\mathcal{O}(\max{a[i]})$ to query current
answer in DP array and $\mathcal{O}(1)$ to update.

The other is to traverse all the possible situations of the next number , (kind
of predicting next answers) $\mathcal{O}(1)$ to query current answer in DP array
and $\mathcal{O}(\max{a[i]})$ to update , but need a bit more memory.

These algorithms are not efficient enough because the time complexity of update
and query are unbalanced.

Try to Consider the two equations carefully and try to "combine" their ideas.

</Spoiler>

<Spoiler title="Explanation">

$\mathcal{O}(N^2)$ DP:

Let $\texttt{dp}[i]$ be the length of longest beautiful sequence end with
$a[i]$.

$$
\texttt{dp}[i]=\max_{j<i,\text{popcount}(a[i]\&a[j])=k[i]}\{\texttt{dp}[j]\}+1
$$

We can also use $a[i]$ as indices:

$\mathcal{O}(N\max a[i])$ DP:

Let $\texttt{dp}[i][j]$ be the length of longest beautiful sequence of first $i$
elements end with $j$ (i.e. $j=\texttt{EndElement}$) ,

then
$\max\limits_{j\leq\max{a[i]},\text{popcount}(j\&a[i])=k[i]}\{\texttt{dp}[i-1][j]\}+1$
will be the length of longest beautiful sequence end with $a[i]$.

$$
\texttt{dp}[i][a[i]] = \max \{ \texttt{dp}[i-1][a[i]] , \max_{j\leq\max{a[i]},\text{popcount}(j\&a[i])=k[i]}\{\texttt{dp}[i-1][j]\}+1 \}
$$

$$
\texttt{dp}[i][j] = \texttt{dp}[i-1][j] , j\not=a[i]
$$

Or another way:

Let $\texttt{dp}[i][j][q]$ be the length of longest beautiful sequence of first
$i$ elements satisfied $\text{popcount}(\texttt{EndElement}\&j)=q$ ,

then $\texttt{dp}[i-1][a[i]][k[i]]+1$ will be the length of longest beautiful
sequence end with $a[i]$.

$$
\texttt{dp}[i][j][\text{popcount}(a[i]\&j)]=\max_{j\leq\max{a[i]}}\{\texttt{dp}[i-1][j][\text{popcount}(a[i]\&j)],\texttt{dp}[i-1][a[i]][k[i]]+1\}
$$

According to Hint 2 , we need to consider either of them , that is , to consider
the answers before and after.

Since $a[i] < 2^{20}$ , divide the 20-bits number into two 10-bits numbers.

For convenience , let $\text{b0}(x) = \lfloor \frac{x}{2^{10}} \rfloor$
represents 10-19 bits , let $\text{b1}(x) = x \& 2^{10} $ represents 0-9 bits.

Let $\texttt{ans}[i]$ be the length of longest beautiful sequence end with
$a[i]$ , and $dp[p][i][j][q]$ be the length of longest beautiful sequence of
first $p$ elements satisfied $i = \text{b1}(\texttt{EndElement})$ ,
$
\text{popcount}(\text{b0}(\texttt{EndElement})\&j)=q$.

For convenience , $\texttt{cur0} = \text{b0}(a[i])$ ,
$\texttt{cur1} = \text{b1}(a[i]))$.

Thus , we have

$$
\texttt{ans}[i] = \max_{\texttt{pre1} < 2^{10}} \{ f[i-1][\texttt{pre1}][\texttt{cur0}][k[i] - \text{popcount}(\texttt{pre1} \& \texttt{cur1})] + 1 \}
$$

$$
f[i][\texttt{cur1}][\texttt{nex0}][\text{popcount}(\texttt{nex0} \& \texttt{cur0})] = \max \{ f[i-1][\texttt{cur1}][\texttt{nex0}][\text{popcount}(\texttt{nex0} \& \texttt{cur0})] , \texttt{ans}[i] \}
$$

For the solution , just store which state this state is transferred from , then
output in reverse order.

</Spoiler>

<Spoiler title="Implementation">

**Time Complexity:** $\mathcal{O}(N\sqrt{\max{a[i]}})$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int maxcount = 10;
const int mask = 1 << maxcount;
const int maxn = 100005;

int cnt[mask]; // popcount array
int f[mask][mask][maxcount + 1];
int last[maxn]; // store position of last chosen element
int id[mask][mask][maxcount + 1];
int a[maxn], k[maxn];
int n;
int sol[maxn], len;

int main() {
	cin >> n;
	for (int i = 1; i < mask; i++) {
		cnt[i] = cnt[i >> 1] + (i & 1);
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++) {
		cin >> k[i];
	}
	int maxid = 0, maxn = 0;
	for (int i = 1; i <= n; i++) {
		int cur0 = (a[i]) >> maxcount, cur1 = (a[i]) & (mask - 1), ans = 1;
		for (int pre1 = 0; pre1 < mask; pre1++) {
			int bc = k[i] - cnt[pre1 & cur1];
			if (bc >= 0 && bc <= maxcount && ans < f[pre1][cur0][bc] + 1) {
				// bc >= 0 && bc <= maxcount is important!
				ans = f[pre1][cur0][bc] + 1;
				last[i] = id[pre1][cur0][bc];
			}
		}
		for (int nex0 = 0; nex0 < mask; nex0++) {
			int bc = cnt[nex0 & cur0];
			if (ans > f[cur1][nex0][bc]) {
				f[cur1][nex0][bc] = ans;
				id[cur1][nex0][bc] = i;
			}
		}
		if (maxn < ans) {
			maxn = ans;
			maxid = i;
		}
	}
	int cur = maxid;
	while (cur) { // generate path
		sol[++len] = cur;
		cur = last[cur];
	}
	cout << len << endl;
	for (int i = len; i >= 1; i--) {
		if (i == 1) {
			cout << sol[i] << endl;
		} else {
			cout << sol[i] << " ";
		}
	}
}
```

</CPPSection>

</LanguageSection>

</Spoiler>
