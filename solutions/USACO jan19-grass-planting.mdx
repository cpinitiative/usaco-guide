---
id: usaco-894
source: USACO Silver 2019 January
title: Grass Planting
author: Aadit Ambadkar
---

## Solution 1 - Intended Solution

$\mathcal{O}(N)$ using a key insight.

Let `adj[i]` represent the number of paths adjacent to node $i$ in the graph. Then, considering that node, and that node alone, you would need exactly `adj[i]+1` numbers to fill it. This is because you would need `adj[i]` for each of the adjacent nodes, and $1$ for the node itself. So, our answer is the maximum of all the adjacents, plus $1$. 

```java
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class planting {
	public static void main(String[] args) throws IOException {
		BufferedReader f = new BufferedReader(new FileReader("planting.in"));
		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("planting.out")));
		StringTokenizer st = new StringTokenizer(f.readLine());
		int n = Integer.parseInt(st.nextToken());
		if (n==1) {
			pw.println(1);
			pw.close();
		} else if (n==2) {
			pw.println(2);
			pw.close();
		}
		int[] adj = new int[n];
		Arrays.fill(adj, 1);
		int max=1;
		for (int i = 0; i < n-1; i++) {
			st = new StringTokenizer(f.readLine());
			int ne = Integer.parseInt(st.nextToken())-1;
			if (++adj[ne]>adj[max]) max=ne;
			ne = Integer.parseInt(st.nextToken())-1;
			if (++adj[ne]>adj[max]) max=ne;
		}
		pw.println(adj[max]);
		pw.close();
	}
}
```

## Solution 2 - DFS

This can also be solved using DFS in $\mathcal{O}(V+E)$, which for this problem is $\mathcal{O}(N)$.

```java
import java.io.*;
import java.util.*;

public class Main {
	public static int[] visited;
	public static ArrayList<ArrayList<Integer>> adj;

	public static void main(String[] args) throws IOException {
		BufferedReader f = new BufferedReader(new FileReader("planting.in"));
		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("planting.out")));
		StringTokenizer st = new StringTokenizer(f.readLine());
		int farms = Integer.parseInt(st.nextToken());
		adj = new ArrayList<>();
		for (int i = 0; i < farms; i++) {
			adj.add(new ArrayList<Integer>());
		}
		for (int i = 0; i < farms - 1; i++) {
			st = new StringTokenizer(f.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			adj.get(a - 1).add(b - 1);
			adj.get(b - 1).add(a - 1);
		}
		visited = new int[farms];
		Arrays.fill(visited, 0);
		visited[0] = 1;
		dfs(0, 0);
		int max = 0;
		for (int i : visited) {
			max = Math.max(max, i);
		}
		pw.println(max);
		pw.close();
	}

	public static void dfs(int self, int parent) {
		int len = adj.get(self).size();
		int g = 1;
		for (int i : adj.get(self)) {
			if (i != parent) {
				while (g == visited[self] || g == visited[parent]) g++;
				visited[i] = g;
				dfs(i, self);
				g++;
			}
		}
	}
}
```
