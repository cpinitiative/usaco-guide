---
id: usaco-759
source: USACO Bronze 2018 January
title: Blocked Billboard II
author: Melody Yu (Python), Hua Zhi Vee (C++)
---

[Official Analysis](http://www.usaco.org/current/data/sol_billboard_bronze_jan18.html)

<LanguageSection>

<PySection>

## Python Implementation

```py
fIn, fOut = open("billboard.in"), open("billboard.out", "w")

x1, y1, x2, y2 = map(lambda x: int(x), fIn.readline().split())
x3, y3, x4, y4 = map(lambda x: int(x), fIn.readline().split())

tlCorner = False
trCorner = False
brCorner = False
blCorner = False

if y3 <= y1 and x3 <= x1:
    blCorner = True

if y4 >= y2 and x4 >= x2:
    trCorner = True

if x3 <= x1 and y4 >= y2:
    tlCorner = True

if x4 >= x2 and y3 <= y1:
    brCorner = True


cornerCount = len(list(filter(lambda x:x, [blCorner, trCorner, brCorner, tlCorner])))

if blCorner and trCorner:
    fOut.write(str(0))

elif cornerCount == 0 or cornerCount == 1:
    fOut.write(str(abs(x2 - x1) * abs(y2 - y1)))

elif brCorner and trCorner:
    fOut.write(str(abs(y2 - y1) * abs(x2 - x4)))

elif blCorner and tlCorner:
    fOut.write(str(abs(y2 - y1) * abs(x2 - x4)))

elif trCorner and tlCorner:
    fOut.write(str(abs(x2 - x1) * abs(y3 - y1)))

elif brCorner and blCorner:
    fOut.write(str(abs(x2 - x1) * abs(y3 - y1)))

```

</PySection>


<CPPSection>

**Time Complexity:** $\mathcal{O}(1)$

```cpp 
#include<bits/stdc++.h>
using namespace std;

struct Rect {
	int x1,y1,x2,y2;
	int area() { return (y2-y1)*(x2-x1); }
} r1, r2;

int isInRect(int x, int y, Rect r){
	if(x >= r.x1 && x <= r.x2 && y >= r.y1 && y <= r.y2) return 1;
	else return 0;
}

int main() {
	ifstream fin("billboard.in");
	ofstream fout("billboard.out");
	
	fin >> r1.x1 >> r1.y1 >> r1.x2 >> r1.y2 >> r2.x1 >> r2.y1 >> r2.x2 >> r2.y2;
	
	// Check how many corners are covered
	int coveredCorners = 0;
	coveredCorners += isInRect(r1.x1, r1.y1, r2);
	coveredCorners += isInRect(r1.x1, r1.y2, r2);
	coveredCorners += isInRect(r1.x2, r1.y1, r2);
	coveredCorners += isInRect(r1.x2, r1.y2, r2);
	if(coveredCorners == 4){
		fout << 0 << endl;
		return 0;
	} 
	
	// If there are only 1 corner or none covered (including if it passes through the middle, we need to include all)
	if(coveredCorners < 2){
		fout << r1.area() << endl;
		return 0;
	}
	
	// Now there are two covered corners. So we can deduct the area with the intersection of the rectangles.
	fout << r1.area() - max(0,min(r1.x2,r2.x2)-max(r1.x1,r2.x1)) * max(0,min(r1.y2,r2.y2)-max(r1.y1,r2.y1)) << endl;
	return 0;
}
```
</CPPSection>
</LanguageSection>
