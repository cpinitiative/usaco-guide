---
id: cses-1621
source: CSES
title: Distinct Numbers
author: Andrew Wang, Maggie Liu, Dustin Miao
---

## Explanation

Sort the array of numbers. Loop through the array and increment the answer for
every distinct number. Distinct numbers can be found if the current number isn't
equal to the previous number in the array.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log{N})$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int N;
	cin >> N;
	vector<int> arr(N);
	for (int i = 0; i < N; i++)
		cin >> arr[i];
	sort(arr.begin(), arr.end());
	int ans = 1;
	for (int i = 1; i < N; i++) {
		/*
		 * if the current number is different from the previous
		 * it is a distinct number so we add 1 to the answer
		 */
		ans += (arr[i] != arr[i - 1]);
	}
	cout << ans << endl;
	return 0;
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class DistinctNumbers {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
		Arrays.sort(arr);
		int ans = 1;
		for (int i = 1; i < n; i++) {
			/*
			 * if the current number is different from the previous
			 * it is a distinct number so we add 1 to the answer
			 */
			if (arr[i] != arr[i - 1]) {
				ans++;
			}
		}
		System.out.println(ans);
	}
}
```

</JavaSection>

<PySection>

```py
n = int(input())
# create a sorted list of the numbers
numbers = sorted(map(int, input().split()))
ans = 1
for i in range(1, n):
	# if the current number is different from the previous
	# it is a distinct number so we add 1 to the answer
	if numbers[i] != numbers[i - 1]:
		ans += 1
print(ans)
```

</PySection>

</LanguageSection>

## Alternative Solution
	
By using an std::set in c++ or its equivalents in other languages, we can take advantage of the fact that a set only stores a copy of an element once.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log{N})$

	
<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int N;
set<int> S;
 
int main() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		int a; cin >> a;
		S.insert(a);
	}
	cout << S.size() << '\n';
}
```
</CPPSection>
<JavaSection>

```java
// Source: Daniel

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.StringTokenizer;

public class DistinctNumbers {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		StringTokenizer st = new StringTokenizer(br.readLine());
		HashSet<Integer> set = new HashSet<Integer>();
		for (int i = 0; i < n; i++) {
			set.add(Integer.parseInt(st.nextToken()));
		}
		System.out.println(set.size());
	}

}
```

</JavaSection>

<PySection>

```py
n = int(input()) # unused
nums = [int(x) for x in input().split()]
distinct_nums = set(nums)
print(len(distinct_nums))
```

We can do this more efficiently by skipping the creation of the list, and use a
set comprehension directly:

```py
n = int(input()) # unused
distinct_nums = {int(x) for x in input().split()}
print(len(distinct_nums))
```

</PySection>

</LanguageSection>
