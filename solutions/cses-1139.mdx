---
id: cses-1139
source: CSES Distinct Colors
title: Distinct Colors
author: Neo Wang
---

## Explanation

Since the graph forms a tree, we can perform
[small to large merging](/plat/merging) in order to calculate the number of
distinct colors in a subtree. At each node, store a `set` to keep track of all
the distinct colors in their respective subtree. To find the number of distinct
colors, we can query the number of items in the set of node $x$ after merging
the sets of all subtrees of $x$ into it.

## Implementation

**Time Complexity:** $\mathcal{O}(N\log^2 N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <vector>
#include <set>

using namespace std;

const int MAX_N = 2e5;

// nodes will be 1-indexed like in the problem
vector<int> adj[MAX_N + 1];

set<int> colors[MAX_N + 1];
int distinct_num[MAX_N + 1];

void process_colors(int curr, int parent) {
	for (int n : adj[curr]) {
		if (n != parent) {
			process_colors(n, curr);
			// make x the larger set always
			if (colors[curr].size() < colors[n].size()) {
				swap(colors[curr], colors[n]);
			}
			for (int item : colors[n]) {
				colors[curr].insert(item);
			}
		}
	}
	distinct_num[curr] = colors[curr].size();
}

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int a;
		std::cin >> a;
		colors[i].insert(a);
	}
	for (int i = 1; i < n; i++) {
		int a;
		int b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	process_colors(1, 0);
	for (int i = 1; i <= n; i++) {
		cout << distinct_num[i] << (i < n ? " " : "\n");
	}
}
```

</CPPSection>

<PySection>

(if you have Python code)

</PySection>

<JavaSection>

(if you have Java code)

</JavaSection>

</LanguageSection>
