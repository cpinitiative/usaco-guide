---
id: cses-1742
source: CSES
title: Robot Path
author: Mihnea Brebenel
---

## Explanation
As you have already guessed this is a sweep line problem.
But the main issue is how to find the first intersection when the robot stops ? To find the first intersection, we use binary search.

The last thing to do is to find the length of the incomplete segment - the on that causes the intersection. There are several ways to do this. 
The easiest way is to binary search for it.

## Implementation

**Time Complexity: $\mathcal O(N \log N)$**

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
#define ll long long 
#define all(x) (x).begin(), (x).end()

using namespace std;

const int BEGINNING_VALUE = -2;
const int ENDING_VALUE = 100;

// BeginCodeSnip{Segment Tree Code}
class segtree {
private:
    vector<int> t;
public:
    segtree(int N) { t.resize(3 * N); }
    void update(int node, int l, int r, int idx, int val) {
        if(l == r) {
            t[node] += val;
            return;
        }
        int mid = (l + r) >> 1;
        if(idx <= mid) update(2*node, l, mid, idx, val);
        else update(2*node+1, mid+1, r, idx, val);
        t[node] = t[2*node] + t[2*node+1];
    }
    int query(int node, int l, int r, int x, int y) {
        if(r < x || l > y) return 0;
        if(x <= l && r <= y ) return t[node];
        int mid = (l + r) >> 1;
        return query(2*node, l, mid, x, y) + query(2*node+1, mid+1, r, x, y);
    }
};
// EndCodeSnip

int n;
ll max_y;
vector<char> direction;
vector<segment> segments, original_segments;
map<char, pair<int, int>> dir;

struct point{ ll x, y; };
struct segment{ ll a, b, x, y; };
struct event{ 
	ll x, y, id; 
    bool operator<(const event &other) {
        if(x == other.x)
            return (0 <= id && id < n && 0 <= other.id && other.id < n) ? segments[id].b < segments[other.id].b : id < other.id;

        return x < other.x;
    }
};

void coordinate_compression(vector<segment> &v) {
    vector<ll> compressx, compressy; 
    compressx.push_back(0);
    compressy.push_back(0);
    for(auto seg : v) {
        compressx.push_back(seg.a); compressx.push_back(seg.x);
        compressy.push_back(seg.b); compressy.push_back(seg.y);
    }
	sort(all(compressx)); 
	compressx.erase(unique(all(compressx)), compressx.end());
	sort(all(compressy)); 
	compressy.erase(unique(all(compressy)), compressy.end());
	for(segment &seg : v) {
		seg.a = lower_bound(all(compressx), seg.a) - compressx.begin() + 1;
		seg.x = lower_bound(all(compressx), seg.x) - compressx.begin() + 1;

		seg.b = lower_bound(all(compressy), seg.b) - compressy.begin() + 1;
		seg.y = lower_bound(all(compressy), seg.y) - compressy.begin() + 1;

		if(seg.a > seg.x) swap(seg.a, seg.x);
		if(seg.b > seg.y) swap(seg.b, seg.y);
        max_y = max(max_y, seg.b);
        max_y = max(max_y, seg.y);
	}
}

bool intersect(int idx) {
	vector<event> events;
	for(int i = 0; i <= idx; i++) {
		if(segments[i].a == segments[i].x) { 
			events.push_back({segments[i].a, segments[i].b, i});
		} else {
			events.push_back({segments[i].a, segments[i].b, BEGINNING_VALUE});
			events.push_back({segments[i].x, segments[i].y, ENDING_VALUE});
		}
	}
    sort(all(events));

    segtree sg(max_y);
    segment last_vertical_line = {0, 0, 0, 0};
    for(auto event : events) {
        if(event.id == BEGINNING_VALUE) { 
            // Beginnig of a horizontal line
            sg.update(1, 1, max_y, event.y, 1);
            // Check for horizontal-horizontal intersection
            if( sg.query(1, 1, max_y, event.y, event.y) > 1 ) return true; 
        } else if(event.id == ENDING_VALUE) { 
            // Ending of a horizontal line
            sg.update(1, 1, max_y, event.y, -1);
        } else { 
            // Checking for vertical-horizontal intersection
            if( sg.query(1, 1, max_y, segments[event.id].b, segments[event.id].y) > 0 ) 
                return true;
            // Checking for vertical-vertical intersection
            if(segments[event.id].a == last_vertical_line.a && segments[event.id].b <= last_vertical_line.y  && segments[event.id].y > last_vertical_line.b)
                return true;
            last_vertical_line = segments[event.id];
        }
    }
    return false;
}

int main() {
	scanf("%d ", &n);

	dir['R'] = {1, 0}; dir['L'] = {-1, 0};
	dir['U'] = {0, 1}; dir['D'] = {0, -1};

	ll a = 0, b = 0;
	for(int i = 0; i < n; i++) {
		char c;
		int steps;
		scanf("%c %d ", &c, &steps);
		ll x = a + dir[c].first * steps;
		ll y = b + dir[c].second * steps;
        if( i > 0 ) {
            a += dir[c].first;
            b += dir[c].second;
        }
        direction.push_back(c);
		segments.push_back({a, b, x, y});
        original_segments.push_back({a, b, x, y});
		a = x, b = y;
	}

	coordinate_compression(segments);

    // Binary search
	int l = 0, r = n - 1, last = r;
	while(l <= r) {
        // Check if the first mid segments intersect
		int mid = (l + r) >> 1;
		if(!intersect(mid)) 
			l = mid + 1, last = mid;
		else 
			r = mid - 1;
	}

    
    auto dist = [](segment seg) { return abs(seg.x - seg.a) + abs(seg.y - seg.b) + 1; };
    auto orientation = [](point a, point b, point c) { return (b.x-a.x) * (c.y-a.y) - (c.x-a.x) * (b.y-a.y); };
    // Check if segment a and b intersect
    auto intersect = [&](segment a, segment b) {
        if(a.a > a.x) swap(a.a, a.x);
        if(a.b > a.y) swap(a.b, a.y);
        if(b.b > b.y) swap(b.b, b.y);
        if(b.a > b.x) swap(b.a, b.x);
        if(a.b == a.y && b.b == b.y && a.b == b.b) return a.a <= b.x && a.x > b.a;
        if(a.a == a.x && b.a == b.x && a.a == b.a) return a.b <= b.y && a.y > b.b;
        if(a.a == a.x && b.b == b.y) return  a.b <= b.b && b.b <= a.y && b.a <= a.a && b.x >= a.a;
        if(a.b == a.y && b.a == b.x) return  b.b <= a.b && a.b <= b.y && a.a <= b.a && a.x >= b.a;
        return false;
    };

    // Add up all the segment lengths before the intersection
    ll ans = -1;
    for(int i = 0; i <= last; i++) ans += dist(original_segments[i]);

    // Check if there are no intersections & if the next segment is useless
    if(last == n-1 || (direction[last+1] == 'D' && direction[last] == 'U') ||  (direction[last+1] == 'U' && direction[last] == 'D') || (direction[last+1] == 'L' && direction[last] == 'R') || (direction[last+1] == 'R' && direction[last] == 'L')) {
        printf("%lli\n", ans);
        return 0;   
    }

    // Find the length of the incomplete segment - the one that causes the intersection
    char c = direction[last+1];
    segment seg = original_segments[last+1];
    l = 0, r = dist(seg);
    ll add = 0;
    // Binary search its length
    while(l <= r) {
        int mid = (l + r) >> 1;
        segment new_seg = {seg.a, seg.b, seg.a + dir[c].first * mid, seg.b + dir[c].second * mid};
        bool ok = 1;
        // Check if this lenth causes an intersection with other segment
        for(int i = 0; i < last && ok; i++)
            if( intersect(new_seg, original_segments[i]) )        
                ok = 0;
        if(ok)
            l = mid + 1, add = dist(new_seg) + !(new_seg.a == new_seg.x && new_seg.x == new_seg.y) ;
        else 
            r = mid - 1;
    }
    printf("%lli\n", ans+add);

	return 0;
}
```
</CPPSection>
</LanguageSection>