---
id: hr-SubtreesPaths
source: HR
title: Subtrees & Paths
author: Rameez Parwez
---

[Official Editorial](https://www.hackerrank.com/challenges/subtrees-and-paths/editorial)

## Intuition

The problem requires us to perform two operations: adding a value $x$ to all nodes in the subtree rooted at $t$, and finding the maximum value on the path from $a$ to $b$. From the [Tutorial](https://usaco.guide/plat/hld?lang=cpp#tutorial) we know that Heavy-Light Decomposition(HLD) handles both operations efficiently. Therefore we will use HLD along with a Lazy Segment Tree for the query operations.

## Explanation
At first, we choose an arbitrary root (i.e., node 1) and start a DFS over the tree to calculate the depth and subtree size for each node. Afterward, the decomposition is performed, which transforms the tree into a structure suitable for Lazy Segment Tree operations by assigning linearized positions to nodes and identifying heavy paths.

The subtree update operation needs to be performed efficiently. During the update, we first handle any pending updates for the current segment tree node to ensure that all the previous changes are applied correctly before handling the new update. If the current segment is entirely within the update range, we add the update value to the node's lazy value. Additionally, if the node is not a leaf node, the update is also propagated to its children. This propagation ensures that future operations on the children will account for the update.

To find the maximum value on the path from $a$ to $b$, instead of traversing directly from $a$ to $b$ and finding the maximum value in linear time, we first calculate the Lowest Common Ancestor(LCA) and split the path into two segments
- $a$ to $LCA(a, b)$
- $b$ to $LCA(a, b)$

After splitting the path, we will use Lazy Segment Tree to calculate the maximum value in each segment, which operates in logarithmic time for each segment. Once we have computed the maximum values for both segments, combining these results gives us the maximum value along the entire path from $a$ to $b$.

## Implementation
**Time Complexity:** $\mathcal{O} ((N + Q) \log^2(N))$
<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 1e5 + 1, LG = 18, INF = 1e9 + 9;
// BeginCodeSnip{Lazy Segment Tree}
struct LST {

	int t[4 * MAX_N], lazy[4 * MAX_N];
	LST() {
		fill(t, t + 4 * MAX_N, -INF);
		fill(lazy, lazy + 4 * MAX_N, 0);
	}

	inline void push(int n, int b, int e) {
		if (lazy[n] == 0) { return; }
		t[n] = t[n] + lazy[n];
		if (b != e) {
			lazy[2 * n] = lazy[2 * n] + lazy[n];
			lazy[2 * n + 1] = lazy[2 * n + 1] + lazy[n];
		}
		lazy[n] = 0;
	}

	inline int combine(int a, int b) { return max(a, b); }

	inline void pull(int n) { t[n] = max(t[2 * n], t[2 * n + 1]); }

	void build(int n, int b, int e) {
		if (b == e) {
			t[n] = 0;
			return;
		}

		int mid = (b + e) >> 1;
		build(2 * n, b, mid);
		build(2 * n + 1, mid + 1, e);
		pull(n);
	}

	void upd(int n, int b, int e, int i, int j, int v) {
		push(n, b, e);
		if (j < b || e < i) { return; }

		if (i <= b && e <= j) {
			lazy[n] += v;
			push(n, b, e);
			return;
		}

		int mid = (b + e) >> 1;
		upd(2 * n, b, mid, i, j, v);
		upd(2 * n + 1, mid + 1, e, i, j, v);
		pull(n);
	}

	int query(int n, int b, int e, int i, int j) {
		push(n, b, e);
		if (i > e || b > j) { return -INF; }
		if (i <= b && e <= j) { return t[n]; }
		int mid = (b + e) >> 1;
		return combine(query(2 * n, b, mid, i, j),
		               query(2 * n + 1, mid + 1, e, i, j));
	}
} lseg;
// EndCodeSnip

vector<int> adj[MAX_N];
int par[MAX_N][LG + 1], dep[MAX_N], sz[MAX_N];

// compute the size of each subtree and set parent relationships
void dfs_sz(int u, int p = 0) {
	par[u][0] = p;
	dep[u] = dep[p] + 1;
	sz[u] = 1;
	for (int i = 1; i <= LG; i++) { par[u][i] = par[par[u][i - 1]][i - 1]; }

	for (int &v : adj[u]) {
		if (v != p) {
			dfs_sz(v, u);
			sz[u] += sz[v];
			if (sz[v] > sz[adj[u][0]]) { swap(v, adj[u][0]); }
		}
	}
}

/** @return lowest common ancestor of nodes u and v */
int lca(int u, int v) {
	if (dep[u] < dep[v]) { swap(u, v); }
	for (int k = LG; k >= 0; k--) {
		if (dep[par[u][k]] >= dep[v]) { u = par[u][k]; }
	}

	if (u == v) { return u; }

	for (int k = LG; k >= 0; k--) {
		if (par[u][k] != par[v][k]) {
			u = par[u][k];
			v = par[v][k];
		}
	}
	return par[u][0];
}

int kth(int u, int k) {
	assert(k >= 0);
	for (int i = 0; i <= LG; i++) {
		if (k & (1 << i)) { u = par[u][i]; }
	}
	return u;
}

int T, head[MAX_N], st[MAX_N], en[MAX_N];
int n;

void dfs_hld(int u, int chain) {
	int k = 0;
	T++;
	st[u] = T;
	head[u] = chain;
	for (int v : adj[u]) {
		if (dep[v] > dep[u] and sz[v] > sz[k]) { k = v; }
	}

	if (k == 0) {
		en[u] = T;
		return;
	}
	dfs_hld(k, chain);
	for (int v : adj[u]) {
		if (dep[v] > dep[u] and k != v) { dfs_hld(v, v); }
	}
	en[u] = T;
}

/** @return maximum value on the path from u to the root of the chain containing v 
int query_up(int u, int v) { 
	int res = -INF; 
	while (head[u] != head[v]) { 
		res = max(res, lseg.query(1, 1, n, st[head[u]], st[u]));
		u = par[head[u]][0];
    }
    res = max(res, lseg.query(1, 1, n, st[v], st[u]));
    return res;
}

/** @return  maximum value on the path from u to v  */
int query(int u, int v) {
	int l = lca(u, v);
	int res = query_up(u, l);
	if (v != l) { res = max(res, query_up(v, kth(v, dep[v] - dep[l] - 1))); }

	return res;
}

int main() {
	cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	dfs_sz(1);
	head[1] = 1;
	dfs_hld(1, 1);

	int q;
	cin >> q;
	lseg.build(1, 1, n);
	while (q--) {
		string type;
		int u, v;
		cin >> type >> u >> v;
		if (type == "add") {
			lseg.upd(1, 1, n, st[u], en[u], v);
		} else {
			cout << query(u, v) << '\n';
		}
	}
	return 0;
}
```
</CPPSection>
</LanguageSection>
