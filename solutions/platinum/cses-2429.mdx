---
id: cses-2429
source: CSES
title: Grid Completion
author: Ashok Narayan
---

## Explanation

This problem asks us to count the number of valid ways to complete the grid while respecting the constraints imposed by characters `A` and `B`.

Each row may contain:

- No marked cell,
- Only an `A`,
- Only a `B`,
- Or both.

Similarly, each column may or may not already contain an `A` or `B`.

The goal is to count the number of valid permutations of columns assigned to rows such that:

- All `A` constraints are satisfied,
- All `B` constraints are satisfied,
- And no conflicts occur.

---

### Key Observation

A direct counting approach is difficult because constraints interact across rows and columns.

Instead of counting only valid permutations, we:

1. Count permutations under relaxed conditions,
2. Subtract invalid configurations,
3. Correct overcounting using the **Principle of Inclusion–Exclusion (PIE)**.

Overcounting happens when:

- A row violates its `A` constraint,
- A row violates its `B` constraint,
- Multiple violations occur simultaneously.

To systematically handle this, we classify rows and columns into structural categories.

---

### Category Definitions

Let:

- `C0`: Rows with neither `A` nor `B`
- `C1`: Rows with only `B`, and its column has no `A`
- `C2`: Rows with only `A`, and its column has no `B`
- `C3`: Columns with neither `A` nor `B`
- `C4`: Columns without `A`
- `C5`: Columns without `B`

These values summarize all available flexibility in the grid.

---

### Applying Inclusion–Exclusion

We iterate over three parameters:

- `i`: number of rows chosen from `C0`
- `j`: number chosen from `C1`
- `k`: number chosen from `C2`

For each triple $(i, j, k)$:

1. Choose rows:
   - $\binom{C_0}{i}$
   - $\binom{C_1}{j}$
   - $\binom{C_2}{k}$

2. Choose matching columns from free columns:
   - $\binom{C_3}{i}$

3. Arrange remaining free columns:
   - $(C_4 - i - j)!$
   - $(C_5 - i - k)!$

4. Match selected rows and columns:
   - $i!$

5. Apply alternating sign:

$$
(-1)^{i + j + k}
$$

This sign is the heart of Inclusion–Exclusion:

- Add configurations with 0 violations,
- Subtract those with 1 violation,
- Add back those with 2 violations,
- Subtract 3 violations,
- And so on.

---

### Final Formula

The final answer is:

$$
\sum_{i,j,k}
(-1)^{i+j+k}
\cdot
\binom{C_0}{i}
\binom{C_1}{j}
\binom{C_2}{k}
\binom{C_3}{i}
\cdot
i!
\cdot
(C_4-i-j)!
\cdot
(C_5-i-k)!
$$

This formula counts all valid completions while correcting overcounting via the Inclusion–Exclusion Principle.

---

## Implementation

**Time Complexity:** $\mathcal{O}(N^3)$

**Space Complexity:** $\mathcal{O}(N)$

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const ll MOD = 1e9 + 7;
const int MAXN = 505;

ll fact[MAXN], invfact[MAXN];

// BeginCodeSnip{Binary Exponentiation}
ll binpow(ll a, ll b) {
	ll r = 1;
	while (b) {
		if (b & 1) r = r * a % MOD;
		a = a * a % MOD;
		b >>= 1;
	}
	return r;
}
// EndCodeSnip
// BeginCodeSnip{Combination Formula}
ll nCr(int n, int r) {
	if (r < 0 || r > n) return 0;
	return fact[n] * invfact[r] % MOD * invfact[n - r] % MOD;
}
// EndCodeSnip
// BeginCodeSnip{Formula from Editorial}
ll formula(int C0, int C1, int C2, int C3, int C4, int C5) {
	ll ans = 0;

	for (int i = 0; i <= min(C0, C3); i++) {
		for (int j = 0; j <= C1; j++) {
			for (int k = 0; k <= C2; k++) {

				ll cur = 1;

				cur = cur * nCr(C0, i) % MOD;
				cur = cur * nCr(C1, j) % MOD;
				cur = cur * nCr(C2, k) % MOD;
				cur = cur * nCr(C3, i) % MOD;

				cur = cur * fact[i] % MOD;
				cur = cur * fact[C4 - i - j] % MOD;
				cur = cur * fact[C5 - i - k] % MOD;

				if ((i + j + k) & 1) cur = (MOD - cur) % MOD;

				ans = (ans + cur) % MOD;
			}
		}
	}

	return ans;
}
// EndCodeSnip

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int n;
	cin >> n;

	// BeginCodeSnip{Pre-Compute}
	fact[0] = 1;
	for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;

	invfact[n] = binpow(fact[n], MOD - 2);
	for (int i = n; i > 0; i--) invfact[i - 1] = invfact[i] * i % MOD;
	// EndCodeSnip

	vector<int> p(n, -1), q(n, -1);
	vector<bool> inA(n, false), inB(n, false);

	for (int i = 0; i < n; i++) {
		string s;
		cin >> s;
		for (int j = 0; j < n; j++) {
			if (s[j] == 'A') {
				p[i] = j;
				inA[j] = true;
			}
			if (s[j] == 'B') {
				q[i] = j;
				inB[j] = true;
			}
		}
	}

	int C0 = 0, C1 = 0, C2 = 0, C3 = 0, C4 = 0, C5 = 0;

	for (int i = 0; i < n; i++) {
		if (p[i] == -1 && q[i] == -1) C0++;
		if (p[i] == -1 && q[i] != -1 && !inA[q[i]]) C1++;
		if (p[i] != -1 && q[i] == -1 && !inB[p[i]]) C2++;
	}

	for (int i = 0; i < n; i++) {
		if (!inA[i] && !inB[i]) C3++;
		if (!inA[i]) C4++;
		if (!inB[i]) C5++;
	}

	cout << formula(C0, C1, C2, C3, C4, C5) << "\n";
}
```
