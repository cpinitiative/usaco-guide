---
id: cf-1254D
source: CF
title: Tree Queries
author: Rameez Parwez
---

[Official Editorial (C++)](https://codeforces.com/blog/entry/71594)

## Explanation

The idea is to use Heavy-Light Decomposition(HLD) for its efficiency in dividing the tree into chains and ensuring that paths between any two nodes pass through a limited number of chains, along with Binary Indexed Tree(BIT) to efficiently manage cumulative sums and range updates operations.

At first, the DFS is performed starting from node $0$ to calculate the depth and subtree size. Afterwards, the decomposition is performed to transform the tree into a structure suitable for BIT operations.

For a modification, we first check if vertex $v$ has some subtree. If it does, we want to add a tag to $v$ which increase the subtree of every light child $u$ of $v$ by $(n - x) * d$. When handling the query, we find its value on BIT and sum of all tags on its path to the root.

## Implementation

**Time Complexity:** $\mathcal{O} (N + Q \log(N))$

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 150001, MOD = 998244353;
vector<int> adj[MAX_N], sum(MAX_N);
vector<int> top(MAX_N), in(MAX_N), parent(MAX_N), depth(MAX_N), out(MAX_N),
    sz(MAX_N);
int T, n, q;

vector<int> bit(MAX_N);
void add(int x, int y) {
	while (x <= MAX_N) {
		bit[x] = (bit[x] + y) % MOD;
		x += x & -x;
	}
}

void add(int l, int r, int x) {
	add(l + 1, x);
	add(r + 1, MOD - x);
}

int get(int x) {
	++x;
	int res = 0;
	while (x > 0) {
		res = (res + bit[x]) % MOD;
		x -= x & -x;
	}
	return res;
}

int power(int a, int b) {
	int res = 1;
	while (b) {
		if (b & 1) { res = 1LL * res * a % MOD; }
		a = 1LL * a * a % MOD;
		b >>= 1;
	}
	return res;
}

// calculates depth and subtree size for each node
void dfs_sz(int u) {
	sz[u] = 1;
	if (parent[u] != -1) {
		adj[u].erase(find(adj[u].begin(), adj[u].end(), parent[u]));
	}

	for (int &v : adj[u]) {
		depth[v] = depth[u] + 1;
		parent[v] = u;
		dfs_sz(v);
		sz[u] += sz[v];
		// Ensuring heavy child is the first child
		if (sz[v] > sz[adj[u][0]]) { swap(v, adj[u][0]); }
	}
}

// decomposition of the tree into a suitable structure for range operations
void dfs_hld(int u) {
	in[u] = T++;
	for (int v : adj[u]) {
		top[v] = (v == adj[u][0] ? top[u] : v);
		dfs_hld(v);
	}
	out[u] = T;
}

void modify(int v, int d) {
	add(0, in[v], 1LL * d * sz[v] % MOD);
	add(out[v], n, 1LL * d * sz[v] % MOD);
	add(in[v], in[v] + 1, 1LL * d * n % MOD);

	if (!adj[v].empty()) {
		int u = adj[v][0];
		add(in[u], out[u], 1LL * d * (n - sz[u]) % MOD);
	}
	sum[v] = (sum[v] + d) % MOD;
}

int query(int v) {
	int res = get(in[v]);
	while (v != -1) {
		v = top[v];
		if (parent[v] != -1) {
			res = (res + 1LL * sum[parent[v]] * (n - sz[v])) % MOD;
		}
		v = parent[v];
	}
	return res;
}

int main() {
	cin >> n >> q;
	for (int i = 0; i < n - 1; i++) {
		int u, v;
		cin >> u >> v;
		u--, v--;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	parent[0] = -1;
	dfs_sz(0);
	dfs_hld(0);

	int inv = power(n, MOD - 2);
	while (q--) {
		int op;
		cin >> op;
		if (op == 1) {
			int v, d;
			cin >> v >> d;
			v--;
			modify(v, d);
		} else {
			int v;
			cin >> v;
			v--;
			cout << 1LL * query(v) * inv % MOD << '\n';
		}
	}
}
```
</CPPSection>
</LanguageSection>
