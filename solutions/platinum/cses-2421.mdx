---
id: cses-2421
source: CSES
title: Counting Reorders
author: Kiruthees G
---

# Counting Reorders

Calculate the number of ways you can reorder the characters of a string so that no two adjacent characters are the same.

---

## Strategy: Inclusion-Exclusion

The constraint "no two adjacent characters are equal" is difficult to count directly. Instead, we use the **Principle of Inclusion-Exclusion (PIE)** to transform the problem into counting arrangements with a specific number of "bad" connections.

### Defining "Bad Pairs"

Let a **Bad Pair** be an instance where two identical characters are placed next to each other (e.g., `AA`). We want to find the number of arrangements with **exactly zero** Bad Pairs.

Instead of counting "exactly zero" directly, PIE tells us to count arrangements where we have forced $K$ specific adjacencies to be bad. The formula for arrangements with zero bad pairs is:

$$
\sum_{K=0}^{n-1} (-1)^K \times (\text{Ways to force } K \text{ Bad Pairs})
$$

### Why this works
When we force $K$ adjacencies, we aren't saying the string has only $K$ bad pairs; it might have more. However, the alternating sign $(-1)^K$ ensures that any arrangement that actually contains $m$ bad pairs (where $m > 0$) is counted a total of:

$$
\sum_{k=0}^{m} \binom{m}{k}(-1)^k = (1-1)^m = 0 \text{ times}
$$

This leaves only the arrangements with zero bad pairs in our final sum, each counted exactly once.

### Connecting PIE to Segments

To calculate the "Ways to force $K$ Bad Pairs," we treat each forced adjacency as a "bond" that merges two identical characters into a single block. If we have a string of total length $n$ and we use $K$ bonds to force adjacencies, we are left with $i$ independent segments:

$$i = n - K \quad \text{or} \quad K = n - i$$

This motivates our Dynamic Programming: if we can count how many ways there are to form exactly $i$ segments, we can apply the PIE sign $(-1)^{n-i}$ to that count to reach our final answer.

---

## Step-by-Step Explanation

### 1. Preprocessing

We count the frequency `f` of every character. We also precompute **Binomial Coefficients** $\binom{n}{r}$ using Pascal's Triangle logic. This allows us to access combinations in $\mathcal{O}(1)$ time while processing DP.

### 2. The Dynamic Programming State

We define a DP state $$dp[i][j]$$

* `i`: We have processed the first `i` distinct character types.
* `j`: The total number of **segments** formed by these characters.

### 3. The Transition

When introducing a new character with frequency `f`, we decide to split it into `k` segments  ($1 \le k \le f$). This transition involves:

1. **Splitting the characters:** Ways to divide `f` identical items into `k` non-empty segments (Stars and Bars Problem): $$\binom{f - 1}{k - 1}$$

2. **Merging with existing segments:** Ways to interleave these `k` new segments among the `j` segments already processed: $$\binom{j+k}{k}$$

**The Update Rule:**

$$
dp[i][j+k] += dp[i-1][j] \times \binom{f-1}{k-1} \times \binom{j+k}{k}
$$

### 4. Final Parity Simplification

After processing all character groups, we aggregate the values in `dp[groups][i]` using the PIE sign $(-1)^{n-i}$. The sign depends on the parity of $n-i$:

* If $n-i$ is even, the sign is **Positive (+)**.
* If $n-i$ is odd, the sign is **Negative (-)**.

This is equivalent to checking if $(n + i)$ is even: `if ((i + n) % 2 == 0)`.

## Implementation

**Time Complexity: $\mathcal{O}(N^2)$**

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll MOD = 1e9 + 7;
const int MAX_N = 5005;
const int ALPH = 26;

ll nCr[MAX_N][MAX_N];    // Binomial coefficients table
ll dp[ALPH + 3][MAX_N];  // dp[i][j]: i-th char group, j total segments
ll freq[ALPH];           // Frequency of each character

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	string s;
	cin >> s;
	int n = s.size();

	// 1. Count Frequencies
	for (char c : s) freq[c - 'a']++;

	// Filter out characters that don't appear in the string
	vector<int> counts;
	counts.push_back(0);  // Dummy 0-index
	for (int i = 0; i < ALPH; i++)
		if (freq[i]) counts.push_back(freq[i]);

	// 2. Precompute nCr (Pascal's Triangle)
	nCr[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		nCr[i][0] = 1;
		for (int j = 1; j <= n; j++)
			nCr[i][j] = (nCr[i - 1][j - 1] + nCr[i - 1][j]) % MOD;
	}

	// 3. Dynamic Programming
	dp[0][0] = 1;
	int used_len = 0;  // Tracks number of segments processed so far

	for (int i = 1; i < (int)counts.size(); i++) {
		int f = counts[i];  // Frequency of current char

		// Iterate over previous number of segments (j)
		for (int j = 0; j <= used_len; j++) {
			// Iterate over how many segments (k) we split the current char into
			for (int k = 1; k <= f; k++) {

				ll ways = dp[i - 1][j];

				// Ways to split frequency f into k parts
				ways = (ways * nCr[f - 1][k - 1]) % MOD;

				// Ways to interleave k new parts into j existing parts
				ways = (ways * nCr[j + k][k]) % MOD;

				// Update DP state
				dp[i][j + k] = (dp[i][j + k] + ways) % MOD;
			}
		}
		used_len += f;
	}

	// 4. Inclusion-Exclusion
	ll answer = 0;
	int groups = counts.size() - 1;

	for (int i = 0; i <= n; i++) {
		// Apply PIE based on parity
		if ((i + n) % 2 == 0) answer = (answer + dp[groups][i]) % MOD;
		else answer = (answer - dp[groups][i] + MOD) % MOD;
	}

	cout << answer << '\n';
	return 0;
}
```

</CPPSection>
<PySection>

```py
import sys

MOD = 10**9 + 7
MAX_N = 5005
ALPH = 26

s = sys.stdin.readline().strip()
n = len(s)

# frequency of each character
freq = [0] * ALPH
for c in s:
	freq[ord(c) - ord("a")] += 1

# keep only non-zero frequencies
counts = [0]
for f in freq:
	if f:
		counts.append(f)

# precompute binomial coefficients (Pascal triangle)
nCr = [[0] * (n + 1) for _ in range(n + 1)]
nCr[0][0] = 1

for i in range(1, n + 1):
	nCr[i][0] = 1
	for j in range(1, i + 1):
		nCr[i][j] = (nCr[i - 1][j - 1] + nCr[i - 1][j]) % MOD

# dp[i][j] = ways using first i characters to form length j
dp = [[0] * (n + 1) for _ in range(len(counts))]
dp[0][0] = 1

used_len = 0

# process each character group
for i in range(1, len(counts)):
	f = counts[i]

	for j in range(used_len + 1):
		if dp[i - 1][j] == 0:
			continue

		for k in range(1, f + 1):
			ways = dp[i - 1][j] * nCr[f - 1][k - 1] % MOD * nCr[j + k][k] % MOD
			dp[i][j + k] = (dp[i][j + k] + ways) % MOD

	used_len += f

# inclusion-exclusion by parity
answer = 0
groups = len(counts) - 1

for i in range(n + 1):
	if (i + n) % 2 == 0:
		answer = (answer + dp[groups][i]) % MOD
	else:
		answer = (answer - dp[groups][i]) % MOD

print(answer % MOD)
```

</PySection>
</LanguageSection>
