---
id: kattis-segmentdistance
source: Kattis
title: Line Segment Distance
author: Ashok Narayan
---

## Explanation

### Distance of a Point from a Line Segment

Before solving for two segments, we must understand how to find the shortest distance from a single point $P$ to a line segment $AB$.

If we project point $P$ onto the infinite line containing $AB$, the position of the projection can be described by a scalar $t$. If we express the line as $A + t \cdot \vec{AB}$, we can calculate $t$ using the dot product:

$$
t = \frac{\vec{AP} \cdot \vec{AB}}{|\vec{AB}|^2}
$$



This scalar $t$ tells us where the closest point lies relative to the segment:
1.  **$t \le 0$**: The projection falls before $A$. The closest point on the segment is the endpoint **$A$**.
2.  **$t \ge 1$**: The projection falls after $B$. The closest point on the segment is the endpoint **$B$**.
3.  **$0 < t < 1$**: The projection falls strictly between $A$ and $B$. The closest point is the projection itself: $A + t \cdot \vec{AB}$.

The distance is then simply the Euclidean distance between $P$ and this closest point.

### Distance between Line Segments

Now consider two segments, $S_1$ and $S_2$. We can visualize the relationship between them using an iterative process:

1.  Pick an arbitrary point $P_1$ on segment $S_1$.
2.  Find the point $P_2$ on segment $S_2$ that is closest to $P_1$.
3.  From $P_2$, find the point $P_3$ on segment $S_1$ that is closest to $P_2$.

Now it $P_2$ == $P_3$, then the line segments are intersecting. So shortest distance is 0. (Trivial case)

Otherwise keep repeating the process till you get to a point where $P_n$, $P_{n+1}$, $P_{n+2}$, $P_{n+3}$ where $P_n$ == $P_{n+2}$ and $P_{n+1}$ == $P_{n+3}$. This means that we have reached the last loop. Here we can observe that **always** atleast one of $P_n$ or $P_n+1$ is an endpoint of a line segment.  

Therefore, to solve the problem for any case, we simply calculate the minimum of four values:
1.  $\text{dist}(A, S_2)$
2.  $\text{dist}(B, S_2)$
3.  $\text{dist}(C, S_1)$
4.  $\text{dist}(D, S_1)$

### Proof

Why does this observation hold true?

We can formalize this using calculus. The distance function $f(t, u)$ between a point on $S_1$ (parameterized by $t$) and a point on $S_2$ (parameterized by $u$) is a **convex function** over the domain $[0, 1] \times [0, 1]$.

For a convex function defined on a square domain, the minimum value must occur either:
1.  **At a stationary point** where the gradient is zero. This corresponds to the case where the segments are parallel (infinite stationary points) or intersecting (distance is 0).
2.  **On the boundary** of the domain.

If the lines are skew (non-parallel and non-intersecting), there is no stationary point with gradient zero inside the square. Thus, the minimum *must* occur on the boundary of the domain $[0, 1] \times [0, 1]$.

The boundary of this domain corresponds to $t=0$, $t=1$, $u=0$, or $u=1$. Geometrically, these parameter values correspond exactly to the **endpoints** of the segments.


## Implementation

**Time Complexity:** $\mathcal{O}(1)$ per test case.

<LanguageSection>
<CPPSection>

```cpp

#include <bits/stdc++.h>
using namespace std;

using T = double;

// BeginCodeSnip{Point Class}
struct Point {
    T x, y;
    Point(T a = 0, T b = 0) : x(a), y(b) {}
    Point operator-(const Point &other) const { return {x - other.x, y - other.y}; }
    Point operator+(const Point &other) const { return {x + other.x, y + other.y}; }
    Point operator*(T s) const { return {x * s, y * s}; }
    
    T dot(const Point &other) const { return x * other.x + y * other.y; }
    T cross(const Point &other) const { return x * other.y - y * other.x; }
    T dist2() const { return x * x + y * y; }
    double dist(const Point &other) const { return hypot(x - other.x, y - other.y); }

    friend istream &operator>>(istream &in, Point &p) {
        in >> p.x >> p.y;
        return in;
    }
};
// EndCodeSnip

// BeginCodeSnip{Segment Distance}
// Returns 1 if CCW, -1 if CW, 0 if collinear
int sign(double x) {
    if (abs(x) < 1e-9) return 0;
    return (x > 0) ? 1 : -1;
}

// Checks if segment AB intersects segment CD
bool intersect(Point a, Point b, Point c, Point d) {
    auto ccw = [&](Point p1, Point p2, Point p3) {
        return sign((p2 - p1).cross(p3 - p1));
    };
    return ccw(a, b, c) * ccw(a, b, d) <= 0 &&
           ccw(c, d, a) * ccw(c, d, b) <= 0;
}

// Distance from point p to segment ab
double distPointSegment(Point p, Point a, Point b) {
    Point ab = b - a;
    Point ap = p - a;
    
    // Project p onto ab (parameter t)
    double t = ap.dot(ab) / ab.dist2();
    
    // Clamp to segment
    if (t < 0.0) t = 0.0;
    if (t > 1.0) t = 1.0;
    
    Point closest = a + (ab * t);
    return p.dist(closest);
}
// EndCodeSnip

void solve() {
    Point a, b, c, d;
    cin >> a >> b >> c >> d;

    // Case 1: Intersection
    if (intersect(a, b, c, d)) {
        cout << "0.00\n";
    } 
    // Case 2: No Intersection
    else {
        double ans = min({
            distPointSegment(c, a, b),
            distPointSegment(d, a, b),
            distPointSegment(a, c, d),
            distPointSegment(b, c, d)
        });
        cout << ans << "\n";
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << fixed << setprecision(2);
    
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}

```

</CPPSection>
</LanguageSection>
