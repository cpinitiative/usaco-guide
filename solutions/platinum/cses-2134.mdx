---
id: cses-2134
source: CSES
title: Path Queries II
author: Dong Liu
---

# Solution

This problem can solved with [Heavy Light Decomposition](/plat/hld); we can
label each edge as either heavy or light. We can use a segment tree to keep
track of the maximum value in each heavy chain.

Now, to change the value at node $i$ to $x$, we can just update the value in the
segment tree. To query the maximum value in the path from $a$ to $b$, we first
find the [Lowest Common Ancestor](/gold/tree-euler#lca). We combine the path
from $a$ to $lca(a,b)$ and the path from $b$ to $lca(a,b)$ to find our answer.

<LanguageSection>

<CPPSection>

Time complexity: $\mathcal O(N\log^2 N)$

```cpp
#include "bits/stdc++.h"
using namespace std;

const int N = 2e5 + 5;
const int D = 19;
const int S = (1 << D);

int n, q, v[N];
vector<int> adj[N];

int sz[N], p[N][D], dep[N];
int st[S], id[N], tp[N];

void update(int idx, int val, int i = 1, int l = 1, int r = n) {
	if (l == r) {
		st[i] = val;
		return;
	}
	int m = (l + r) / 2;
	if (idx <= m) update(idx, val, i * 2, l, m);
	else update(idx, val, i * 2 + 1, m + 1, r);
	st[i] = max(st[i * 2], st[i * 2 + 1]);
}
int query(int lo, int hi, int i = 1, int l = 1, int r = n) {
	if (lo > r || hi < l) return 0;
	if (lo <= l && r <= hi) return st[i];
	int m = (l + r) / 2;
	return max(query(lo, hi, i * 2, l, m), query(lo, hi, i * 2 + 1, m + 1, r));
}

int dfs_sz(int cur, int par) {
	sz[cur] = 1;
	for (int chi : adj[cur]) {
		if (chi == par) continue;
		dep[chi] = dep[cur] + 1;
		p[chi][0] = cur;
		sz[cur] += dfs_sz(chi, cur);
	}
	return sz[cur];
}
void init_lca() {
	for (int d = 1; d < 18; d++)
		for (int i = 1; i <= n; i++) p[i][d] = p[p[i][d - 1]][d - 1];
}
int ct = 1;
void dfs_hld(int cur, int par, int top) {
	id[cur] = ct++;
	tp[cur] = top;
	update(id[cur], v[cur]);
	int h_chi = -1, h_sz = -1;
	for (int chi : adj[cur]) {
		if (chi == par) continue;
		if (sz[chi] > h_sz) {
			h_sz = sz[chi];
			h_chi = chi;
		}
	}
	if (h_chi == -1) return;
	dfs_hld(h_chi, cur, top);
	for (int chi : adj[cur]) {
		if (chi == par || chi == h_chi) continue;
		dfs_hld(chi, cur, chi);
	}
}
int lca(int a, int b) {
	if (dep[a] < dep[b]) swap(a, b);
	for (int d = D - 1; d >= 0; d--) {
		if (dep[a] - (1 << d) >= dep[b]) { a = p[a][d]; }
	}
	for (int d = D - 1; d >= 0; d--) {
		if (p[a][d] != p[b][d]) {
			a = p[a][d];
			b = p[b][d];
		}
	}
	if (a != b) {
		a = p[a][0];
		b = p[b][0];
	}
	return a;
}
int path(int chi, int par) {
	int ret = 0;
	while (chi != par) {
		if (tp[chi] == chi) {
			ret = max(ret, v[chi]);
			chi = p[chi][0];
		} else if (dep[tp[chi]] > dep[par]) {
			ret = max(ret, query(id[tp[chi]], id[chi]));
			chi = p[tp[chi]][0];
		} else {
			ret = max(ret, query(id[par] + 1, id[chi]));
			break;
		}
	}
	return ret;
}
int main() {

	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; i++) scanf("%d", &v[i]);
	for (int i = 2; i <= n; i++) {
		int a, b;
		scanf("%d%d", &a, &b);
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	dfs_sz(1, 1);
	init_lca();
	memset(st, 0, sizeof st);
	dfs_hld(1, 1, 1);
	while (q--) {
		int t;
		scanf("%d", &t);
		if (t == 1) {
			int s, x;
			scanf("%d%d", &s, &x);
			v[s] = x;
			update(id[s], v[s]);
		} else {
			int a, b;
			scanf("%d%d", &a, &b);
			int c = lca(a, b);
			int res = max(max(path(a, c), path(b, c)), v[c]);
			printf("%d ", res);
		}
	}
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

/**
    Heavy-Light Decomposition (HLD) implementation with Segment Tree.

    This implementation supports:
    1. Updating a single node's value in O(log n)</li>
    2. Querying the maximum value on a path between two nodes in O(log^2 n)</li>

    This solves problems such as:
    - Path Queries II (CSES problem 2134) (This Code shows the solution to this problem)

    Approach:
    1. Perform a DFS to compute subtree sizes.
    2. Decompose the tree into heavy and light chains.
    3. Flatten the tree into an array (Euler order for chains).
    4. Build a segment tree on top of this array for range queries/updates.

    Time Complexity:
    - Build: O(n)
    - Update: O(log n)
    - Path Query: O(log^2 n)
*/

public class PathQueriesHLD {
	static FastScanner sc = new FastScanner(System.in);
	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));

	static int[] values;  // stores initial values of nodes

	public static void main(String[] args) throws IOException {
		Attack();
		out.flush();
	}

	public static void Attack() throws IOException {
		int n = sc.nextInt(), q = sc.nextInt();
		values = new int[n];
		for (int i = 0; i < n; i++) values[i] = sc.nextInt();

		HeavyLightDecomposition hld = new HeavyLightDecomposition(n);
		for (int i = 0; i < n - 1; i++) {
			int u = sc.nextInt() - 1, v = sc.nextInt() - 1;
			hld.addEdge(u, v);
		}

		hld.initialize(0, values);  // root the tree at node 0

		while (q-- > 0) {
			int type = sc.nextInt();
			if (type == 1) {
				// Point update: change node u's value
				int u = sc.nextInt() - 1, newVal = sc.nextInt();
				hld.updateSegmentTree(1, 0, hld.getPositionIndex() - 1,
				                      hld.getPosition(u), newVal);
			} else {
				// Path query: maximum value on path u-v
				int u = sc.nextInt() - 1, v = sc.nextInt() - 1;
				out.println(hld.queryMaxInPath(u, v));
			}
		}
	}

	/**
	    Class for performing Heavy-Light Decomposition (HLD).

	    Internally, it uses:
	    - parent[]: parent of each node
	    - depth[]: depth of each node in the tree
	    - subtreeSize[]: size of subtree rooted at node
	    - chainHead[]: head of the current chain for each node
	    - position[]: flattened position of node in segment tree array
	    - nodeValue[]: node values mapped to flattened array
	    - segmentTree[]: max segment tree for range queries
	*/
	static class HeavyLightDecomposition {
		private List<List<Integer>> tree;  // adjacency list of the tree
		private int[] parent;
		private int[] depth;
		private int[] subtreeSize;
		private int[] chainHead;
		private int[] position;
		private int[] nodeValue;
		private int[] segmentTree;
		private int positionIndex;  // current index in flattened array

		/**
		    Initializes HLD data structures.
		*/
		public HeavyLightDecomposition(int n) {
			tree = new ArrayList<>();
			for (int i = 0; i <= n; i++) tree.add(new ArrayList<>());
			parent = new int[n + 1];
			depth = new int[n + 1];
			subtreeSize = new int[n + 1];
			chainHead = new int[n + 1];
			position = new int[n + 1];
			nodeValue = new int[n + 1];
			segmentTree = new int[4 * (n + 1)];
			for (int i = 0; i <= n; i++) chainHead[i] = -1;
			positionIndex = 0;
		}

		public int getPosition(int index) { return position[index]; }

		public int getPositionIndex() { return positionIndex; }

		/**
		    Adds an undirected edge between two nodes.
		*/
		public void addEdge(int u, int v) {
			tree.get(u).add(v);
			tree.get(v).add(u);
		}

		/**
		    DFS to compute subtree sizes and parent/depth arrays.
		*/
		private void dfsSize(int node, int parentNode) {
			parent[node] = parentNode;
			subtreeSize[node] = 1;
			for (int child : tree.get(node)) {
				if (child != parentNode) {
					depth[child] = depth[node] + 1;
					dfsSize(child, node);
					subtreeSize[node] += subtreeSize[child];
				}
			}
		}

		/**
		    Decompose tree into heavy and light chains.
		    Heavy child = child with maximum subtree size.
		*/
		private void decompose(int node, int head) {
			chainHead[node] = head;
			position[node] = positionIndex++;
			int heavyChild = -1, maxSubtreeSize = -1;
			for (int child : tree.get(node)) {
				if (child != parent[node] && subtreeSize[child] > maxSubtreeSize) {
					heavyChild = child;
					maxSubtreeSize = subtreeSize[child];
				}
			}
			if (heavyChild != -1)  // continue heavy chain
				decompose(heavyChild, head);
			for (int child : tree.get(node)) {
				if (child != parent[node] && child != heavyChild)
					decompose(child, child);  // start new light chain
			}
		}

		/**
		    Build segment tree for range maximum queries.
		*/
		private void buildSegmentTree(int node, int start, int end) {
			if (start == end) {
				segmentTree[node] = nodeValue[start];
				return;
			}
			int mid = (start + end) / 2;
			buildSegmentTree(2 * node, start, mid);
			buildSegmentTree(2 * node + 1, mid + 1, end);
			segmentTree[node] =
			    Math.max(segmentTree[2 * node], segmentTree[2 * node + 1]);
		}

		/**
		    Point update in segment tree.
		*/
		public void updateSegmentTree(int node, int start, int end, int index,
		                              int value) {
			if (start == end) {
				segmentTree[node] = value;
				return;
			}
			int mid = (start + end) / 2;
			if (index <= mid) updateSegmentTree(2 * node, start, mid, index, value);
			else updateSegmentTree(2 * node + 1, mid + 1, end, index, value);
			segmentTree[node] =
			    Math.max(segmentTree[2 * node], segmentTree[2 * node + 1]);
		}

		/**
		    Range maximum query on segment tree.
		*/
		public int querySegmentTree(int node, int start, int end, int left, int right) {
			if (left > end || right < start) return Integer.MIN_VALUE;  // out of range
			if (left <= start && end <= right)
				return segmentTree[node];  // fully covered
			int mid = (start + end) / 2;
			int leftQuery = querySegmentTree(2 * node, start, mid, left, right);
			int rightQuery = querySegmentTree(2 * node + 1, mid + 1, end, left, right);
			return Math.max(leftQuery, rightQuery);
		}

		/**
		    Query maximum value on the path between u and v.
		*/
		public int queryMaxInPath(int u, int v) {
			int result = Integer.MIN_VALUE;
			while (chainHead[u] != chainHead[v]) {
				if (depth[chainHead[u]] < depth[chainHead[v]]) {
					int temp = u;
					u = v;
					v = temp;
				}
				result = Math.max(result, querySegmentTree(1, 0, positionIndex - 1,
				                                           position[chainHead[u]],
				                                           position[u]));
				u = parent[chainHead[u]];
			}
			if (depth[u] > depth[v]) {  // ensure u is ancestor
				int temp = u;
				u = v;
				v = temp;
			}
			result = Math.max(result, querySegmentTree(1, 0, positionIndex - 1,
			                                           position[u], position[v]));
			return result;
		}

		/**
		    Initialize HLD: runs DFS, decomposes tree, builds segment tree.
		*/
		public void initialize(int root, int[] values) {
			dfsSize(root, -1);
			decompose(root, root);
			for (int i = 0; i < values.length; i++) nodeValue[position[i]] = values[i];
			buildSegmentTree(1, 0, positionIndex - 1);
		}
	}

	// -------- Fast Scanner ----------
	static class FastScanner {
		private final InputStream in;
		private final byte[] buffer = new byte[1 << 16];
		private int ptr = 0, len = 0;

		public FastScanner(InputStream is) { in = is; }

		private int readByte() {
			if (ptr >= len) {
				ptr = 0;
				try {
					len = in.read(buffer);
				} catch (IOException e) { throw new RuntimeException(e); }
				if (len <= 0) return -1;
			}
			return buffer[ptr++];
		}

		public int nextInt() {
			int c, sign = 1, val = 0;
			do { c = readByte(); } while (c <= ' ');
			if (c == '-') {
				sign = -1;
				c = readByte();
			}
			while (c > ' ') {
				val = val * 10 + (c - '0');
				c = readByte();
			}
			return val * sign;
		}
	}
}
```

</JavaSection>

</LanguageSection>
