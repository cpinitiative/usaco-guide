---
id: spoj-QueryOnATreeAgain
source: SPOJ
title: Query on a tree again!
author: Rameez Parwez
---

## Explanation

We can solve this problem using Heavy-Light Decomposition (HLD). The process starts with a depth-first search (`dfs1`) to calculate the size of each subtree and identify the heavy child, which is the child with the largest subtree. This information is crucial for breaking down the tree into heavy-light chains.

Next, a second DFS (`dfs2`) assigns positions and chains to each node. Nodes within the same heavy chain are given consecutive positions, making range queries efficient. During this step, the head of each chain is also identified. The dfs2 function ensures that every node is part of exactly one heavy chain, with light edges pointing to different chains.

The solution handles two types of queries: toggling a node's color and finding the nearest colored ancestor. For toggling, each chain maintains a set to keep track of the positions of colored nodes. When a node's color is toggled, it is either added to or removed from this set.

To find the nearest colored ancestor, the solution traverses the tree upwards using the heavy-light chains. It checks the set of colored nodes in each chain, and the smallest position in the set provides the nearest colored ancestor due to the ordered nature of positions within the chains.

## Implementation

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100001;
vector<int> adj[N];
set<int> tree[N];

int heavy[N], par[N], weight[N], pos[N], chain[N], head[N], chains, id;
int color[N], arr[N];

// First DFS to calculate the size of each subtree and determine the heavy child
void dfs1(int u) {
	weight[u] = 1;
	heavy[u] = -1;
	for (auto v : adj[u]) {
		if (v != par[u]) {
			par[v] = u;
			dfs1(v);
			if (heavy[u] == -1 or weight[heavy[u]] < weight[v]) {
				heavy[u] = v;
			}
			weight[u] += weight[v];
		}
	}
}

// Second DFS to decompose the tree into chains and assign positions
void dfs2(int u) {
	if (head[chains] == -1) {
		tree[chains].clear();
		head[chains] = u;
	}

	pos[u] = id;
	chain[u] = chains;
	arr[id++] = u;
	if (heavy[u] != -1) { dfs2(heavy[u]); }

	for (auto v : adj[u]) {
		if (v != par[u] && v != heavy[u]) {
			chains++;
			dfs2(v);
		}
	}
}

void hld(int root, int n) {
	for (int i = 0; i < n; i++) { par[i] = head[i] = -1; }
	chains = 0;
	id = 0;
	dfs1(root);
	dfs2(root);
	chains++;
}

// Query to find the nearest colored ancestor node
int query(int u) {
	int res = -1;
	while (u != -1) {
		if (!tree[chain[u]].empty() and *tree[chain[u]].begin() <= pos[u]) {
			res = arr[*tree[chain[u]].begin()] + 1;
		}
		u = par[head[chain[u]]];
	}
	return res;
}

int main() {
	int n, q;
	cin >> n >> q;
	for (int i = 1; i < n; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

	hld(0, n);
	while (q--) {
		int a, b;
		cin >> a >> b;
		b--;
		if (a > 0) {
			cout << query(b) << '\n';
		} else {
			// Update the color of node b
			if (color[b] ^= 1) {
				tree[chain[b]].insert(pos[b]);
			} else {
				tree[chain[b]].erase(pos[b]);
			}
		}
	}
}
```
</CPPSection>
</LanguageSection>
