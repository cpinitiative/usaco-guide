---
id: spoj-QueryOnATreeAgain
source: SPOJ
title: Query on a tree again!
author: Rameez Parwez
---

## Explanation

This problem can be solved with Heavy-Light Decomposition (HLD); at first we can use one dfs `(dfs1)` to calculate the size of each subtree and identifies the heavy child, which is the child with the largest subtree. This information is crucial for decomposing the tree into heavy-light chains.

Secondly, the second dfs `(dfs2)` assigns positions and chains to each node. Nodes belonging to the same heavy chain are assigned consecutive positions, making range queries efficient. The head of each chain is also identified during this step. The `dfs2` function handles this decomposition, ensuring that each node is part of exactly one heavy chain, and light edges point to different chains.

Queries are processed in two types: toggling the color of a node and finding the nearest colored ancestor. For toggling, a set is maintained for each chain to keep track of the colored nodes' positions. When toggling a node's color, it is either added to or removed from this set.

For the query to find the nearest colored ancestor, the solution traverses the tree upwards using the heavy-light chains. It checks the set of colored nodes in each chain, and the smallest position in the set provides the nearest colored ancestor due to the ordered nature of positions within chains.


## Implementation

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 100001;
vector<int> adj[N];
set<int> tree[N];

int heavy[N], par[N], weight[N], pos[N], chain[N], head[N], chains, id;
int color[N], arr[N];

// First DFS to calculate the size of each subtree and determine the heavy child
void dfs1(int u) {
	weight[u] = 1;
	heavy[u] = -1;
	for (auto v : adj[u]) {
		if (v != par[u]) {
			par[v] = u;
			dfs1(v);
			if (heavy[u] == -1 or weight[heavy[u]] < weight[v]) {
				heavy[u] = v;
			}
			weight[u] += weight[v];
		}
	}
}

// Second DFS to decompose the tree into chains and assign positions
void dfs2(int u) {
	if (head[chains] == -1) {
		tree[chains].clear();
		head[chains] = u;
	}

	pos[u] = id;
	chain[u] = chains;
	arr[id++] = u;
	if (heavy[u] != -1) { dfs2(heavy[u]); }

	for (auto v : adj[u]) {
		if (v != par[u] && v != heavy[u]) {
			chains++;
			dfs2(v);
		}
	}
}

void hld(int root, int n) {
	for (int i = 0; i < n; i++) { par[i] = head[i] = -1; }
	chains = 0;
	id = 0;
	dfs1(root);
	dfs2(root);
	chains++;
}

// Query to find the nearest colored ancestor node
int query(int u) {
	int res = -1;
	while (u != -1) {
		if (!tree[chain[u]].empty() and *tree[chain[u]].begin() <= pos[u]) {
			res = arr[*tree[chain[u]].begin()] + 1;
		}
		u = par[head[chain[u]]];
	}
	return res;
}

int main() {
	int n, q;
	cin >> n >> q;
	for (int i = 1; i < n; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

	hld(0, n);
	while (q--) {
		int a, b;
		cin >> a >> b;
		b--;
		if (a > 0) {
			cout << query(b) << '\n';
		} else {
			// Update the color of node b
			if (color[b] ^= 1) {
				tree[chain[b]].insert(pos[b]);
			} else {
				tree[chain[b]].erase(pos[b]);
			}
		}
	}
}
```
</CPPSection>
</LanguageSection>
