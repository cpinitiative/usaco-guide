---
id: cses-1736
source: CSES
title: Polynomial Queries
author: Albert Ye
---

## Solution
**Time Complexity: $\mathcal{O}(n\log n)$**

Despite the strange operations we can still use a segment tree with lazy propagation
to solve this problem.

The range queries are vanilla lazy propagation, so we should focus more on the updates.

We can split the "update" operation into two operations. One would be a basic range addition,
and the other would be an incremental addition. Therefore, for each index $a_i$, we will need
to keep track of two points: the total offset $s_i$ given only the offset sum (without increments),
and the total increment $t_i$ which contains the sum of all increments from the incremental steps.

When we propagate, the values of $s_i$ and $t_i$ for
a node $k$ representing segment $[i, j]$ 
when updating segment $[l, r]$ can be found by calculating $i-l$, as follows.

- $s_k = s_k + (i-l)$ because we must add an increment $i-l$ to the value of $s_k$ because we are starting at $l + (i-l)$.
- $t_k = t_k + 1$ because the increment increases by 1 during each update.

And when we update the segment tree, the range sum is the sum of the offset and the total increment across the range. Assuming our range is $L$ 
and the range sum for node $k$ is $st[k]$, $st[k] = s_k \cdot L + t_k \cdot \frac{L(L+1)}{2}$. In this case, $s_k \cdot L$ is the sum of all the
offsets in the range, and $t_k \cdot \frac{L(L+1)}{2}$ is the sum of $t_k \cdot (i-l)$ for each $i$ in the range.

## Implementation
<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
 
using namespace st;
using ll = long long;
 
const int MAXN = 200005;
const ll INF = 1e18;
 
int n, q;
vector<ll> x;
 
struct ST
{
	int n;
	vector<ll> a;
	// lz = stores changes in s_i
	// lz2 = stores changes in t_i
	vector<ll> st, lz, lz2;
	ST()
	{
	}
	ST(int n, vector<ll> a)
	{
		this->n = n;
		this->a = a;
		st.resize(4*n);
		lz.resize(4*n);
		lz2.resize(4*n);
	}
 
	void build(int nd, int i, int j)
	{
		if (i == j)
		{
			st[nd] = a[i];
			return;
		}
		int d = (i + j) / 2;
		build(2 * nd, i, d);
		build(2 * nd + 1, d + 1, j);
		lz[nd] = 0;
		st[nd] = st[2 * nd] + st[2 * nd + 1];
	}
 
	void push(int nd, int i, int j, ll p, ll q)
	{
		int len = (j-i+1);
		st[nd] += p*len + q*len*(len+1)/2;
		lz[nd] += p;
		lz2[nd] += q;
	}
 
	void prop(int nd, int i, int j)
	{
		if(i == j) return;
		int d = (i+j)/2;
		push(2*nd, i, d, lz[nd], lz2[nd]);
		push(2*nd+1, d+1, j, lz[nd] + lz2[nd] * (d+1-i), lz2[nd]);
		lz[nd] = lz2[nd] = 0;
	}
 
	// increment
	void upd(int nd, int i, int j, int l, int r, ll v)
	{
		prop(nd, i, j);
		if (i > r || j < l)
			return;			  // not in range
		if (i >= l && j <= r) // completely in range
		{
			push(nd, i, j, i-l, v);
			return;
		}
		int d = (i + j) / 2;
		upd(2 * nd, i, d, l, r, v);
		upd(2 * nd + 1, d + 1, j, l, r, v);
		st[nd] = st[2 * nd] + st[2 * nd + 1];
	}
 
	ll rmq(int nd, int i, int j, int l, int r)
	{
		if (i > r || j < l)
			return 0;
		prop(nd, i, j);
		if (i >= l && j <= r)
			return st[nd];
		int d = (i + j) / 2;
		ll p = rmq(2 * nd, i, d, l, r);
		ll q = rmq(2 * nd + 1, d + 1, j, l, r);
		return p + q;
	}
} st1;
 
int main()
{
	cin >> n >> q;
	x.resize(n);
	for (int i = 0; i < n; i++)
	{
		cin >> x[i];
	}
	st1 = ST(n, x);
	st1.build(1, 0, n-1);
	while (q--)
	{
		int t, a, b;
		cin >> t >> a >> b;
		--a;
		--b;
		if(t == 1)
		{
			st1.upd(1, 0, n-1, a, b, 1);
		} else 
		{
			cout << st1.rmq(1, 0, n-1, a, b) << endl;
		}
	}
}
```
</CPPSection>
</LanguageSection>
