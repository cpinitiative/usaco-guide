---
id: cses-1195
source: CSES
title: Flight Discount
author: Kai Wang, Stanley Zhong, Maggie Liu
---

## Solution 1

Say we use the discount coupon on the edge between cities A and B.

There are two cases: we can go from $1\rightarrow A\rightarrow B\rightarrow N$,
or $1\rightarrow B\rightarrow A\rightarrow N$. We need to know the distance
between $1$ and $A$, and $N$ and $B$.

We can use Dijkstra's to compute the distance from $1$ and $N$ to every vertex.
Then our answer is
$\min\limits_{A\rightarrow B} \texttt{dist1}[A]+c(A,B)+\texttt{distN}[B]$, where
$c(A,B)$ is the cost to travel from city $A$ to city $B$ after applying the
coupon to that flight, $\texttt{dist1}[A]$ is the cost to travel from city $1$
to city $A$ and $\texttt{distN}[B]$ is the cost to travel from city $B$ to city
$N$.

<LanguageSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class FlightDiscount {

	/**
	 * Author : Kai Wang
	 */
	static class Pair implements Comparable<Pair>{
		int v; long w;
		public Pair(int a, long b){
			this.v=a; this.w=b;
		}
		public int compareTo(Pair other){
			if(this.w<other.w)return -1;
			return 1;
		}
	}
	static class FastReader
	{
		BufferedReader br;
		StringTokenizer st;

		public FastReader()
		{
			br = new BufferedReader(new
					 InputStreamReader(System.in));
		}

		String next()
		{
			while (st == null || !st.hasMoreElements())
			{
				try
				{
					st = new StringTokenizer(br.readLine());
				}
				catch (IOException  e)
				{
					e.printStackTrace();
				}
			}
			return st.nextToken();
		}

		int nextInt()
		{
			return Integer.parseInt(next());
		}


	}
	static long MOD=35566483914425l;
	public static void main(String[] args) {
		FastReader br=new FastReader();
		int N=br.nextInt();
		int M=br.nextInt();
		ArrayList<Pair> in[]=new ArrayList[N];
		ArrayList<Pair> out[]=new ArrayList[N];
		for (int i = 0; i < N; i++) {
			in[i]=new ArrayList<>(); out[i]=new ArrayList<>();
		}
		int a,b,c;
		for (int i = 0; i < M; i++) {
			a=br.nextInt()-1;
			b=br.nextInt()-1;
			c=br.nextInt();
			in[b].add(new Pair(a,c));
			out[a].add(new Pair(b,c));
		}
		long[] dist1=new long[N];
		Arrays.fill(dist1, MOD);
		dist1[0]=0;
		PriorityQueue<Pair> pq=new PriorityQueue<>();
		pq.add(new Pair(0,0));
		while(!pq.isEmpty()){
			Pair p=pq.poll();
			for (Pair i :out[p.v]) {
				if(dist1[p.v]+i.w<dist1[i.v]){
					dist1[i.v]=dist1[p.v]+i.w;
					pq.add(new Pair(i.v,dist1[i.v]));
				}

			}
		}
		long[] distN=new long[N];
		Arrays.fill(distN, MOD);
		distN[N-1]=0;

		pq.add(new Pair(N-1,0));
		while(!pq.isEmpty()){
			Pair p=pq.poll();
			for (Pair i :in[p.v]) {
				if(distN[p.v]+i.w<distN[i.v]){
					distN[i.v]=distN[p.v]+i.w;
					pq.add(new Pair(i.v,distN[i.v]));
				}

			}
		}

		long min=MOD;
		for (int i = 0; i < N; i++) {
			for (Pair p: out[i]) {
				min=Math.min(min,dist1[i]+distN[p.v]+p.w/2);
			}
		}
		System.out.println(min);
	}

}
```

</JavaSection>

<CPPSection>

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

int main()
{
	int n, m;
	cin >> n >> m;
	//in[i] contains flights from city i
	//out[i] contains flights to city i
	vector<pair<int, int>> in[100000], out[100000];
	for (int i = 0; i < m; i++)
	{
		int a, b, c;
		cin >> a >> b >> c;
		out[a - 1].push_back({b - 1, c});
		in[b - 1].push_back({a - 1, c});
	}
	priority_queue<pair<long long, int>> q; //(-price, city)
	bool visited[100000]{};

	//find the price to go from city 1 to all other cities
	long long dist1[100000];
	fill(dist1, dist1 + n, 1e18);
	dist1[0] = 0;
	q.push({0, 0});
	while (!q.empty())
	{
		int a = q.top().second;
		q.pop();
		if (visited[a]) continue;
		visited[a] = true;
		for (auto i : out[a])
		{
			int b = i.first, w = i.second;
			if (dist1[a] + w < dist1[b])
			{
				dist1[b] = dist1[a] + w;
				q.push({-dist1[b], b});
			}
		}
	}

	//find the price to go from each city to city n
	long long distn[100000];
	fill(distn, distn + n, 1e18);
	fill(visited, visited + n, false);
	distn[n - 1] = 0;
	q.push({0, n - 1});
	while (!q.empty())
	{
		int a = q.top().second;
		q.pop();
		if (visited[a]) continue;
		visited[a] = true;
		for (auto i : in[a])
		{
			int b = i.first, w = i.second;
			if (distn[a] + w < distn[b])
			{
				distn[b] = distn[a] + w;
				q.push({-distn[b], b});
			}
		}
	}

	//take the minimum cost after using the coupon over all pairs of cities
	long long cost = dist1[n - 1];
	for (int a = 0; a < n; a++)
	{
		for (auto i : out[a])
		{
			int b = i.first, w = i.second;
			cost = min(cost, dist1[a] + distn[b] + w / 2);
		}
	}
	cout << cost << endl;
	return 0;
}
```

</CPPSection>

</LanguageSection>

## Solution 2

Alternatively, we can run Dijkstra's and modify our distance array slightly to
track whether the discount has been used or not.

$\texttt{dist}[i][0]$ will represent the shortest distance from the start node
to node $i$, without using the discount. $\texttt{dist}[i][1]$ will represent
the shortest distance after using the discount.

<LanguageSection>

<CPPSection>

```cpp
// Author: Stanley Zhong
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using pll = pair<ll,ll>;
#define f first
#define s second

// create a struct to store data in a priority_queue
struct Item {
	int node;
	ll cost;
	bool discount;

	Item(int _node, ll _cost, bool _discount) {
		node = _node;
		cost = _cost;
		discount = _discount;
	}

	inline const bool operator<(const Item& other) const {
		if (discount == other.discount) {
			return cost > other.cost;
		}
		return discount > other.discount;
	}
};

const int MN = 100005;

int N, M;
vector<pll> adj[MN];
ll dist[MN][2];
// dist[i][0] represents the shortest distance without discount
// dist[i][1] represents the shortest distance with a discount

int main() {
	cin.tie(0)->sync_with_stdio(0);

	cin >> N >> M;
	for (int i=0; i<M; ++i) {
		ll u, v, c;
		cin >> u >> v >> c;
		--u; --v;
		adj[u].emplace_back(v, c);
	}

	// initialize dist
	for (int i=0; i<N; ++i) {
		dist[i][0] = dist[i][1] = 1e18;
	}

	priority_queue<Item> pq;
	pq.emplace(0, 0, false);

	while (pq.size() > 0) {
		Item cur = pq.top(); pq.pop();

		if (cur.node == N-1 && cur.discount) {
			cout << cur.cost << '\n';
			return 0;
		}

		for (pll nxt: adj[cur.node]) {
			// travel without a discount
			if (dist[nxt.f][cur.discount] > cur.cost + nxt.s) {
				dist[nxt.f][cur.discount] = cur.cost + nxt.s;
				pq.emplace(nxt.f, dist[nxt.f][cur.discount], cur.discount);
			}
			// if we haven't used the discount yet, try using it on this edge
			if (cur.discount == false) {
				if (dist[nxt.f][true] > cur.cost + nxt.s / 2) {
					dist[nxt.f][true] = cur.cost + nxt.s / 2;
					pq.emplace(nxt.f, dist[nxt.f][true], true);
				}
			}
		}
	}

	// it is guaranteed that we can reach our destination, so this should never happen
	assert(false);
}
```

</CPPSection>

</LanguageSection>
