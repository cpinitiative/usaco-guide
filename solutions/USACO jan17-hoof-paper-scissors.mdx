---
id: usaco-691
source: USACO Silver 2017 January
title: Hoof, Paper, Scissors
author: Ã“scar Garries (C++), Owen Wang (Java), Mrinall Umausdhan (Editorial)
---

[Official Analysis](http://www.usaco.org/current/data/sol_hps_silver_jan17.html)

Editorial: As opposed to the official editorial there also exists a simpler solution in which one does not need to get involved with multiple 2D arrays, instead there is also a fairly straightforward solution using prefix sums with 1D arrays. To find the maximum amounts of wins we simply have to simulate changing the gesture in each index in the moves array we are provided within the input. Now the problem is narrowed down to two questions. How do we efficiently calculate the best place we need to change the gesture or if we need to change it at all? And how do we calculate the number of wins of a certain gesture given the range of turns the gesture is played? Well to calculate the number of wins a gesture makes given the range of turns it is used we have to maintain a prefix sum for each of the three gestures so any given range we can find the number of wins for a specific gesture. Now to find the area where the gesture should be changed to maximize wins we then go through each index of the array and use the given ranges of $\texttt{moves[1]}$  to $\texttt{moves[i]}$, apply it to the prefix sums and add the number of wins to the prefix sum that outputs the greatest amount of wins; Meaning that gesture gives the largest amount of wins in that range. We then repeat the same process for the ranges of $\texttt{moves[i]}$ to $\texttt{moves[N]}$ and add the value to the greatest amount of wins in the range $\texttt{moves[1]}$ to $\texttt{moves[i]}$ as specified in a previous step. Finally, we store the greatest sum of wins in the simulation of changing gestures and output the answer. 

<LanguageSection>
<CPPSection>

## C++ Implementation

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	freopen("hps.in", "r", stdin);
	freopen("hps.out", "w", stdout);

	int n;
	cin >> n;
	vector<int> h(n + 1), p(n + 1), s(n + 1);

	for (int i = 0; i < n; i++) {
		h[i + 1] = h[i];
		p[i + 1] = p[i];
		s[i + 1] = s[i];

		char cur;
		cin >> cur;
		if (cur == 'P') p[i + 1]++;
		else if (cur == 'H') h[i + 1]++;
		else s[i + 1]++;
	}

	int sol = 0;

	for (int i = 1; i <= n; i++) {
		auto update = [&] (vector<int>& a, vector<int>& b) {
				sol = max(sol, a[i] + b[n] - b[i]);
		};
		update(h, p);
		update(h, s);
		update(p, s);
		update(p, h);
		update(s, h);
		update(s, p);
	}

	cout << sol << '\n';
}

```

</CPPSection>
<JavaSection>

## Java Implementation

```java
import java.io.File;
import java.io.PrintWriter;
import java.util.Scanner;

public class hps {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(new File("hps.in"));
        PrintWriter out = new PrintWriter("hps.out");

        int N = sc.nextInt();
        int[] hooves = new int[N + 1];
        int[] paper = new int[N + 1];
        int[] scissors = new int[N + 1];

        for (int i = 1; i < N + 1; i++) {
            char action = sc.next().charAt(0);
            hooves[i] += hooves[i - 1];
            paper[i] += paper[i - 1];
            scissors[i] += scissors[i - 1];
            if (action == 'H') {
                paper[i] ++;
            } else if (action == 'P') {
                scissors[i] ++;
            } else if (action == 'S') {
                hooves[i] ++;
            }
        }

        sc.close();

        int max = 0;

        for (int i = 1; i < N + 1; i++) {
            int beforeWin = Math.max(hooves[i], Math.max(paper[i], scissors[i]));
            int afterWin = Math.max(hooves[N] - hooves[i], Math.max(paper[N] - paper[i], scissors[N] - scissors[i]));

            max = Math.max(max, beforeWin + afterWin);
        }

        out.println(max);
        out.close();
    }
}
```

</JavaSection>


</LanguageSection>
